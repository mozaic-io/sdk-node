/* tslint:disable */
/* eslint-disable */
/**
 * Mozaic.io API Documentation
 * A global payment, payout and smart contract for the Creator Economy.
 *
 * The version of the OpenAPI document: v2
 * Contact: dev@jammber.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *   pending  accepted  suspended
 * export
 * @enum {string}
 */

export const AcceptPaymentStatusEnum = {
    /**
    * 
    */
    Pending: 'pending',
    /**
    * 
    */
    Accepted: 'accepted',
    /**
    * 
    */
    Suspended: 'suspended'
} as const;

export type AcceptPaymentStatusEnum = typeof AcceptPaymentStatusEnum[keyof typeof AcceptPaymentStatusEnum];


/**
 * 
 * export
 * @interface AccessControlRule
 */
export interface AccessControlRule {
    /**
     * 
     * @type {string}
     * memberof AccessControlRule
     */
    'AccountId'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccessControlRule
     */
    'UserId'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccessControlRule
     */
    'RoleName'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof AccessControlRule
     */
    'ValueFound'?: boolean;
    /**
     * 
     * @type {string}
     * memberof AccessControlRule
     */
    'ResourcePath'?: string | null;
    /**
     * 
     * @type {AccessPerspective}
     * memberof AccessControlRule
     */
    'Perspective'?: AccessPerspective;
    /**
     * 
     * @type {LicenseAssignmentStatuses}
     * memberof AccessControlRule
     */
    'LicenseStatus'?: LicenseAssignmentStatuses;
    /**
     * 
     * @type {number}
     * memberof AccessControlRule
     */
    'ResourceAccessId'?: number;
    /**
     * 
     * @type {string}
     * memberof AccessControlRule
     */
    'UID'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccessControlRule
     */
    'PersonaId'?: string | null;
    /**
     * 
     * @type {number}
     * memberof AccessControlRule
     */
    'RestrictionLevel'?: number;
    /**
     * 
     * @type {boolean}
     * memberof AccessControlRule
     */
    'CanEdit'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccessControlRule
     */
    'CanView'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccessControlRule
     */
    'CanDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccessControlRule
     */
    'CanCreate'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccessControlRule
     */
    'CanDownload'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccessControlRule
     */
    'AllowSensitive'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccessControlRule
     */
    'AcceptanceRequired'?: boolean;
    /**
     * 
     * @type {string}
     * memberof AccessControlRule
     */
    'ResourceAccessUID'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof AccessControlRule
     */
    'HasExplicitAccess'?: boolean;
}


/**
 *   none  self  collaborators  all  invite  admin  webHook
 * export
 * @enum {string}
 */

export const AccessPerspective = {
    /**
    * 
    */
    None: 'none',
    /**
    * 
    */
    Self: 'self',
    /**
    * 
    */
    Collaborators: 'collaborators',
    /**
    * 
    */
    All: 'all',
    /**
    * 
    */
    Invite: 'invite',
    /**
    * 
    */
    Admin: 'admin',
    /**
    * 
    */
    WebHook: 'webHook'
} as const;

export type AccessPerspective = typeof AccessPerspective[keyof typeof AccessPerspective];


/**
 * 
 * export
 * @interface AccountSession
 */
export interface AccountSession {
    /**
     * 
     * @type {string}
     * memberof AccountSession
     */
    'object'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccountSession
     */
    'account'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccountSession
     */
    'client_secret'?: string | null;
    /**
     * 
     * @type {AccountSessionComponents}
     * memberof AccountSession
     */
    'components'?: AccountSessionComponents;
    /**
     * 
     * @type {string}
     * memberof AccountSession
     */
    'expires_at'?: string;
    /**
     * 
     * @type {boolean}
     * memberof AccountSession
     */
    'livemode'?: boolean;
}
/**
 * 
 * export
 * @interface AccountSessionComponents
 */
export interface AccountSessionComponents {
    /**
     * 
     * @type {AccountSessionComponentsAccountManagement}
     * memberof AccountSessionComponents
     */
    'account_management'?: AccountSessionComponentsAccountManagement;
    /**
     * 
     * @type {AccountSessionComponentsAccountOnboarding}
     * memberof AccountSessionComponents
     */
    'account_onboarding'?: AccountSessionComponentsAccountOnboarding;
    /**
     * 
     * @type {AccountSessionComponentsBalances}
     * memberof AccountSessionComponents
     */
    'balances'?: AccountSessionComponentsBalances;
    /**
     * 
     * @type {AccountSessionComponentsCapitalFinancing}
     * memberof AccountSessionComponents
     */
    'capital_financing'?: AccountSessionComponentsCapitalFinancing;
    /**
     * 
     * @type {AccountSessionComponentsCapitalFinancingApplication}
     * memberof AccountSessionComponents
     */
    'capital_financing_application'?: AccountSessionComponentsCapitalFinancingApplication;
    /**
     * 
     * @type {AccountSessionComponentsCapitalFinancingPromotion}
     * memberof AccountSessionComponents
     */
    'capital_financing_promotion'?: AccountSessionComponentsCapitalFinancingPromotion;
    /**
     * 
     * @type {AccountSessionComponentsDocuments}
     * memberof AccountSessionComponents
     */
    'documents'?: AccountSessionComponentsDocuments;
    /**
     * 
     * @type {AccountSessionComponentsNotificationBanner}
     * memberof AccountSessionComponents
     */
    'notification_banner'?: AccountSessionComponentsNotificationBanner;
    /**
     * 
     * @type {AccountSessionComponentsPaymentDetails}
     * memberof AccountSessionComponents
     */
    'payment_details'?: AccountSessionComponentsPaymentDetails;
    /**
     * 
     * @type {AccountSessionComponentsPayments}
     * memberof AccountSessionComponents
     */
    'payments'?: AccountSessionComponentsPayments;
    /**
     * 
     * @type {AccountSessionComponentsPayouts}
     * memberof AccountSessionComponents
     */
    'payouts'?: AccountSessionComponentsPayouts;
    /**
     * 
     * @type {AccountSessionComponentsPayoutsList}
     * memberof AccountSessionComponents
     */
    'payouts_list'?: AccountSessionComponentsPayoutsList;
    /**
     * 
     * @type {AccountSessionComponentsTaxRegistrations}
     * memberof AccountSessionComponents
     */
    'tax_registrations'?: AccountSessionComponentsTaxRegistrations;
    /**
     * 
     * @type {AccountSessionComponentsTaxSettings}
     * memberof AccountSessionComponents
     */
    'tax_settings'?: AccountSessionComponentsTaxSettings;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsAccountManagement
 */
export interface AccountSessionComponentsAccountManagement {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsAccountManagement
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {AccountSessionComponentsAccountManagementFeatures}
     * memberof AccountSessionComponentsAccountManagement
     */
    'features'?: AccountSessionComponentsAccountManagementFeatures;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsAccountManagementFeatures
 */
export interface AccountSessionComponentsAccountManagementFeatures {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsAccountManagementFeatures
     */
    'disable_stripe_user_authentication'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsAccountManagementFeatures
     */
    'external_account_collection'?: boolean;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsAccountOnboarding
 */
export interface AccountSessionComponentsAccountOnboarding {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsAccountOnboarding
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {AccountSessionComponentsAccountOnboardingFeatures}
     * memberof AccountSessionComponentsAccountOnboarding
     */
    'features'?: AccountSessionComponentsAccountOnboardingFeatures;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsAccountOnboardingFeatures
 */
export interface AccountSessionComponentsAccountOnboardingFeatures {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsAccountOnboardingFeatures
     */
    'disable_stripe_user_authentication'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsAccountOnboardingFeatures
     */
    'external_account_collection'?: boolean;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsBalances
 */
export interface AccountSessionComponentsBalances {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsBalances
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {AccountSessionComponentsBalancesFeatures}
     * memberof AccountSessionComponentsBalances
     */
    'features'?: AccountSessionComponentsBalancesFeatures;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsBalancesFeatures
 */
export interface AccountSessionComponentsBalancesFeatures {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsBalancesFeatures
     */
    'disable_stripe_user_authentication'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsBalancesFeatures
     */
    'edit_payout_schedule'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsBalancesFeatures
     */
    'external_account_collection'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsBalancesFeatures
     */
    'instant_payouts'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsBalancesFeatures
     */
    'standard_payouts'?: boolean;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsCapitalFinancing
 */
export interface AccountSessionComponentsCapitalFinancing {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsCapitalFinancing
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * memberof AccountSessionComponentsCapitalFinancing
     */
    'features'?: object;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsCapitalFinancingApplication
 */
export interface AccountSessionComponentsCapitalFinancingApplication {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsCapitalFinancingApplication
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * memberof AccountSessionComponentsCapitalFinancingApplication
     */
    'features'?: object;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsCapitalFinancingPromotion
 */
export interface AccountSessionComponentsCapitalFinancingPromotion {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsCapitalFinancingPromotion
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * memberof AccountSessionComponentsCapitalFinancingPromotion
     */
    'features'?: object;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsDocuments
 */
export interface AccountSessionComponentsDocuments {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsDocuments
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * memberof AccountSessionComponentsDocuments
     */
    'features'?: object;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsNotificationBanner
 */
export interface AccountSessionComponentsNotificationBanner {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsNotificationBanner
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {AccountSessionComponentsNotificationBannerFeatures}
     * memberof AccountSessionComponentsNotificationBanner
     */
    'features'?: AccountSessionComponentsNotificationBannerFeatures;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsNotificationBannerFeatures
 */
export interface AccountSessionComponentsNotificationBannerFeatures {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsNotificationBannerFeatures
     */
    'disable_stripe_user_authentication'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsNotificationBannerFeatures
     */
    'external_account_collection'?: boolean;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsPaymentDetails
 */
export interface AccountSessionComponentsPaymentDetails {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPaymentDetails
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {AccountSessionComponentsPaymentDetailsFeatures}
     * memberof AccountSessionComponentsPaymentDetails
     */
    'features'?: AccountSessionComponentsPaymentDetailsFeatures;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsPaymentDetailsFeatures
 */
export interface AccountSessionComponentsPaymentDetailsFeatures {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPaymentDetailsFeatures
     */
    'capture_payments'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPaymentDetailsFeatures
     */
    'destination_on_behalf_of_charge_management'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPaymentDetailsFeatures
     */
    'dispute_management'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPaymentDetailsFeatures
     */
    'refund_management'?: boolean;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsPayments
 */
export interface AccountSessionComponentsPayments {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPayments
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {AccountSessionComponentsPaymentsFeatures}
     * memberof AccountSessionComponentsPayments
     */
    'features'?: AccountSessionComponentsPaymentsFeatures;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsPaymentsFeatures
 */
export interface AccountSessionComponentsPaymentsFeatures {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPaymentsFeatures
     */
    'capture_payments'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPaymentsFeatures
     */
    'destination_on_behalf_of_charge_management'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPaymentsFeatures
     */
    'dispute_management'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPaymentsFeatures
     */
    'refund_management'?: boolean;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsPayouts
 */
export interface AccountSessionComponentsPayouts {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPayouts
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {AccountSessionComponentsPayoutsFeatures}
     * memberof AccountSessionComponentsPayouts
     */
    'features'?: AccountSessionComponentsPayoutsFeatures;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsPayoutsFeatures
 */
export interface AccountSessionComponentsPayoutsFeatures {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPayoutsFeatures
     */
    'disable_stripe_user_authentication'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPayoutsFeatures
     */
    'edit_payout_schedule'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPayoutsFeatures
     */
    'external_account_collection'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPayoutsFeatures
     */
    'instant_payouts'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPayoutsFeatures
     */
    'standard_payouts'?: boolean;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsPayoutsList
 */
export interface AccountSessionComponentsPayoutsList {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsPayoutsList
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * memberof AccountSessionComponentsPayoutsList
     */
    'features'?: object;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsTaxRegistrations
 */
export interface AccountSessionComponentsTaxRegistrations {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsTaxRegistrations
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * memberof AccountSessionComponentsTaxRegistrations
     */
    'features'?: object;
}
/**
 * 
 * export
 * @interface AccountSessionComponentsTaxSettings
 */
export interface AccountSessionComponentsTaxSettings {
    /**
     * 
     * @type {boolean}
     * memberof AccountSessionComponentsTaxSettings
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * memberof AccountSessionComponentsTaxSettings
     */
    'features'?: object;
}
/**
 * 
 * export
 * @interface AccountUserPersona
 */
export interface AccountUserPersona {
    /**
     * 
     * @type {string}
     * memberof AccountUserPersona
     */
    'contact_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccountUserPersona
     */
    'user_account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccountUserPersona
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccountUserPersona
     */
    'known_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccountUserPersona
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccountUserPersona
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccountUserPersona
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccountUserPersona
     */
    'mobile_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AccountUserPersona
     */
    'role'?: string | null;
}
/**
 * 
 * export
 * @interface Activity
 */
export interface Activity {
    /**
     * id of the object this activity is associated with
     * @type {string}
     * memberof Activity
     */
    'key'?: string | null;
    /**
     * 
     * @type {ActivityType}
     * memberof Activity
     */
    'type'?: ActivityType;
    /**
     * 
     * @type {ActivityStatus}
     * memberof Activity
     */
    'status'?: ActivityStatus;
    /**
     * A short description of the activity (pulled from a resource file)
     * @type {string}
     * memberof Activity
     */
    'title'?: string | null;
    /**
     * A full description of the activity (pulled from a resouce file)
     * @type {string}
     * memberof Activity
     */
    'caption'?: string | null;
    /**
     * Id of the User associated with this Payment\'s wallet
     * @type {string}
     * memberof Activity
     */
    'user_id'?: string | null;
    /**
     * Id of the Persona associated with this Payment\'s wallet
     * @type {string}
     * memberof Activity
     */
    'persona_id'?: string | null;
    /**
     * Id of the account authorized to send payments
     * @type {string}
     * memberof Activity
     */
    'tenant_id'?: string | null;
    /**
     * 
     * @type {Array<ActivityTask>}
     * memberof Activity
     */
    'tasks'?: Array<ActivityTask> | null;
    /**
     * 
     * @type {string}
     * memberof Activity
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Activity
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Activity
     */
    'created_at'?: string;
}


/**
 *   unknown  started  pending  completed  needsAttention  failed  notStarted
 * export
 * @enum {string}
 */

export const ActivityStatus = {
    /**
    * 
    */
    Unknown: 'unknown',
    /**
    * 
    */
    Started: 'started',
    /**
    * 
    */
    Pending: 'pending',
    /**
    * 
    */
    Completed: 'completed',
    /**
    * 
    */
    NeedsAttention: 'needsAttention',
    /**
    * 
    */
    Failed: 'failed',
    /**
    * 
    */
    NotStarted: 'notStarted'
} as const;

export type ActivityStatus = typeof ActivityStatus[keyof typeof ActivityStatus];


/**
 * 
 * export
 * @interface ActivityTask
 */
export interface ActivityTask {
    /**
     * 
     * @type {string}
     * memberof ActivityTask
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ActivityTask
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ActivityTask
     */
    'link'?: string | null;
    /**
     * 
     * @type {ActivityTaskStatus}
     * memberof ActivityTask
     */
    'status'?: ActivityTaskStatus;
    /**
     * 
     * @type {string}
     * memberof ActivityTask
     */
    'date_completed'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ActivityTask
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ActivityTask
     */
    'created_at'?: string;
}


/**
 *   notStarted  inProgress  completed
 * export
 * @enum {string}
 */

export const ActivityTaskStatus = {
    /**
    * 
    */
    NotStarted: 'notStarted',
    /**
    * 
    */
    InProgress: 'inProgress',
    /**
    * 
    */
    Completed: 'completed'
} as const;

export type ActivityTaskStatus = typeof ActivityTaskStatus[keyof typeof ActivityTaskStatus];


/**
 * 
 * export
 * @interface ActivityTaskUpdateDeets
 */
export interface ActivityTaskUpdateDeets {
    /**
     * The id of the object this activity is associated with
     * @type {string}
     * memberof ActivityTaskUpdateDeets
     */
    'key'?: string | null;
    /**
     * 
     * @type {ActivityType}
     * memberof ActivityTaskUpdateDeets
     */
    'type': ActivityType;
    /**
     * 
     * @type {ActivityTaskStatus}
     * memberof ActivityTaskUpdateDeets
     */
    'status': ActivityTaskStatus;
    /**
     * Specifies the id of the activity task
     * @type {string}
     * memberof ActivityTaskUpdateDeets
     */
    'task_id': string;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof ActivityTaskUpdateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ActivityTaskUpdateDeets
     */
    'object'?: string | null;
}


/**
 *   contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
 * export
 * @enum {string}
 */

export const ActivityType = {
    /**
    * 
    */
    ContactCreated: 'contactCreated',
    /**
    * 
    */
    Invited: 'invited',
    /**
    * 
    */
    Onboarded: 'onboarded',
    /**
    * 
    */
    ReadyForPayouts: 'readyForPayouts',
    /**
    * 
    */
    FirstPayout: 'firstPayout',
    /**
    * 
    */
    FirstPayment: 'firstPayment'
} as const;

export type ActivityType = typeof ActivityType[keyof typeof ActivityType];


/**
 * 
 * export
 * @interface AddressDeets
 */
export interface AddressDeets {
    /**
     * Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
     * @type {string}
     * memberof AddressDeets
     */
    'common_name'?: string | null;
    /**
     * Address line 1
     * @type {string}
     * memberof AddressDeets
     */
    'line1'?: string | null;
    /**
     * Address line 2
     * @type {string}
     * memberof AddressDeets
     */
    'line2'?: string | null;
    /**
     * City name
     * @type {string}
     * memberof AddressDeets
     */
    'city'?: string | null;
    /**
     * Latitude and Longitude
     * @type {string}
     * memberof AddressDeets
     */
    'lat_long'?: string | null;
    /**
     * Postal code or ZIP code
     * @type {string}
     * memberof AddressDeets
     */
    'postal_code'?: string | null;
    /**
     * State, region or province
     * @type {string}
     * memberof AddressDeets
     */
    'state_region'?: string | null;
    /**
     * Two-letter country code <see href=\"https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\">ISO 3166-1 alpha-2</see>
     * @type {string}
     * memberof AddressDeets
     */
    'country_code'?: string | null;
}
/**
 * 
 * export
 * @interface Amount
 */
export interface Amount {
    /**
     * The currency of the amount
     * @type {string}
     * memberof Amount
     */
    'currency'?: string | null;
    /**
     * The id of the wallet to use.   If an Wallet id is not specified the platform balance is used if  the amount is less than or equal to the balance, otherwise the default  Wallet for the currency will be charged
     * @type {string}
     * memberof Amount
     */
    'wallet_id'?: string | null;
    /**
     * The quantity of Currency to send  Note that quantity is either base units or fractional depending on the currency and wallet type
     * @type {number}
     * memberof Amount
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * memberof Amount
     */
    'formatted_quantity'?: string | null;
}
/**
 * 
 * export
 * @interface AttributionDeets
 */
export interface AttributionDeets {
    /**
     * The role or credit of the attribution
     * @type {string}
     * memberof AttributionDeets
     */
    'Role'?: string | null;
    /**
     * 
     * @type {ContactDeets}
     * memberof AttributionDeets
     */
    'Contact'?: ContactDeets;
}
/**
 * 
 * export
 * @interface AvatarBytes
 */
export interface AvatarBytes {
    /**
     * A base64 encoded byte array for the PNG image
     * @type {string}
     * memberof AvatarBytes
     */
    'base64_bytes'?: string | null;
}
/**
 * 
 * export
 * @interface AvatarPromptCreateDeets
 */
export interface AvatarPromptCreateDeets {
    /**
     * 
     * @type {string}
     * memberof AvatarPromptCreateDeets
     */
    'prompt'?: string | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof AvatarPromptCreateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof AvatarPromptCreateDeets
     */
    'object'?: string | null;
}
/**
 *   default  contact  simpleContarct  paymentCycle
 * export
 * @enum {string}
 */

export const AvatarType = {
    /**
    * 
    */
    Default: 'default',
    /**
    * 
    */
    Contact: 'contact',
    /**
    * 
    */
    SimpleContarct: 'simpleContarct',
    /**
    * 
    */
    PaymentCycle: 'paymentCycle'
} as const;

export type AvatarType = typeof AvatarType[keyof typeof AvatarType];


/**
 *   contact  simpleContarct  paymentCycle  profile
 * export
 * @enum {string}
 */

export const AvatarTypeEnum = {
    /**
    * 
    */
    Contact: 'contact',
    /**
    * 
    */
    SimpleContarct: 'simpleContarct',
    /**
    * 
    */
    PaymentCycle: 'paymentCycle',
    /**
    * 
    */
    Profile: 'profile'
} as const;

export type AvatarTypeEnum = typeof AvatarTypeEnum[keyof typeof AvatarTypeEnum];


/**
 * 
 * export
 * @interface Balance
 */
export interface Balance {
    /**
     * 
     * @type {string}
     * memberof Balance
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {number}
     * memberof Balance
     */
    'available'?: number;
    /**
     * 
     * @type {string}
     * memberof Balance
     */
    'formatted_available'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Balance
     */
    'currency'?: string | null;
    /**
     * 
     * @type {number}
     * memberof Balance
     */
    'money_in'?: number;
    /**
     * 
     * @type {string}
     * memberof Balance
     */
    'formatted_money_in'?: string | null;
    /**
     * 
     * @type {number}
     * memberof Balance
     */
    'money_out'?: number;
    /**
     * 
     * @type {string}
     * memberof Balance
     */
    'formatted_money_out'?: string | null;
    /**
     * 
     * @type {BalanceEntry}
     * memberof Balance
     */
    'bitcoin_entry'?: BalanceEntry;
    /**
     * 
     * @type {BalanceEntry}
     * memberof Balance
     */
    'platform-us'?: BalanceEntry;
    /**
     * 
     * @type {BalanceEntry}
     * memberof Balance
     */
    'pending_balance'?: BalanceEntry;
    /**
     * 
     * @type {BalanceEntry}
     * memberof Balance
     */
    'suspended_balance'?: BalanceEntry;
    /**
     * 
     * @type {string}
     * memberof Balance
     */
    'tenant_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Balance
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Balance
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Balance
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface BalanceEntry
 */
export interface BalanceEntry {
    /**
     * 
     * @type {string}
     * memberof BalanceEntry
     */
    'wallet_key'?: string | null;
    /**
     * 
     * @type {string}
     * memberof BalanceEntry
     */
    'currency'?: string | null;
    /**
     * 
     * @type {number}
     * memberof BalanceEntry
     */
    'available'?: number;
    /**
     * 
     * @type {string}
     * memberof BalanceEntry
     */
    'formatted_available'?: string | null;
    /**
     * 
     * @type {number}
     * memberof BalanceEntry
     */
    'money_in'?: number;
    /**
     * 
     * @type {string}
     * memberof BalanceEntry
     */
    'formatted_money_in'?: string | null;
    /**
     * 
     * @type {number}
     * memberof BalanceEntry
     */
    'money_out'?: number;
    /**
     * 
     * @type {string}
     * memberof BalanceEntry
     */
    'formatted_money_out'?: string | null;
}
/**
 * 
 * export
 * @interface BaseError
 */
export interface BaseError {
    /**
     * The error message
     * @type {string}
     * memberof BaseError
     */
    'message'?: string | null;
    /**
     * The error code
     * @type {number}
     * memberof BaseError
     */
    'code'?: number;
}
/**
 * 
 * export
 * @interface BaseTerms
 */
export interface BaseTerms {
    /**
     * 
     * @type {string}
     * memberof BaseTerms
     */
    '$entity'?: string | null;
    /**
     * 
     * @type {string}
     * memberof BaseTerms
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof BaseTerms
     */
    'description'?: string | null;
    /**
     * 
     * @type {TermHeader}
     * memberof BaseTerms
     */
    'header'?: TermHeader;
    /**
     * 
     * @type {TermScope}
     * memberof BaseTerms
     */
    'scope'?: TermScope;
    /**
     * 
     * @type {PayoutTerm}
     * memberof BaseTerms
     */
    'payout'?: PayoutTerm;
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * memberof BaseTerms
     */
    'meta_data'?: { [key: string]: string | null; } | null;
    /**
     * 
     * @type {Array<BaseTermsDescendentsInner>}
     * memberof BaseTerms
     */
    'descendents'?: Array<BaseTermsDescendentsInner> | null;
    /**
     * 
     * @type {TermBalance}
     * memberof BaseTerms
     */
    'previous_balance'?: TermBalance;
}
/**
 * @type BaseTermsDescendentsInner
 * export
 */
export type BaseTermsDescendentsInner = BaseTerms | FlatAmountTerm | FlatRateTerm | Income | RecoupableTerm | TieredTerm | TieredTermTieredGroupTerm;

/**
 * A lightweight object for specifying \'to\' and \'from\' addresses  and other forms of general contact
 * export
 * @interface BasicContact
 */
export interface BasicContact {
    /**
     * The Mozaic handle for a contact
     * @type {string}
     * memberof BasicContact
     */
    'handle'?: string | null;
    /**
     * The email address of the contact
     * @type {string}
     * memberof BasicContact
     */
    'email'?: string | null;
    /**
     * The fully qualified phone number of the contact
     * @type {string}
     * memberof BasicContact
     */
    'phone'?: string | null;
    /**
     * Loosely, the name of the contact. May be changed during registration
     * @type {string}
     * memberof BasicContact
     */
    'name': string;
    /**
     * Specifies the persona associated with this contact record
     * @type {string}
     * memberof BasicContact
     */
    'persona_id'?: string | null;
    /**
     * Specifies the user associated with this contact record
     * @type {string}
     * memberof BasicContact
     */
    'user_id'?: string | null;
    /**
     * Specifies the user account id associated with this contact record
     * @type {string}
     * memberof BasicContact
     */
    'user_account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof BasicContact
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof BasicContact
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof BasicContact
     */
    'created_at'?: string;
}
/**
 * A lightweight object for specifying \'to\' and \'from\' addresses  and other forms of general contact
 * export
 * @interface BasicContactDeets
 */
export interface BasicContactDeets {
    /**
     * This can be either an email, mobile number, or mozaic handle
     * @type {string}
     * memberof BasicContactDeets
     */
    'point_of_contact': string;
    /**
     * Loosely, the name of the contact. May be changed during registration
     * @type {string}
     * memberof BasicContactDeets
     */
    'name': string;
    /**
     * 
     * @type {string}
     * memberof BasicContactDeets
     */
    'user_account_id'?: string | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof BasicContactDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof BasicContactDeets
     */
    'object'?: string | null;
}
/**
 * A list of BasicContact objects that have been mapped to Personas
 * export
 * @interface BasicContacts
 */
export interface BasicContacts {
    /**
     * 
     * @type {Array<BasicContact>}
     * memberof BasicContacts
     */
    'data'?: Array<BasicContact> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof BasicContacts
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof BasicContacts
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof BasicContacts
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface BatchRun
 */
export interface BatchRun {
    /**
     * 
     * @type {string}
     * memberof BatchRun
     */
    'partner_account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof BatchRun
     */
    'batch_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof BatchRun
     */
    'run_at'?: string;
}
/**
 * 
 * export
 * @interface BillingDeets
 */
export interface BillingDeets {
    /**
     * 
     * @type {string}
     * memberof BillingDeets
     */
    'name'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof BillingDeets
     */
    'address'?: AddressDeets;
    /**
     * 
     * @type {string}
     * memberof BillingDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface BulkErrorResponse
 */
export interface BulkErrorResponse {
    /**
     * 
     * @type {string}
     * memberof BulkErrorResponse
     */
    'message'?: string | null;
    /**
     * 
     * @type {number}
     * memberof BulkErrorResponse
     */
    'number'?: number;
}
/**
 * 
 * export
 * @interface CatalogEntryDeets
 */
export interface CatalogEntryDeets {
    /**
     * The id of a catalog this PortfolioItem belongs to
     * @type {string}
     * memberof CatalogEntryDeets
     */
    'catalog_id': string;
    /**
     * The ordinal position when necessary, otherwise ignored
     * @type {number}
     * memberof CatalogEntryDeets
     */
    'ordinal'?: number;
}
/**
 * 
 * export
 * @interface Connector
 */
export interface Connector {
    /**
     * Connector name.
     * @type {string}
     * memberof Connector
     */
    'connector_name'?: string | null;
    /**
     * Connector id.  It will be auto generated.
     * @type {string}
     * memberof Connector
     */
    'connector_id'?: string | null;
    /**
     * Connector description.  It will be auto generated.
     * @type {string}
     * memberof Connector
     */
    'description'?: string | null;
    /**
     * Connector logo URL.
     * @type {string}
     * memberof Connector
     */
    'thumbnail'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Connector
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Connector
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Connector
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface ConnectorAuth
 */
export interface ConnectorAuth {
    /**
     * Channel Id.
     * @type {string}
     * memberof ConnectorAuth
     */
    'channel_id'?: string | null;
    /**
     * Auth information
     * @type {any}
     * memberof ConnectorAuth
     */
    'auth_info'?: any | null;
    /**
     * 
     * @type {string}
     * memberof ConnectorAuth
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ConnectorAuth
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ConnectorAuth
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface ConnectorAuthListResponse
 */
export interface ConnectorAuthListResponse {
    /**
     * 
     * @type {Array<ConnectorAuth>}
     * memberof ConnectorAuthListResponse
     */
    'data'?: Array<ConnectorAuth> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof ConnectorAuthListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof ConnectorAuthListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof ConnectorAuthListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface ConnectorAuthUrl
 */
export interface ConnectorAuthUrl {
    /**
     * Auth url
     * @type {string}
     * memberof ConnectorAuthUrl
     */
    'auth_url'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ConnectorAuthUrl
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ConnectorAuthUrl
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ConnectorAuthUrl
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface ConnectorDeet
 */
export interface ConnectorDeet {
    /**
     * Connector name.
     * @type {string}
     * memberof ConnectorDeet
     */
    'connector_name'?: string | null;
    /**
     * Connector Id
     * @type {string}
     * memberof ConnectorDeet
     */
    'connector_id'?: string | null;
    /**
     * Description
     * @type {string}
     * memberof ConnectorDeet
     */
    'description'?: string | null;
    /**
     * Connector logo URL.
     * @type {string}
     * memberof ConnectorDeet
     */
    'thumbnail'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ConnectorDeet
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ConnectorDeet
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ConnectorDeet
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface ConnectorListResponse
 */
export interface ConnectorListResponse {
    /**
     * 
     * @type {Array<Connector>}
     * memberof ConnectorListResponse
     */
    'data'?: Array<Connector> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof ConnectorListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof ConnectorListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof ConnectorListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface ContactBulkCreateDeets
 */
export interface ContactBulkCreateDeets {
    /**
     * Send an email to contact.
     * @type {boolean}
     * memberof ContactBulkCreateDeets
     */
    'send_invite_email'?: boolean;
    /**
     * 
     * @type {Array<ContactCreateDeets>}
     * memberof ContactBulkCreateDeets
     */
    'data'?: Array<ContactCreateDeets> | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof ContactBulkCreateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactBulkCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface ContactCreateDeets
 */
export interface ContactCreateDeets {
    /**
     * 
     * @type {AddressDeets}
     * memberof ContactCreateDeets
     */
    'address'?: AddressDeets;
    /**
     * 
     * @type {DOBDeets}
     * memberof ContactCreateDeets
     */
    'dob'?: DOBDeets;
    /**
     * A collection of email addresses for the contact
     * @type {Array<EmailDeets>}
     * memberof ContactCreateDeets
     */
    'email_addresses'?: Array<EmailDeets> | null;
    /**
     * The contact\'s first name
     * @type {string}
     * memberof ContactCreateDeets
     */
    'first_name': string;
    /**
     * The contact\'s last name
     * @type {string}
     * memberof ContactCreateDeets
     */
    'last_name': string;
    /**
     * A title for the contact (e.g. Mr., Mrs., .Ms, etc)
     * @type {string}
     * memberof ContactCreateDeets
     */
    'title'?: string | null;
    /**
     * The contact\'s phone number
     * @type {Array<PhoneDeets>}
     * memberof ContactCreateDeets
     */
    'phone_numbers'?: Array<PhoneDeets> | null;
    /**
     * A separate name that this contact might be known by.
     * @type {string}
     * memberof ContactCreateDeets
     */
    'known_name'?: string | null;
    /**
     * The contact\'s middle initial
     * @type {string}
     * memberof ContactCreateDeets
     */
    'middle_initial'?: string | null;
    /**
     * A short biography for the
     * @type {string}
     * memberof ContactCreateDeets
     */
    'short_bio'?: string | null;
    /**
     * A separate name for any display purposes.
     * @type {string}
     * memberof ContactCreateDeets
     */
    'display_name'?: string | null;
    /**
     * Base64 encoded byte array (PNG format) to upload as an avatar during contact creation.
     * @type {string}
     * memberof ContactCreateDeets
     */
    'avatar_bytes'?: string | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof ContactCreateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactCreateDeets
     */
    'object'?: string | null;
}
/**
 * Options for including contact information
 * export
 * @interface ContactDeets
 */
export interface ContactDeets {
    /**
     * The Contact Id
     * @type {string}
     * memberof ContactDeets
     */
    'id'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof ContactDeets
     */
    'address'?: AddressDeets;
    /**
     * 
     * @type {DOBDeets}
     * memberof ContactDeets
     */
    'dob'?: DOBDeets;
    /**
     * A collection of email addresses for the contact
     * @type {Array<EmailDeets>}
     * memberof ContactDeets
     */
    'email_addresses'?: Array<EmailDeets> | null;
    /**
     * The contact\'s first name
     * @type {string}
     * memberof ContactDeets
     */
    'first_name': string;
    /**
     * The contact\'s last name
     * @type {string}
     * memberof ContactDeets
     */
    'last_name': string;
    /**
     * A title for the contact (e.g. Mr., Mrs., .Ms, etc)
     * @type {string}
     * memberof ContactDeets
     */
    'title'?: string | null;
    /**
     * The contact\'s phone number
     * @type {Array<PhoneDeets>}
     * memberof ContactDeets
     */
    'phone_numbers'?: Array<PhoneDeets> | null;
    /**
     * A separate name that this contact might be known by.
     * @type {string}
     * memberof ContactDeets
     */
    'known_name'?: string | null;
    /**
     * The contact\'s middle initial
     * @type {string}
     * memberof ContactDeets
     */
    'middle_initial'?: string | null;
    /**
     * A short biography for the
     * @type {string}
     * memberof ContactDeets
     */
    'short_bio'?: string | null;
    /**
     * A separate name for any display purposes.
     * @type {string}
     * memberof ContactDeets
     */
    'display_name'?: string | null;
    /**
     * Base64 encoded byte array (PNG format) to upload as an avatar during contact creation.
     * @type {string}
     * memberof ContactDeets
     */
    'avatar_bytes'?: string | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof ContactDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface ContactInfo
 */
export interface ContactInfo {
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {Location}
     * memberof ContactInfo
     */
    'address'?: Location;
    /**
     * 
     * @type {DOB}
     * memberof ContactInfo
     */
    'dob'?: DOB;
    /**
     * 
     * @type {Array<Email>}
     * memberof ContactInfo
     */
    'email_addresses'?: Array<Email> | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'title'?: string | null;
    /**
     * 
     * @type {Array<Phone>}
     * memberof ContactInfo
     */
    'phone_numbers'?: Array<Phone> | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'known_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'middle_initial'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'short_bio'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'avatar_url'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'display_name'?: string | null;
    /**
     * The primary AccountId of this Persona, Created when a contact is first invited  or added to the platform and is guaranteed unique  and may be present before UserId which is only available  once the invited user has been fully on-boarded
     * @type {string}
     * memberof ContactInfo
     */
    'user_account_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof ContactInfo
     */
    'is_contact'?: boolean;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'email_invite_message'?: string | null;
    /**
     * 
     * @type {ContactStatusPersona}
     * memberof ContactInfo
     */
    'contact_status'?: ContactStatusPersona;
    /**
     * 
     * @type {boolean}
     * memberof ContactInfo
     */
    'has_existing_account'?: boolean;
    /**
     * 
     * @type {InvitingContact}
     * memberof ContactInfo
     */
    'inviting_contact'?: InvitingContact;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'last_payment_at'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInfo
     */
    'created_at'?: string;
}


/**
 * 
 * export
 * @interface ContactInfoListResponse
 */
export interface ContactInfoListResponse {
    /**
     * 
     * @type {Array<ContactInfo>}
     * memberof ContactInfoListResponse
     */
    'data'?: Array<ContactInfo> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof ContactInfoListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof ContactInfoListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof ContactInfoListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface ContactInviteCreateDeets
 */
export interface ContactInviteCreateDeets {
    /**
     * A collection of email addresses for the contact
     * @type {string}
     * memberof ContactInviteCreateDeets
     */
    'email': string;
    /**
     * A separate name that this contact might be known by.
     * @type {string}
     * memberof ContactInviteCreateDeets
     */
    'known_name': string;
    /**
     * Custom message for invite email.
     * @type {string}
     * memberof ContactInviteCreateDeets
     */
    'email_message'?: string | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof ContactInviteCreateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInviteCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface ContactInviteUpdateDeets
 */
export interface ContactInviteUpdateDeets {
    /**
     * Persona Id.
     * @type {string}
     * memberof ContactInviteUpdateDeets
     */
    'PersonaId'?: string | null;
    /**
     * A separate name that this contact might be known by.
     * @type {string}
     * memberof ContactInviteUpdateDeets
     */
    'known_name': string;
    /**
     * Custom message for invite email.
     * @type {string}
     * memberof ContactInviteUpdateDeets
     */
    'email_message'?: string | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof ContactInviteUpdateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactInviteUpdateDeets
     */
    'object'?: string | null;
}
/**
 *   undefinded  invited  accepted  rejected  rejectedButKeepInvite
 * export
 * @enum {string}
 */

export const ContactStatusPersona = {
    /**
    * 
    */
    Undefinded: 'undefinded',
    /**
    * 
    */
    Invited: 'invited',
    /**
    * 
    */
    Accepted: 'accepted',
    /**
    * 
    */
    Rejected: 'rejected',
    /**
    * 
    */
    RejectedButKeepInvite: 'rejectedButKeepInvite'
} as const;

export type ContactStatusPersona = typeof ContactStatusPersona[keyof typeof ContactStatusPersona];


/**
 *   all  invited  accepted  rejected
 * export
 * @enum {string}
 */

export const ContactStatusPersonaFilter = {
    /**
    * 
    */
    All: 'all',
    /**
    * 
    */
    Invited: 'invited',
    /**
    * 
    */
    Accepted: 'accepted',
    /**
    * 
    */
    Rejected: 'rejected'
} as const;

export type ContactStatusPersonaFilter = typeof ContactStatusPersonaFilter[keyof typeof ContactStatusPersonaFilter];


/**
 * 
 * export
 * @interface ContactStatusUpdateDeets
 */
export interface ContactStatusUpdateDeets {
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof ContactStatusUpdateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContactStatusUpdateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface Contract
 */
export interface Contract {
    /**
     * Unique Id and primary key of this Contract
     * @type {string}
     * memberof Contract
     */
    'id'?: string | null;
    /**
     * Shared id of the contract for when multiple revisions may exist
     * @type {string}
     * memberof Contract
     */
    'contract_id'?: string | null;
    /**
     * Display title
     * @type {string}
     * memberof Contract
     */
    'title'?: string | null;
    /**
     * Description
     * @type {string}
     * memberof Contract
     */
    'description'?: string | null;
    /**
     * 
     * @type {ContractHeader}
     * memberof Contract
     */
    'header'?: ContractHeader;
    /**
     * One ore more Income terms which help provide scope  on how funds flow through the `Contract`
     * @type {Array<Income>}
     * memberof Contract
     */
    'incomes'?: Array<Income> | null;
    /**
     * True if this `Contract` is derived from another one, otherwise false
     * @type {boolean}
     * memberof Contract
     */
    'is_derived'?: boolean;
    /**
     * True if this `Contract` is active; otherwise false. Contracts must be active in order to process funds
     * @type {boolean}
     * memberof Contract
     */
    'is_active'?: boolean;
    /**
     * The date and time the `Contract` was most recently activated
     * @type {string}
     * memberof Contract
     */
    'activated_at'?: string | null;
    /**
     * 
     * @type {AccountUserPersona}
     * memberof Contract
     */
    'activated_by'?: AccountUserPersona;
    /**
     * 
     * @type {string}
     * memberof Contract
     */
    'bulk_id'?: string | null;
    /**
     * 
     * @type {Array<BatchRun>}
     * memberof Contract
     */
    'batch_runs'?: Array<BatchRun> | null;
}
/**
 * 
 * export
 * @interface ContractHeader
 */
export interface ContractHeader {
    /**
     * 
     * @type {string}
     * memberof ContractHeader
     */
    'contract_type'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContractHeader
     */
    'system_version'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContractHeader
     */
    'system_description'?: string | null;
    /**
     * 
     * @type {number}
     * memberof ContractHeader
     */
    'revision'?: number;
    /**
     * True when the system or internal staff  have disabled the contract from processing
     * @type {boolean}
     * memberof ContractHeader
     */
    'system_disabled'?: boolean;
    /**
     * Any notes related to system changes or  enabling/disabling of this contract
     * @type {string}
     * memberof ContractHeader
     */
    'system_notes'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContractHeader
     */
    'last_updated_date'?: string;
    /**
     * 
     * @type {string}
     * memberof ContractHeader
     */
    'initiated_by_user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContractHeader
     */
    'partner_account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ContractHeader
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {number}
     * memberof ContractHeader
     */
    'priority'?: number;
    /**
     * 
     * @type {boolean}
     * memberof ContractHeader
     */
    'ready_to_share'?: boolean;
}
/**
 * Date of birth
 * export
 * @interface DOB
 */
export interface DOB {
    /**
     * Day
     * @type {number}
     * memberof DOB
     */
    'day'?: number;
    /**
     * Month
     * @type {number}
     * memberof DOB
     */
    'month'?: number;
    /**
     * Year
     * @type {number}
     * memberof DOB
     */
    'year'?: number;
}
/**
 * Date of birth
 * export
 * @interface DOBDeets
 */
export interface DOBDeets {
    /**
     * Day
     * @type {number}
     * memberof DOBDeets
     */
    'day'?: number;
    /**
     * Month
     * @type {number}
     * memberof DOBDeets
     */
    'month'?: number;
    /**
     * Year
     * @type {number}
     * memberof DOBDeets
     */
    'year'?: number;
}
/**
 * 
 * export
 * @interface DateTimeDecimalDataPoint
 */
export interface DateTimeDecimalDataPoint {
    /**
     * 
     * @type {string}
     * memberof DateTimeDecimalDataPoint
     */
    'x'?: string;
    /**
     * 
     * @type {number}
     * memberof DateTimeDecimalDataPoint
     */
    'y'?: number;
}
/**
 * 
 * export
 * @interface DateTimeDecimalDataSeries
 */
export interface DateTimeDecimalDataSeries {
    /**
     * 
     * @type {Array<DateTimeDecimalSeries>}
     * memberof DateTimeDecimalDataSeries
     */
    'series'?: Array<DateTimeDecimalSeries> | null;
}
/**
 * 
 * export
 * @interface DateTimeDecimalSeries
 */
export interface DateTimeDecimalSeries {
    /**
     * 
     * @type {string}
     * memberof DateTimeDecimalSeries
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<DateTimeDecimalDataPoint>}
     * memberof DateTimeDecimalSeries
     */
    'data'?: Array<DateTimeDecimalDataPoint> | null;
}
/**
 * 
 * export
 * @interface DeviceRegistration
 */
export interface DeviceRegistration {
    /**
     * 
     * @type {string}
     * memberof DeviceRegistration
     */
    'Platform'?: string | null;
    /**
     * 
     * @type {string}
     * memberof DeviceRegistration
     */
    'Handle'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * memberof DeviceRegistration
     */
    'Tags'?: Array<string> | null;
}
/**
 * Enables a contract to be created via the SimpleContract API... more simply.
 * export
 * @interface EasyContractDeets
 */
export interface EasyContractDeets {
    /**
     * 
     * @type {string}
     * memberof EasyContractDeets
     */
    'projectName': string;
    /**
     * 
     * @type {string}
     * memberof EasyContractDeets
     */
    'description': string;
    /**
     * 
     * @type {string}
     * memberof EasyContractDeets
     */
    'primaryEmail': string;
    /**
     * 
     * @type {string}
     * memberof EasyContractDeets
     */
    'collaboratorEmail': string;
    /**
     * 
     * @type {number}
     * memberof EasyContractDeets
     */
    'collaboratorPerctage': number;
    /**
     * 
     * @type {string}
     * memberof EasyContractDeets
     */
    'recoupableDescription'?: string | null;
    /**
     * 
     * @type {number}
     * memberof EasyContractDeets
     */
    'recoupableAmount'?: number;
    /**
     * 
     * @type {number}
     * memberof EasyContractDeets
     */
    'recoupableBalance'?: number;
}
/**
 * 
 * export
 * @interface Email
 */
export interface Email {
    /**
     * 
     * @type {string}
     * memberof Email
     */
    'address'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Email
     */
    'label'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof Email
     */
    'is_primary'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof Email
     */
    'is_validated'?: boolean;
}
/**
 * 
 * export
 * @interface EmailDeets
 */
export interface EmailDeets {
    /**
     * The email address itself
     * @type {string}
     * memberof EmailDeets
     */
    'address': string;
    /**
     * A label for this email address
     * @type {string}
     * memberof EmailDeets
     */
    'label'?: string | null;
    /**
     * True if this is a primary email address
     * @type {boolean}
     * memberof EmailDeets
     */
    'is_primary'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof EmailDeets
     */
    'is_validated'?: boolean;
}
/**
 * Represents an end user, which is part of a tenant.
 * export
 * @interface EndUser
 */
export interface EndUser {
    /**
     * 
     * @type {string}
     * memberof EndUser
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUser
     */
    'tenant_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof EndUser
     */
    'is_new'?: boolean;
}
/**
 * 
 * export
 * @interface EndUserCreateDeets
 */
export interface EndUserCreateDeets {
    /**
     * First name of the account holder
     * @type {string}
     * memberof EndUserCreateDeets
     */
    'first_name'?: string | null;
    /**
     * Last name of the account holder
     * @type {string}
     * memberof EndUserCreateDeets
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof EndUserCreateDeets
     */
    'address'?: AddressDeets;
    /**
     * The birthdate of the account holder
     * @type {string}
     * memberof EndUserCreateDeets
     */
    'dob'?: string;
    /**
     * Phone number of the account holder
     * @type {string}
     * memberof EndUserCreateDeets
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserCreateDeets
     */
    'invite_token'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserCreateDeets
     */
    'email_address'?: string | null;
    /**
     * Federal Tax Identifier / SSN of the account holder
     * @type {string}
     * memberof EndUserCreateDeets
     */
    'federal_tax_id'?: string | null;
    /**
     * Business Name
     * @type {string}
     * memberof EndUserCreateDeets
     */
    'business_name'?: string | null;
    /**
     * 
     * @type {EntityType}
     * memberof EndUserCreateDeets
     */
    'entity_type'?: EntityType;
    /**
     * 
     * @type {IUserBusinessDeets}
     * memberof EndUserCreateDeets
     */
    'business_details'?: IUserBusinessDeets;
    /**
     * 
     * @type {IUserIndividualDeets}
     * memberof EndUserCreateDeets
     */
    'individual_details'?: IUserIndividualDeets;
    /**
     * 
     * @type {string}
     * memberof EndUserCreateDeets
     */
    'object'?: string | null;
}


/**
 * 
 * export
 * @interface EndUserReadDeets
 */
export interface EndUserReadDeets {
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'Id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'middle_initial'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'known_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'phone'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof EndUserReadDeets
     */
    'Address'?: AddressDeets;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {DOBDeets}
     * memberof EndUserReadDeets
     */
    'dob'?: DOBDeets;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'last_active_at'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'bio'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'government_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * memberof EndUserReadDeets
     */
    'object'?: string | null;
}
/**
 *   individual  organization
 * export
 * @enum {string}
 */

export const EntityType = {
    /**
    * 
    */
    Individual: 'individual',
    /**
    * 
    */
    Organization: 'organization'
} as const;

export type EntityType = typeof EntityType[keyof typeof EntityType];


/**
 * 
 * export
 * @interface Expiration
 */
export interface Expiration {
    /**
     * 
     * @type {number}
     * memberof Expiration
     */
    'month'?: number;
    /**
     * 
     * @type {number}
     * memberof Expiration
     */
    'year'?: number;
    /**
     * 
     * @type {string}
     * memberof Expiration
     */
    'display'?: string | null;
}
/**
 * 
 * export
 * @interface ExternalImageDeets
 */
export interface ExternalImageDeets {
    /**
     * 
     * @type {string}
     * memberof ExternalImageDeets
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * memberof ExternalImageDeets
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * memberof ExternalImageDeets
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * memberof ExternalImageDeets
     */
    'ext'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof ExternalImageDeets
     */
    'is_imported'?: boolean;
    /**
     * 
     * @type {string}
     * memberof ExternalImageDeets
     */
    'last_imported_at'?: string;
}
/**
 * Defines the direction in which fees are charged.  default (Use the platform default fee direction which is to the Payee)  payer (Fees are charged to the Payer)  payee (Fees are charged to the Payee)  split (Fees are split equally between Payer and Payee.   Any remaineder is paid by the Payee)
 * export
 * @enum {string}
 */

export const FeeDirection = {
    /**
    * Use the platform default fee direction which is to the Payee
    */
    Default: 'default',
    /**
    * Fees are charged to the Payer
    */
    Payer: 'payer',
    /**
    * Fees are charged to the Payee
    */
    Payee: 'payee',
    /**
    * Fees are split equally between Payer and Payee. 
Any remaineder is paid by the Payee
    */
    Split: 'split'
} as const;

export type FeeDirection = typeof FeeDirection[keyof typeof FeeDirection];


/**
 * 
 * export
 * @interface Fees
 */
export interface Fees {
    /**
     * 
     * @type {Array<LineItem>}
     * memberof Fees
     */
    'LineItems'?: Array<LineItem> | null;
    /**
     * 
     * @type {string}
     * memberof Fees
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Fees
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Fees
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface FeesBulk
 */
export interface FeesBulk {
    /**
     * 
     * @type {Fees}
     * memberof FeesBulk
     */
    'fees'?: Fees;
    /**
     * 
     * @type {BasicContactDeets}
     * memberof FeesBulk
     */
    'from'?: BasicContactDeets;
    /**
     * 
     * @type {BasicContactDeets}
     * memberof FeesBulk
     */
    'to': BasicContactDeets;
    /**
     * 
     * @type {string}
     * memberof FeesBulk
     */
    'memo'?: string | null;
    /**
     * 
     * @type {Amount}
     * memberof FeesBulk
     */
    'amount'?: Amount;
    /**
     * 
     * @type {FeeDirection}
     * memberof FeesBulk
     */
    'fee_direction'?: FeeDirection;
    /**
     * 
     * @type {boolean}
     * memberof FeesBulk
     */
    'ignore_contracts'?: boolean;
    /**
     * 
     * @type {FundingSource}
     * memberof FeesBulk
     */
    'funding_source'?: FundingSource;
    /**
     * 
     * @type {string}
     * memberof FeesBulk
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof FeesBulk
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof FeesBulk
     */
    'created_at'?: string;
}


/**
 * 
 * export
 * @interface FeesBulkListResponse
 */
export interface FeesBulkListResponse {
    /**
     * 
     * @type {Array<FeesBulk>}
     * memberof FeesBulkListResponse
     */
    'data'?: Array<FeesBulk> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof FeesBulkListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof FeesBulkListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof FeesBulkListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface FileExpandableField
 */
export interface FileExpandableField {
    /**
     * 
     * @type {string}
     * memberof FileExpandableField
     */
    'Id'?: string | null;
    /**
     * 
     * @type {any}
     * memberof FileExpandableField
     */
    'ExpandedObject'?: any;
}
/**
 * 
 * export
 * @interface FileLink
 */
export interface FileLink {
    /**
     * 
     * @type {string}
     * memberof FileLink
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof FileLink
     */
    'object'?: string | null;
    /**
     * 
     * @type {string}
     * memberof FileLink
     */
    'created'?: string;
    /**
     * 
     * @type {boolean}
     * memberof FileLink
     */
    'expired'?: boolean;
    /**
     * 
     * @type {string}
     * memberof FileLink
     */
    'expires_at'?: string | null;
    /**
     * 
     * @type {FileExpandableField}
     * memberof FileLink
     */
    'file'?: FileExpandableField;
    /**
     * 
     * @type {boolean}
     * memberof FileLink
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * memberof FileLink
     */
    'metadata'?: { [key: string]: string | null; } | null;
    /**
     * 
     * @type {string}
     * memberof FileLink
     */
    'url'?: string | null;
}
/**
 * 
 * export
 * @interface FileLinkStripeList
 */
export interface FileLinkStripeList {
    /**
     * 
     * @type {string}
     * memberof FileLinkStripeList
     */
    'object'?: string | null;
    /**
     * 
     * @type {Array<FileLink>}
     * memberof FileLinkStripeList
     */
    'data'?: Array<FileLink> | null;
    /**
     * 
     * @type {boolean}
     * memberof FileLinkStripeList
     */
    'has_more'?: boolean;
    /**
     * 
     * @type {string}
     * memberof FileLinkStripeList
     */
    'url'?: string | null;
}
/**
 * 
 * export
 * @interface FlatAmountTerm
 */
export interface FlatAmountTerm extends BaseTerms {
    /**
     * 
     * @type {string}
     * memberof FlatAmountTerm
     */
    '$entity'?: string | null;
    /**
     * 
     * @type {number}
     * memberof FlatAmountTerm
     */
    'rate'?: number;
    /**
     * 
     * @type {AccountUserPersona}
     * memberof FlatAmountTerm
     */
    'from'?: AccountUserPersona;
    /**
     * 
     * @type {AccountUserPersona}
     * memberof FlatAmountTerm
     */
    'to'?: AccountUserPersona;
}
/**
 * 
 * export
 * @interface FlatRateTerm
 */
export interface FlatRateTerm extends BaseTerms {
    /**
     * 
     * @type {string}
     * memberof FlatRateTerm
     */
    '$entity'?: string | null;
    /**
     * 
     * @type {number}
     * memberof FlatRateTerm
     */
    'rate'?: number;
    /**
     * 
     * @type {AccountUserPersona}
     * memberof FlatRateTerm
     */
    'from'?: AccountUserPersona;
    /**
     * 
     * @type {AccountUserPersona}
     * memberof FlatRateTerm
     */
    'to'?: AccountUserPersona;
}
/**
 * 
 * export
 * @interface FundingAttachDeets
 */
export interface FundingAttachDeets {
    /**
     * 
     * @type {FundingType}
     * memberof FundingAttachDeets
     */
    'funding_type'?: FundingType;
    /**
     * 
     * @type {string}
     * memberof FundingAttachDeets
     */
    'orchestration_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof FundingAttachDeets
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof FundingAttachDeets
     */
    'external_id'?: string | null;
}


/**
 * Funding sources can be user/tenant wallet payment sources  or ACH Direct Debit, or Debit Credit via Wire or Deposits
 * export
 * @interface FundingSource
 */
export interface FundingSource {
    /**
     * 
     * @type {FundingType}
     * memberof FundingSource
     */
    'funding_type'?: FundingType;
    /**
     * 
     * @type {string}
     * memberof FundingSource
     */
    'funding_type_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof FundingSource
     */
    'payment_method_id'?: string | null;
}


/**
 *   invoice  wallet  balance  tipLink
 * export
 * @enum {string}
 */

export const FundingType = {
    /**
    * 
    */
    Invoice: 'invoice',
    /**
    * 
    */
    Wallet: 'wallet',
    /**
    * 
    */
    Balance: 'balance',
    /**
    * 
    */
    TipLink: 'tipLink'
} as const;

export type FundingType = typeof FundingType[keyof typeof FundingType];


/**
 * 
 * export
 * @interface HubSpotContact
 */
export interface HubSpotContact {
    /**
     * 
     * @type {string}
     * memberof HubSpotContact
     */
    'id'?: string | null;
    /**
     * 
     * @type {HubSpotContactProperties}
     * memberof HubSpotContact
     */
    'properties'?: HubSpotContactProperties;
    /**
     * 
     * @type {string}
     * memberof HubSpotContact
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * memberof HubSpotContact
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * memberof HubSpotContact
     */
    'archived'?: boolean;
}
/**
 * 
 * export
 * @interface HubSpotContactProperties
 */
export interface HubSpotContactProperties {
    /**
     * 
     * @type {string}
     * memberof HubSpotContactProperties
     */
    'createdate'?: string;
    /**
     * 
     * @type {string}
     * memberof HubSpotContactProperties
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * memberof HubSpotContactProperties
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * memberof HubSpotContactProperties
     */
    'hs_object_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof HubSpotContactProperties
     */
    'lastmodifieddate'?: string;
    /**
     * 
     * @type {string}
     * memberof HubSpotContactProperties
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * memberof HubSpotContactProperties
     */
    'lifecyclestage'?: string | null;
}
/**
 *   payerWaitlist (The user would like to become a payer.)  applicationWaitlist (The user would like to log into the application.)
 * export
 * @enum {string}
 */

export const HubSpotLifecycle = {
    /**
    * The user would like to become a payer.
    */
    PayerWaitlist: 'payerWaitlist',
    /**
    * The user would like to log into the application.
    */
    ApplicationWaitlist: 'applicationWaitlist'
} as const;

export type HubSpotLifecycle = typeof HubSpotLifecycle[keyof typeof HubSpotLifecycle];


/**
 * 
 * export
 * @interface IUserBusinessDeets
 */
export interface IUserBusinessDeets {
    /**
     * Address of the Business
     * @type {string}
     * memberof IUserBusinessDeets
     */
    'business_name'?: string | null;
    /**
     * Business Legal Name
     * @type {string}
     * memberof IUserBusinessDeets
     */
    'business_legal_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof IUserBusinessDeets
     */
    'email_address'?: string | null;
    /**
     * Business EIN
     * @type {string}
     * memberof IUserBusinessDeets
     */
    'business_ein'?: string | null;
    /**
     * Business website
     * @type {string}
     * memberof IUserBusinessDeets
     */
    'business_website'?: string | null;
    /**
     * Business Phone Number
     * @type {string}
     * memberof IUserBusinessDeets
     */
    'business_phone_number'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof IUserBusinessDeets
     */
    'business_address'?: AddressDeets;
    /**
     * Is owners provided for the business
     * @type {boolean}
     * memberof IUserBusinessDeets
     */
    'is_business_owners_provided'?: boolean | null;
    /**
     * List of associated persons with business
     * @type {Array<Person>}
     * memberof IUserBusinessDeets
     */
    'business_persons'?: Array<Person> | null;
}
/**
 * 
 * export
 * @interface IUserIndividualDeets
 */
export interface IUserIndividualDeets {
    /**
     * First name of the account holder
     * @type {string}
     * memberof IUserIndividualDeets
     */
    'first_name'?: string | null;
    /**
     * Last name of the account holder
     * @type {string}
     * memberof IUserIndividualDeets
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof IUserIndividualDeets
     */
    'email_address'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof IUserIndividualDeets
     */
    'address'?: AddressDeets;
    /**
     * The birthdate of the account holder
     * @type {string}
     * memberof IUserIndividualDeets
     */
    'dob'?: string | null;
    /**
     * Phone number of the account holder
     * @type {string}
     * memberof IUserIndividualDeets
     */
    'phone'?: string | null;
    /**
     * Federal Tax Identifier / SSN of the account holder
     * @type {string}
     * memberof IUserIndividualDeets
     */
    'federal_tax_id'?: string | null;
}
/**
 * 
 * export
 * @interface Income
 */
export interface Income extends BaseTerms {
    /**
     * 
     * @type {string}
     * memberof Income
     */
    '$entity'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Income
     */
    'connector_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Income
     */
    'connector_name'?: string | null;
}
/**
 * 
 * export
 * @interface InviteInfo
 */
export interface InviteInfo {
    /**
     * 
     * @type {string}
     * memberof InviteInfo
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof InviteInfo
     */
    'amount'?: string | null;
    /**
     * 
     * @type {string}
     * memberof InviteInfo
     */
    'from_display_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof InviteInfo
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * memberof InviteInfo
     */
    'primary_phone'?: string | null;
}
/**
 * 
 * export
 * @interface InviteSendDeets
 */
export interface InviteSendDeets {
    /**
     * 
     * @type {string}
     * memberof InviteSendDeets
     */
    'token'?: string | null;
    /**
     * 
     * @type {string}
     * memberof InviteSendDeets
     */
    'subject'?: string | null;
    /**
     * 
     * @type {string}
     * memberof InviteSendDeets
     */
    'template_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof InviteSendDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface InvitingContact
 */
export interface InvitingContact {
    /**
     * persona id of inviting contact.
     * @type {string}
     * memberof InvitingContact
     */
    'id'?: string | null;
    /**
     * email address of inviting contact.
     * @type {string}
     * memberof InvitingContact
     */
    'email'?: string | null;
    /**
     * known name of inviting contact
     * @type {string}
     * memberof InvitingContact
     */
    'known_name'?: string | null;
    /**
     * display name of inviting contact
     * @type {string}
     * memberof InvitingContact
     */
    'display_name'?: string | null;
}
/**
 * 
 * export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {string}
     * memberof Invoice
     */
    'mozaic_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Invoice
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Invoice
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {Array<LineItem>}
     * memberof Invoice
     */
    'line_items'?: Array<LineItem> | null;
    /**
     * 
     * @type {string}
     * memberof Invoice
     */
    'status'?: string | null;
    /**
     * 
     * @type {ReceivingAccountInfo}
     * memberof Invoice
     */
    'receiving_account'?: ReceivingAccountInfo;
    /**
     * 
     * @type {string}
     * memberof Invoice
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Invoice
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Invoice
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface InvoiceFinalizeDeets
 */
export interface InvoiceFinalizeDeets {
    /**
     * 
     * @type {boolean}
     * memberof InvoiceFinalizeDeets
     */
    'auto_advance'?: boolean;
    /**
     * 
     * @type {string}
     * memberof InvoiceFinalizeDeets
     */
    'payment_method_id'?: string | null;
    /**
     * send_invoice or charge_automatically
     * @type {string}
     * memberof InvoiceFinalizeDeets
     */
    'collection_method'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof InvoiceFinalizeDeets
     */
    'ach_auto_reconciliation'?: boolean;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof InvoiceFinalizeDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof InvoiceFinalizeDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface InvoicePayDeets
 */
export interface InvoicePayDeets {
    /**
     * 
     * @type {string}
     * memberof InvoicePayDeets
     */
    'payment_method_id'?: string | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof InvoicePayDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof InvoicePayDeets
     */
    'object'?: string | null;
}
/**
 * Shows the type of the ledger entry that a Payment document in cosmos represents.  active (Active: The payment was created and sent by the system (money moved between accounts).)  journal (Journal: The payment was done off-platform and no money was moved between accounts.)
 * export
 * @enum {string}
 */

export const LedgerType = {
    /**
    * Active: The payment was created and sent by the system (money moved between accounts).
    */
    Active: 'active',
    /**
    * Journal: The payment was done off-platform and no money was moved between accounts.
    */
    Journal: 'journal'
} as const;

export type LedgerType = typeof LedgerType[keyof typeof LedgerType];


/**
 *   granted  pendingRegistration  claimed  invited  notReal  deleted
 * export
 * @enum {string}
 */

export const LicenseAssignmentStatuses = {
    /**
    * 
    */
    Granted: 'granted',
    /**
    * 
    */
    PendingRegistration: 'pendingRegistration',
    /**
    * 
    */
    Claimed: 'claimed',
    /**
    * 
    */
    Invited: 'invited',
    /**
    * 
    */
    NotReal: 'notReal',
    /**
    * 
    */
    Deleted: 'deleted'
} as const;

export type LicenseAssignmentStatuses = typeof LicenseAssignmentStatuses[keyof typeof LicenseAssignmentStatuses];


/**
 * 
 * export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * 
     * @type {number}
     * memberof LineItem
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * memberof LineItem
     */
    'type'?: string | null;
    /**
     * 
     * @type {Amount}
     * memberof LineItem
     */
    'amount'?: Amount;
    /**
     * 
     * @type {string}
     * memberof LineItem
     */
    'memo'?: string | null;
    /**
     * 
     * @type {string}
     * memberof LineItem
     */
    'external_id'?: string | null;
}
/**
 * 
 * export
 * @interface Location
 */
export interface Location {
    /**
     * Common name of the address like Central Park
     * @type {string}
     * memberof Location
     */
    'common_name'?: string | null;
    /**
     * Address line 1
     * @type {string}
     * memberof Location
     */
    'line1'?: string | null;
    /**
     * Address line 2
     * @type {string}
     * memberof Location
     */
    'line2'?: string | null;
    /**
     * City name
     * @type {string}
     * memberof Location
     */
    'city'?: string | null;
    /**
     * Latitude and Longitude
     * @type {string}
     * memberof Location
     */
    'lat_long'?: string | null;
    /**
     * Postal code or ZIP code
     * @type {string}
     * memberof Location
     */
    'postal_code'?: string | null;
    /**
     * State, region or province
     * @type {string}
     * memberof Location
     */
    'state_region'?: string | null;
    /**
     * Two-letter country code <see href=\"https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\">ISO 3166-1 alpha-2</see>
     * @type {string}
     * memberof Location
     */
    'country_code'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Location
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Location
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Location
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface LogicError
 */
export interface LogicError {
    /**
     * 
     * @type {string}
     * memberof LogicError
     */
    'ErrorMessage'?: string | null;
    /**
     * 
     * @type {number}
     * memberof LogicError
     */
    'ErrorNumber'?: number;
}
/**
 * 
 * export
 * @interface LogicResult
 */
export interface LogicResult {
    /**
     * 
     * @type {boolean}
     * memberof LogicResult
     */
    'Successful'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof LogicResult
     */
    'ResultReadOnly'?: boolean;
    /**
     * 
     * @type {Array<LogicError>}
     * memberof LogicResult
     */
    'Errors'?: Array<LogicError> | null;
    /**
     * 
     * @type {number}
     * memberof LogicResult
     */
    'Count'?: number;
}
/**
 * 
 * export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {string}
     * memberof ModelFile
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ModelFile
     */
    'object'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ModelFile
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * memberof ModelFile
     */
    'expires_at'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ModelFile
     */
    'filename'?: string | null;
    /**
     * 
     * @type {FileLinkStripeList}
     * memberof ModelFile
     */
    'links'?: FileLinkStripeList;
    /**
     * 
     * @type {string}
     * memberof ModelFile
     */
    'purpose'?: string | null;
    /**
     * 
     * @type {number}
     * memberof ModelFile
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * memberof ModelFile
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ModelFile
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ModelFile
     */
    'url'?: string | null;
}
/**
 * 
 * export
 * @interface NotificationAggregate
 */
export interface NotificationAggregate {
    /**
     * 
     * @type {number}
     * memberof NotificationAggregate
     */
    'unread_count'?: number;
    /**
     * 
     * @type {number}
     * memberof NotificationAggregate
     */
    'total_count'?: number;
    /**
     * 
     * @type {string}
     * memberof NotificationAggregate
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof NotificationAggregate
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof NotificationAggregate
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface NotificationResponse
 */
export interface NotificationResponse {
    /**
     * Title of the notification
     * @type {string}
     * memberof NotificationResponse
     */
    'title'?: string | null;
    /**
     * The actual notification message
     * @type {string}
     * memberof NotificationResponse
     */
    'message'?: string | null;
    /**
     * True if the notification is read, and false if it is unread
     * @type {boolean}
     * memberof NotificationResponse
     */
    'is_read'?: boolean;
    /**
     * The date the notification was created
     * @type {string}
     * memberof NotificationResponse
     */
    'created_at'?: string;
    /**
     * A url pointing to an icon to display with the notification
     * @type {string}
     * memberof NotificationResponse
     */
    'icon_url'?: string | null;
    /**
     * True if the notification is marked urgent
     * @type {boolean}
     * memberof NotificationResponse
     */
    'is_urgent'?: boolean;
    /**
     * The ID for the persona this notification is directed towards
     * @type {string}
     * memberof NotificationResponse
     */
    'to_persona_id'?: string | null;
    /**
     * A url this notification is linked to. Often this is where to send the client when the notification is clicked.
     * @type {string}
     * memberof NotificationResponse
     */
    'action_uri'?: string | null;
    /**
     * The ID for the persona that triggered this notification to send, if not a system/platform notification
     * @type {string}
     * memberof NotificationResponse
     */
    'from_persona_id'?: string | null;
    /**
     * The URL for the avatar of the personna that triggered this notification to send
     * @type {string}
     * memberof NotificationResponse
     */
    'from_persona_avatar_url'?: string | null;
    /**
     * 
     * @type {NotificationStyleTypes}
     * memberof NotificationResponse
     */
    'style_type'?: NotificationStyleTypes;
    /**
     * 
     * @type {string}
     * memberof NotificationResponse
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof NotificationResponse
     */
    'id'?: string | null;
}


/**
 *   information  success  warning  critical  backgroundPending  attentionRequired  none
 * export
 * @enum {string}
 */

export const NotificationStyleTypes = {
    /**
    * 
    */
    Information: 'information',
    /**
    * 
    */
    Success: 'success',
    /**
    * 
    */
    Warning: 'warning',
    /**
    * 
    */
    Critical: 'critical',
    /**
    * 
    */
    BackgroundPending: 'backgroundPending',
    /**
    * 
    */
    AttentionRequired: 'attentionRequired',
    /**
    * 
    */
    None: 'none'
} as const;

export type NotificationStyleTypes = typeof NotificationStyleTypes[keyof typeof NotificationStyleTypes];


/**
 * 
 * export
 * @interface NotificationsBulkUpdateDeets
 */
export interface NotificationsBulkUpdateDeets {
    /**
     * 
     * @type {Array<string>}
     * memberof NotificationsBulkUpdateDeets
     */
    'Ids'?: Array<string> | null;
}
/**
 * 
 * export
 * @interface NotificationsUpdateDeets
 */
export interface NotificationsUpdateDeets {
    /**
     * 
     * @type {boolean}
     * memberof NotificationsUpdateDeets
     */
    'Read'?: boolean;
}
/**
 * keeping it here just for time being - want to unblock the FE team.
 * export
 * @interface OnBoardingTask
 */
export interface OnBoardingTask {
    /**
     * 
     * @type {string}
     * memberof OnBoardingTask
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof OnBoardingTask
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * memberof OnBoardingTask
     */
    'link'?: string | null;
    /**
     * 
     * @type {OnBoardingTaskStatus}
     * memberof OnBoardingTask
     */
    'status'?: OnBoardingTaskStatus;
    /**
     * 
     * @type {string}
     * memberof OnBoardingTask
     */
    'date_completed'?: string | null;
}


/**
 *   nonStarted  inProgress  completed
 * export
 * @enum {string}
 */

export const OnBoardingTaskStatus = {
    /**
    * 
    */
    NonStarted: 'nonStarted',
    /**
    * 
    */
    InProgress: 'inProgress',
    /**
    * 
    */
    Completed: 'completed'
} as const;

export type OnBoardingTaskStatus = typeof OnBoardingTaskStatus[keyof typeof OnBoardingTaskStatus];


/**
 * 
 * export
 * @interface Orchestration
 */
export interface Orchestration {
    /**
     * 
     * @type {string}
     * memberof Orchestration
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {Array<PaymentPushCreateDeets>}
     * memberof Orchestration
     */
    'payment_pushes'?: Array<PaymentPushCreateDeets> | null;
    /**
     * 
     * @type {FundingSource}
     * memberof Orchestration
     */
    'funding_source'?: FundingSource;
    /**
     * 
     * @type {OrchestrationMode}
     * memberof Orchestration
     */
    'mode'?: OrchestrationMode;
    /**
     * 
     * @type {OrchestrationStatus}
     * memberof Orchestration
     */
    'status'?: OrchestrationStatus;
    /**
     * 
     * @type {string}
     * memberof Orchestration
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Orchestration
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Orchestration
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Orchestration
     */
    'created_at'?: string;
}


/**
 * The details for creating a new payment cycle
 * export
 * @interface OrchestrationCreateDeets
 */
export interface OrchestrationCreateDeets {
    /**
     * 
     * @type {OrchestrationMode}
     * memberof OrchestrationCreateDeets
     */
    'mode'?: OrchestrationMode;
    /**
     * 
     * @type {string}
     * memberof OrchestrationCreateDeets
     */
    'object'?: string | null;
}


/**
 * The payment cycle mode defines how a payment cycle behaves.  continuous (Orchestrations can remain continuously listening for funding until deliberately closed. Useful for open ended payment scenarios like tip links where funding trickles in based on exposure and engagement. In this scenario, the funding step will process income, calculate contracts, and attach sent payments to the orchestration for later reporting.)  batched (Batched orchestrations are for data imports. They\'re likely created as part of a backend process and are initiated via data feeds.)  immediate (Orchestrations can be interactively built up and immediately executed and closed. This is useful for explicit payment grouping scenarios where you want to prepare a set of payments and explicitly define funding up front. These can be funded via invoice or instant card payment still, but they are immediately executed)
 * export
 * @enum {string}
 */

export const OrchestrationMode = {
    /**
    * Orchestrations can remain continuously listening for funding until deliberately closed. Useful for open ended payment scenarios like tip links where funding trickles in based on exposure and engagement. In this scenario, the funding step will process income, calculate contracts, and attach sent payments to the orchestration for later reporting.
    */
    Continuous: 'continuous',
    /**
    * Batched orchestrations are for data imports. They&#39;re likely created as part of a backend process and are initiated via data feeds.
    */
    Batched: 'batched',
    /**
    * Orchestrations can be interactively built up and immediately executed and closed. This is useful for explicit payment grouping scenarios where you want to prepare a set of payments and explicitly define funding up front. These can be funded via invoice or instant card payment still, but they are immediately executed
    */
    Immediate: 'immediate'
} as const;

export type OrchestrationMode = typeof OrchestrationMode[keyof typeof OrchestrationMode];


/**
 * 
 * export
 * @interface OrchestrationRun
 */
export interface OrchestrationRun {
    /**
     * 
     * @type {string}
     * memberof OrchestrationRun
     */
    'mozaic_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof OrchestrationRun
     */
    'phase'?: string | null;
    /**
     * 
     * @type {string}
     * memberof OrchestrationRun
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * memberof OrchestrationRun
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * memberof OrchestrationRun
     */
    'started_at'?: string | null;
    /**
     * 
     * @type {string}
     * memberof OrchestrationRun
     */
    'ended_at'?: string | null;
    /**
     * 
     * @type {string}
     * memberof OrchestrationRun
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof OrchestrationRun
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof OrchestrationRun
     */
    'created_at'?: string;
}
/**
 * Defines a state for the general workflow of a payment cycle  draft  pending  funding  completed  canceled
 * export
 * @enum {string}
 */

export const OrchestrationStatus = {
    /**
    * 
    */
    Draft: 'draft',
    /**
    * 
    */
    Pending: 'pending',
    /**
    * 
    */
    Funding: 'funding',
    /**
    * 
    */
    Completed: 'completed',
    /**
    * 
    */
    Canceled: 'canceled'
} as const;

export type OrchestrationStatus = typeof OrchestrationStatus[keyof typeof OrchestrationStatus];


/**
 * 
 * export
 * @interface PayerInviteProfileResponse
 */
export interface PayerInviteProfileResponse {
    /**
     * 
     * @type {boolean}
     * memberof PayerInviteProfileResponse
     */
    'can_invite'?: boolean;
    /**
     * 
     * @type {number}
     * memberof PayerInviteProfileResponse
     */
    'availbale_invites'?: number;
    /**
     * 
     * @type {number}
     * memberof PayerInviteProfileResponse
     */
    'total_sent'?: number;
}
/**
 * 
 * export
 * @interface PayerInviteResponse
 */
export interface PayerInviteResponse {
    /**
     * 
     * @type {string}
     * memberof PayerInviteResponse
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayerInviteResponse
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayerInviteResponse
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayerInviteResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {PayerInviteStatus}
     * memberof PayerInviteResponse
     */
    'status'?: PayerInviteStatus;
    /**
     * 
     * @type {string}
     * memberof PayerInviteResponse
     */
    'invite_date'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayerInviteResponse
     */
    'expiration_date'?: string | null;
}


/**
 * 
 * export
 * @interface PayerInviteResponseListResponse
 */
export interface PayerInviteResponseListResponse {
    /**
     * 
     * @type {Array<PayerInviteResponse>}
     * memberof PayerInviteResponseListResponse
     */
    'data'?: Array<PayerInviteResponse> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof PayerInviteResponseListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof PayerInviteResponseListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof PayerInviteResponseListResponse
     */
    'total_count'?: number;
}
/**
 *   sent  accepted  expired
 * export
 * @enum {string}
 */

export const PayerInviteStatus = {
    /**
    * 
    */
    Sent: 'sent',
    /**
    * 
    */
    Accepted: 'accepted',
    /**
    * 
    */
    Expired: 'expired'
} as const;

export type PayerInviteStatus = typeof PayerInviteStatus[keyof typeof PayerInviteStatus];


/**
 * 
 * export
 * @interface Payment
 */
export interface Payment {
    /**
     * Flag: An indicator representing the payment acceptance status, distinct from the overall payment status.
     * @type {string}
     * memberof Payment
     */
    'acceptance_status'?: string | null;
    /**
     * Transaction IDs are used internally to group payment objects
     * @type {string}
     * memberof Payment
     */
    'transaction_id'?: string | null;
    /**
     * 
     * @type {BasicContact}
     * memberof Payment
     */
    'from'?: BasicContact;
    /**
     * 
     * @type {BasicContact}
     * memberof Payment
     */
    'to'?: BasicContact;
    /**
     * A memo to include with the payment
     * @type {string}
     * memberof Payment
     */
    'memo'?: string | null;
    /**
     * 
     * @type {Amount}
     * memberof Payment
     */
    'amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof Payment
     */
    'original_amount'?: Amount;
    /**
     * 
     * @type {FeeDirection}
     * memberof Payment
     */
    'fee_direction'?: FeeDirection;
    /**
     * 
     * @type {PaymentDirection}
     * memberof Payment
     */
    'direction'?: PaymentDirection;
    /**
     * The status of the payment
     * @type {string}
     * memberof Payment
     */
    'status'?: string | null;
    /**
     * User Display Status
     * @type {string}
     * memberof Payment
     */
    'user_status'?: string | null;
    /**
     * Id of the initiating user
     * @type {string}
     * memberof Payment
     */
    'user_id'?: string | null;
    /**
     * Id of the account authorized to send payments
     * @type {string}
     * memberof Payment
     */
    'tenant_id'?: string | null;
    /**
     * The transaction identifier from the wallet provider (external id)
     * @type {string}
     * memberof Payment
     */
    'wallet_transaction_id'?: string | null;
    /**
     * 
     * @type {Array<LineItem>}
     * memberof Payment
     */
    'Fees'?: Array<LineItem> | null;
    /**
     * 
     * @type {string}
     * memberof Payment
     */
    'funding_id'?: string | null;
    /**
     * 
     * @type {FundingType}
     * memberof Payment
     */
    'funding_type'?: FundingType;
    /**
     * To store various payment-related information
     * @type {string}
     * memberof Payment
     */
    'messsage'?: string | null;
    /**
     * 
     * @type {PaymentProcessingDetails}
     * memberof Payment
     */
    'payment_processing_details'?: PaymentProcessingDetails;
    /**
     * Payment transfer id
     * @type {string}
     * memberof Payment
     */
    'transfer_id'?: string | null;
    /**
     * <p>Payment Cycle identifier.</p>
     * @type {string}
     * memberof Payment
     */
    'payment_cycle_id'?: string | null;
    /**
     * 
     * @type {PaymentSource}
     * memberof Payment
     */
    'payment_source'?: PaymentSource;
    /**
     * <p>Invoice External ID for Payment Cycle Invoice Funding Source </p>
     * @type {string}
     * memberof Payment
     */
    'invoice_id'?: string | null;
    /**
     * 
     * @type {Amount}
     * memberof Payment
     */
    'total_fees'?: Amount;
    /**
     * 
     * @type {PaymentRecordDirection}
     * memberof Payment
     */
    'payment_direction'?: PaymentRecordDirection;
    /**
     * Wallet id
     * @type {string}
     * memberof Payment
     */
    'wallet_key'?: string | null;
    /**
     * Payment payout id
     * @type {string}
     * memberof Payment
     */
    'payout_id'?: string | null;
    /**
     * 
     * @type {LedgerType}
     * memberof Payment
     */
    'ledger_type'?: LedgerType;
    /**
     * 
     * @type {string}
     * memberof Payment
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Payment
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Payment
     */
    'created_at'?: string;
}


/**
 * 
 * export
 * @interface PaymentAcceptDeets
 */
export interface PaymentAcceptDeets {
    /**
     * Account Id to accept payments from
     * @type {string}
     * memberof PaymentAcceptDeets
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {AcceptPaymentStatusEnum}
     * memberof PaymentAcceptDeets
     */
    'status'?: AcceptPaymentStatusEnum;
    /**
     * 
     * @type {string}
     * memberof PaymentAcceptDeets
     */
    'object'?: string | null;
}


/**
 * 
 * export
 * @interface PaymentAcceptResponse
 */
export interface PaymentAcceptResponse {
    /**
     * Account Id to accept payments from
     * @type {string}
     * memberof PaymentAcceptResponse
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {AcceptPaymentStatusEnum}
     * memberof PaymentAcceptResponse
     */
    'status'?: AcceptPaymentStatusEnum;
}


/**
 * 
 * export
 * @interface PaymentBankAccountCreateDeets
 */
export interface PaymentBankAccountCreateDeets {
    /**
     * 
     * @type {string}
     * memberof PaymentBankAccountCreateDeets
     */
    'account_holder_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentBankAccountCreateDeets
     */
    'account_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentBankAccountCreateDeets
     */
    'aba_routing_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentBankAccountCreateDeets
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentBankAccountCreateDeets
     */
    'currency'?: string | null;
    /**
     * Holder type can be company or individual
     * @type {string}
     * memberof PaymentBankAccountCreateDeets
     */
    'account_holder_type'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentBankAccountCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentBankAccountUpdateDeets
 */
export interface PaymentBankAccountUpdateDeets {
    /**
     * 
     * @type {string}
     * memberof PaymentBankAccountUpdateDeets
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentBankAccountUpdateDeets
     */
    'account_holder_name'?: string | null;
    /**
     * Holder type can be company or individual
     * @type {string}
     * memberof PaymentBankAccountUpdateDeets
     */
    'account_holder_type'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentBulkResultResponse
 */
export interface PaymentBulkResultResponse {
    /**
     * 
     * @type {Payment}
     * memberof PaymentBulkResultResponse
     */
    'result'?: Payment;
    /**
     * 
     * @type {boolean}
     * memberof PaymentBulkResultResponse
     */
    'is_readonly'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof PaymentBulkResultResponse
     */
    'is_successful'?: boolean;
    /**
     * 
     * @type {Array<BulkErrorResponse>}
     * memberof PaymentBulkResultResponse
     */
    'errors'?: Array<BulkErrorResponse> | null;
}
/**
 * 
 * export
 * @interface PaymentBulkResultResponseListResponse
 */
export interface PaymentBulkResultResponseListResponse {
    /**
     * 
     * @type {Array<PaymentBulkResultResponse>}
     * memberof PaymentBulkResultResponseListResponse
     */
    'data'?: Array<PaymentBulkResultResponse> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof PaymentBulkResultResponseListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof PaymentBulkResultResponseListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof PaymentBulkResultResponseListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface PaymentCancelDeets
 */
export interface PaymentCancelDeets {
    /**
     * 
     * @type {string}
     * memberof PaymentCancelDeets
     */
    'wallet_key'?: string | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof PaymentCancelDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCancelDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentCardCreateDeets
 */
export interface PaymentCardCreateDeets {
    /**
     * 
     * @type {BillingDeets}
     * memberof PaymentCardCreateDeets
     */
    'billing'?: BillingDeets;
    /**
     * 
     * @type {number}
     * memberof PaymentCardCreateDeets
     */
    'exp_month'?: number;
    /**
     * 
     * @type {number}
     * memberof PaymentCardCreateDeets
     */
    'exp_year'?: number;
    /**
     * 
     * @type {string}
     * memberof PaymentCardCreateDeets
     */
    'cvc'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCardCreateDeets
     */
    'number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCardCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentCardUpdateDeets
 */
export interface PaymentCardUpdateDeets {
    /**
     * 
     * @type {string}
     * memberof PaymentCardUpdateDeets
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof PaymentCardUpdateDeets
     */
    'address'?: AddressDeets;
    /**
     * 
     * @type {number}
     * memberof PaymentCardUpdateDeets
     */
    'exp_month'?: number;
    /**
     * 
     * @type {number}
     * memberof PaymentCardUpdateDeets
     */
    'exp_year'?: number;
    /**
     * 
     * @type {string}
     * memberof PaymentCardUpdateDeets
     */
    'name'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentCycle
 */
export interface PaymentCycle {
    /**
     * 
     * @type {string}
     * memberof PaymentCycle
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycle
     */
    'invoice_id'?: string | null;
    /**
     * 
     * @type {FeeDirection}
     * memberof PaymentCycle
     */
    'fee_direction'?: FeeDirection;
    /**
     * 
     * @type {string}
     * memberof PaymentCycle
     */
    'memo'?: string | null;
    /**
     * 
     * @type {PaymentCycleStatus}
     * memberof PaymentCycle
     */
    'status'?: PaymentCycleStatus;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycle
     */
    'amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycle
     */
    'original_amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycle
     */
    'fees'?: Amount;
    /**
     * Accounting start date
     * @type {string}
     * memberof PaymentCycle
     */
    'accounting_from'?: string | null;
    /**
     * Accounting end date
     * @type {string}
     * memberof PaymentCycle
     */
    'accounting_to'?: string | null;
    /**
     * 
     * @type {BasicContact}
     * memberof PaymentCycle
     */
    'from'?: BasicContact;
    /**
     * 
     * @type {number}
     * memberof PaymentCycle
     */
    'total_entries'?: number;
    /**
     * 
     * @type {string}
     * memberof PaymentCycle
     */
    'payment_date'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycle
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycle
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycle
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycle
     */
    'created_at'?: string;
}


/**
 * 
 * export
 * @interface PaymentCycleBulkEntryCreateDeets
 */
export interface PaymentCycleBulkEntryCreateDeets {
    /**
     * 
     * @type {Array<PaymentCycleEntryCreateDeets>}
     * memberof PaymentCycleBulkEntryCreateDeets
     */
    'data'?: Array<PaymentCycleEntryCreateDeets> | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof PaymentCycleBulkEntryCreateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleBulkEntryCreateDeets
     */
    'object'?: string | null;
}
/**
 * PaymentCycle_CreateDeets
 * export
 * @interface PaymentCycleCreateDeets
 */
export interface PaymentCycleCreateDeets {
    /**
     * 
     * @type {FeeDirection}
     * memberof PaymentCycleCreateDeets
     */
    'fee_direction'?: FeeDirection;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleCreateDeets
     */
    'memo'?: string | null;
    /**
     * Accounting start date
     * @type {string}
     * memberof PaymentCycleCreateDeets
     */
    'accounting_from'?: string;
    /**
     * Accounting end date
     * @type {string}
     * memberof PaymentCycleCreateDeets
     */
    'accounting_to'?: string;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleCreateDeets
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleCreateDeets
     */
    'object'?: string | null;
}


/**
 * Payment Cycle paymanet entry - for push payment
 * export
 * @interface PaymentCycleEntry
 */
export interface PaymentCycleEntry {
    /**
     * 
     * @type {BasicContact}
     * memberof PaymentCycleEntry
     */
    'to'?: BasicContact;
    /**
     * 
     * @type {BasicContact}
     * memberof PaymentCycleEntry
     */
    'from'?: BasicContact;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntry
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntry
     */
    'payment_cycle_id'?: string | null;
    /**
     * 
     * @type {PaymentCycleEntryStatus}
     * memberof PaymentCycleEntry
     */
    'status'?: PaymentCycleEntryStatus;
    /**
     * 
     * @type {Array<LineItem>}
     * memberof PaymentCycleEntry
     */
    'fees'?: Array<LineItem> | null;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleEntry
     */
    'gross_amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleEntry
     */
    'original_amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleEntry
     */
    'amount'?: Amount;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntry
     */
    'memo'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntry
     */
    'persona_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntry
     */
    'payment_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntry
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntry
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntry
     */
    'created_at'?: string;
}


/**
 * 
 * export
 * @interface PaymentCycleEntryBulkResultResponse
 */
export interface PaymentCycleEntryBulkResultResponse {
    /**
     * 
     * @type {PaymentCycleEntry}
     * memberof PaymentCycleEntryBulkResultResponse
     */
    'result'?: PaymentCycleEntry;
    /**
     * 
     * @type {boolean}
     * memberof PaymentCycleEntryBulkResultResponse
     */
    'is_readonly'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof PaymentCycleEntryBulkResultResponse
     */
    'is_successful'?: boolean;
    /**
     * 
     * @type {Array<BulkErrorResponse>}
     * memberof PaymentCycleEntryBulkResultResponse
     */
    'errors'?: Array<BulkErrorResponse> | null;
}
/**
 * 
 * export
 * @interface PaymentCycleEntryBulkResultResponseListResponse
 */
export interface PaymentCycleEntryBulkResultResponseListResponse {
    /**
     * 
     * @type {Array<PaymentCycleEntryBulkResultResponse>}
     * memberof PaymentCycleEntryBulkResultResponseListResponse
     */
    'data'?: Array<PaymentCycleEntryBulkResultResponse> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof PaymentCycleEntryBulkResultResponseListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof PaymentCycleEntryBulkResultResponseListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof PaymentCycleEntryBulkResultResponseListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface PaymentCycleEntryCreateDeets
 */
export interface PaymentCycleEntryCreateDeets {
    /**
     * 
     * @type {BasicContact}
     * memberof PaymentCycleEntryCreateDeets
     */
    'to'?: BasicContact;
    /**
     * 
     * @type {BasicContact}
     * memberof PaymentCycleEntryCreateDeets
     */
    'from'?: BasicContact;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntryCreateDeets
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntryCreateDeets
     */
    'payment_cycle_id'?: string | null;
    /**
     * 
     * @type {PaymentCycleEntryStatus}
     * memberof PaymentCycleEntryCreateDeets
     */
    'status'?: PaymentCycleEntryStatus;
    /**
     * 
     * @type {Array<LineItem>}
     * memberof PaymentCycleEntryCreateDeets
     */
    'fees'?: Array<LineItem> | null;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleEntryCreateDeets
     */
    'amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleEntryCreateDeets
     */
    'original_amount'?: Amount;
    /**
     * 
     * @type {FeeDirection}
     * memberof PaymentCycleEntryCreateDeets
     */
    'fee_direction'?: FeeDirection;
    /**
     * 
     * @type {FundingSource}
     * memberof PaymentCycleEntryCreateDeets
     */
    'funding_source'?: FundingSource;
    /**
     * <p>Invoice External ID for Payment Cycle Invoice Funding Source </p>
     * @type {string}
     * memberof PaymentCycleEntryCreateDeets
     */
    'invoice_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntryCreateDeets
     */
    'object'?: string | null;
}


/**
 * 
 * export
 * @interface PaymentCycleEntryListResponse
 */
export interface PaymentCycleEntryListResponse {
    /**
     * 
     * @type {Array<PaymentCycleEntry>}
     * memberof PaymentCycleEntryListResponse
     */
    'data'?: Array<PaymentCycleEntry> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof PaymentCycleEntryListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof PaymentCycleEntryListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof PaymentCycleEntryListResponse
     */
    'total_count'?: number;
}
/**
 *   draft  success  warning  error  processing
 * export
 * @enum {string}
 */

export const PaymentCycleEntryStatus = {
    /**
    * 
    */
    Draft: 'draft',
    /**
    * 
    */
    Success: 'success',
    /**
    * 
    */
    Warning: 'warning',
    /**
    * 
    */
    Error: 'error',
    /**
    * 
    */
    Processing: 'processing'
} as const;

export type PaymentCycleEntryStatus = typeof PaymentCycleEntryStatus[keyof typeof PaymentCycleEntryStatus];


/**
 * 
 * export
 * @interface PaymentCycleEntryUpdateDeets
 */
export interface PaymentCycleEntryUpdateDeets {
    /**
     * 
     * @type {BasicContact}
     * memberof PaymentCycleEntryUpdateDeets
     */
    'to'?: BasicContact;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntryUpdateDeets
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntryUpdateDeets
     */
    'payment_cycle_id'?: string | null;
    /**
     * 
     * @type {PaymentCycleEntryStatus}
     * memberof PaymentCycleEntryUpdateDeets
     */
    'status'?: PaymentCycleEntryStatus;
    /**
     * 
     * @type {Array<LineItem>}
     * memberof PaymentCycleEntryUpdateDeets
     */
    'fees'?: Array<LineItem> | null;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleEntryUpdateDeets
     */
    'amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleEntryUpdateDeets
     */
    'original_amount'?: Amount;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof PaymentCycleEntryUpdateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleEntryUpdateDeets
     */
    'object'?: string | null;
}


/**
 * payment cycle fields  none  email  amount  phoneNumber  startDate  endDate  startAndEndDate  name  countryCode
 * export
 * @enum {string}
 */

export const PaymentCycleFieldEnum = {
    /**
    * 
    */
    None: 'none',
    /**
    * 
    */
    Email: 'email',
    /**
    * 
    */
    Amount: 'amount',
    /**
    * 
    */
    PhoneNumber: 'phoneNumber',
    /**
    * 
    */
    StartDate: 'startDate',
    /**
    * 
    */
    EndDate: 'endDate',
    /**
    * 
    */
    StartAndEndDate: 'startAndEndDate',
    /**
    * 
    */
    Name: 'name',
    /**
    * 
    */
    CountryCode: 'countryCode'
} as const;

export type PaymentCycleFieldEnum = typeof PaymentCycleFieldEnum[keyof typeof PaymentCycleFieldEnum];


/**
 * 
 * export
 * @interface PaymentCycleFile
 */
export interface PaymentCycleFile {
    /**
     * validation information
     * @type {Array<PaymentCycleFileField>}
     * memberof PaymentCycleFile
     */
    'fields_data'?: Array<PaymentCycleFileField> | null;
    /**
     * Header validation information
     * @type {Array<string>}
     * memberof PaymentCycleFile
     */
    'header_validation'?: Array<string> | null;
    /**
     * payment cycle entries
     * @type {Array<PaymentCycleEntry>}
     * memberof PaymentCycleFile
     */
    'payment_cycle_entry'?: Array<PaymentCycleEntry> | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFile
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFile
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFile
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface PaymentCycleFileField
 */
export interface PaymentCycleFileField {
    /**
     * name of the receiving person
     * @type {string}
     * memberof PaymentCycleFileField
     */
    'name'?: string | null;
    /**
     * email of receiving person.
     * @type {string}
     * memberof PaymentCycleFileField
     */
    'email'?: string | null;
    /**
     * amoount to be send
     * @type {number}
     * memberof PaymentCycleFileField
     */
    'amount'?: number;
    /**
     * Is valid record
     * @type {boolean}
     * memberof PaymentCycleFileField
     */
    'is_valid': boolean;
    /**
     * validation information
     * @type {Array<ValidationError>}
     * memberof PaymentCycleFileField
     */
    'validation_errors'?: Array<ValidationError> | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFileField
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFileField
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFileField
     */
    'created_at'?: string;
}
/**
 *   payouts
 * export
 * @enum {string}
 */

export const PaymentCycleFileType = {
    /**
    * 
    */
    Payouts: 'payouts'
} as const;

export type PaymentCycleFileType = typeof PaymentCycleFileType[keyof typeof PaymentCycleFileType];


/**
 * 
 * export
 * @interface PaymentCycleFinalizeDeets
 */
export interface PaymentCycleFinalizeDeets {
    /**
     * 
     * @type {boolean}
     * memberof PaymentCycleFinalizeDeets
     */
    'auto_advance'?: boolean;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFinalizeDeets
     */
    'payment_method_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFinalizeDeets
     */
    'collection_method'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof PaymentCycleFinalizeDeets
     */
    'ach_auto_reconciliation'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof PaymentCycleFinalizeDeets
     */
    'auto_finalize_invoice'?: boolean;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof PaymentCycleFinalizeDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFinalizeDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentCycleFinalizeResponse
 */
export interface PaymentCycleFinalizeResponse {
    /**
     * 
     * @type {Invoice}
     * memberof PaymentCycleFinalizeResponse
     */
    'invoice'?: Invoice;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFinalizeResponse
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFinalizeResponse
     */
    'invoice_id'?: string | null;
    /**
     * 
     * @type {FeeDirection}
     * memberof PaymentCycleFinalizeResponse
     */
    'fee_direction'?: FeeDirection;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFinalizeResponse
     */
    'memo'?: string | null;
    /**
     * 
     * @type {PaymentCycleStatus}
     * memberof PaymentCycleFinalizeResponse
     */
    'status'?: PaymentCycleStatus;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleFinalizeResponse
     */
    'amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleFinalizeResponse
     */
    'original_amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleFinalizeResponse
     */
    'fees'?: Amount;
    /**
     * Accounting start date
     * @type {string}
     * memberof PaymentCycleFinalizeResponse
     */
    'accounting_from'?: string | null;
    /**
     * Accounting end date
     * @type {string}
     * memberof PaymentCycleFinalizeResponse
     */
    'accounting_to'?: string | null;
    /**
     * 
     * @type {BasicContact}
     * memberof PaymentCycleFinalizeResponse
     */
    'from'?: BasicContact;
    /**
     * 
     * @type {number}
     * memberof PaymentCycleFinalizeResponse
     */
    'total_entries'?: number;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFinalizeResponse
     */
    'payment_date'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFinalizeResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFinalizeResponse
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFinalizeResponse
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleFinalizeResponse
     */
    'created_at'?: string;
}


/**
 * 
 * export
 * @interface PaymentCycleListResponse
 */
export interface PaymentCycleListResponse {
    /**
     * 
     * @type {Array<PaymentCycle>}
     * memberof PaymentCycleListResponse
     */
    'data'?: Array<PaymentCycle> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof PaymentCycleListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof PaymentCycleListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof PaymentCycleListResponse
     */
    'total_count'?: number;
}
/**
 *   draft  locked  processing  invoicing  cancelled  completed  completedWithErrors  failed
 * export
 * @enum {string}
 */

export const PaymentCycleStatus = {
    /**
    * 
    */
    Draft: 'draft',
    /**
    * 
    */
    Locked: 'locked',
    /**
    * 
    */
    Processing: 'processing',
    /**
    * 
    */
    Invoicing: 'invoicing',
    /**
    * 
    */
    Cancelled: 'cancelled',
    /**
    * 
    */
    Completed: 'completed',
    /**
    * 
    */
    CompletedWithErrors: 'completedWithErrors',
    /**
    * 
    */
    Failed: 'failed'
} as const;

export type PaymentCycleStatus = typeof PaymentCycleStatus[keyof typeof PaymentCycleStatus];


/**
 * 
 * export
 * @interface PaymentCycleUpdateDeets
 */
export interface PaymentCycleUpdateDeets {
    /**
     * 
     * @type {string}
     * memberof PaymentCycleUpdateDeets
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleUpdateDeets
     */
    'invoice_id'?: string | null;
    /**
     * 
     * @type {FeeDirection}
     * memberof PaymentCycleUpdateDeets
     */
    'fee_direction'?: FeeDirection;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleUpdateDeets
     */
    'memo'?: string | null;
    /**
     * 
     * @type {PaymentCycleStatus}
     * memberof PaymentCycleUpdateDeets
     */
    'status'?: PaymentCycleStatus;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleUpdateDeets
     */
    'amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentCycleUpdateDeets
     */
    'original_amount'?: Amount;
    /**
     * Accounting start date
     * @type {string}
     * memberof PaymentCycleUpdateDeets
     */
    'accounting_from'?: string | null;
    /**
     * Accounting end date
     * @type {string}
     * memberof PaymentCycleUpdateDeets
     */
    'accounting_to'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleUpdateDeets
     */
    'name'?: string | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof PaymentCycleUpdateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentCycleUpdateDeets
     */
    'object'?: string | null;
}


/**
 * validation type  info  warning  error
 * export
 * @enum {string}
 */

export const PaymentCycleValidationType = {
    /**
    * 
    */
    Info: 'info',
    /**
    * 
    */
    Warning: 'warning',
    /**
    * 
    */
    Error: 'error'
} as const;

export type PaymentCycleValidationType = typeof PaymentCycleValidationType[keyof typeof PaymentCycleValidationType];


/**
 *   in  out
 * export
 * @enum {string}
 */

export const PaymentDetailsDirection = {
    /**
    * 
    */
    In: 'in',
    /**
    * 
    */
    Out: 'out'
} as const;

export type PaymentDetailsDirection = typeof PaymentDetailsDirection[keyof typeof PaymentDetailsDirection];


/**
 * PaymentDetails_UpdateDeets used for updating payment processing details
 * export
 * @interface PaymentDetailsUpdateDeets
 */
export interface PaymentDetailsUpdateDeets {
    /**
     * Internal Number
     * @type {string}
     * memberof PaymentDetailsUpdateDeets
     */
    'internal_number'?: string | null;
    /**
     * External ID
     * @type {string}
     * memberof PaymentDetailsUpdateDeets
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentDetailsUpdateDeets
     */
    'payee_internal_id'?: string | null;
    /**
     * Payment provider ref code
     * @type {string}
     * memberof PaymentDetailsUpdateDeets
     */
    'payment_provider_ref_code'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentDetailsUpdateDeets
     */
    'object'?: string | null;
}
/**
 *   push  request  smartContract  paymentCycle  transfer
 * export
 * @enum {string}
 */

export const PaymentDirection = {
    /**
    * 
    */
    Push: 'push',
    /**
    * 
    */
    Request: 'request',
    /**
    * 
    */
    SmartContract: 'smartContract',
    /**
    * 
    */
    PaymentCycle: 'paymentCycle',
    /**
    * 
    */
    Transfer: 'transfer'
} as const;

export type PaymentDirection = typeof PaymentDirection[keyof typeof PaymentDirection];


/**
 * 
 * export
 * @interface PaymentIntentRequestDeets
 */
export interface PaymentIntentRequestDeets {
    /**
     * 
     * @type {string}
     * memberof PaymentIntentRequestDeets
     */
    'invoice-id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentIntentRequestDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentInviteAcceptCreateDeets
 */
export interface PaymentInviteAcceptCreateDeets {
    /**
     * 
     * @type {string}
     * memberof PaymentInviteAcceptCreateDeets
     */
    'token'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentInviteAcceptCreateDeets
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentInviteAcceptCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentInviteCreateDeets
 */
export interface PaymentInviteCreateDeets {
    /**
     * 
     * @type {string}
     * memberof PaymentInviteCreateDeets
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentInviteCreateDeets
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentInviteCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentListResponse
 */
export interface PaymentListResponse {
    /**
     * 
     * @type {Array<Payment>}
     * memberof PaymentListResponse
     */
    'data'?: Array<Payment> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof PaymentListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof PaymentListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof PaymentListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
    /**
     * 
     * @type {string}
     * memberof PaymentMethod
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentMethod
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentMethod
     */
    'payment_method_type'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentMethod
     */
    'last_four'?: string | null;
    /**
     * When Type = Card, this will be the brand (e.g. Visa, etc)
     * @type {string}
     * memberof PaymentMethod
     */
    'brand'?: string | null;
    /**
     * Holder type can be company or individual
     * @type {string}
     * memberof PaymentMethod
     */
    'account_holder_type'?: string | null;
    /**
     * When Type = Bank, Name of the bank associated with the routing number
     * @type {string}
     * memberof PaymentMethod
     */
    'account_bank_name'?: string | null;
    /**
     * 
     * @type {Expiration}
     * memberof PaymentMethod
     */
    'exp'?: Expiration;
    /**
     * 
     * @type {boolean}
     * memberof PaymentMethod
     */
    'default_for_currency'?: boolean;
    /**
     * 
     * @type {string}
     * memberof PaymentMethod
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentMethod
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentMethod
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface PaymentMethodCreateDeets
 */
export interface PaymentMethodCreateDeets {
    /**
     * 
     * @type {PaymentBankAccountCreateDeets}
     * memberof PaymentMethodCreateDeets
     */
    'bank_account'?: PaymentBankAccountCreateDeets;
    /**
     * 
     * @type {string}
     * memberof PaymentMethodCreateDeets
     */
    'bank_account_token'?: string | null;
    /**
     * 
     * @type {PaymentCardCreateDeets}
     * memberof PaymentMethodCreateDeets
     */
    'card'?: PaymentCardCreateDeets;
    /**
     * 
     * @type {string}
     * memberof PaymentMethodCreateDeets
     */
    'card_token'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof PaymentMethodCreateDeets
     */
    'default_for_currency'?: boolean;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof PaymentMethodCreateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentMethodCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentMethodUpdateDeets
 */
export interface PaymentMethodUpdateDeets {
    /**
     * 
     * @type {PaymentBankAccountUpdateDeets}
     * memberof PaymentMethodUpdateDeets
     */
    'bank_account'?: PaymentBankAccountUpdateDeets;
    /**
     * 
     * @type {PaymentCardUpdateDeets}
     * memberof PaymentMethodUpdateDeets
     */
    'card'?: PaymentCardUpdateDeets;
    /**
     * 
     * @type {boolean}
     * memberof PaymentMethodUpdateDeets
     */
    'default_for_currency'?: boolean;
    /**
     * 
     * @type {string}
     * memberof PaymentMethodUpdateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentPayoutMethodCreateDeets
 */
export interface PaymentPayoutMethodCreateDeets {
    /**
     * 
     * @type {PaymentPayoutMethodTokenizedCreateDeets}
     * memberof PaymentPayoutMethodCreateDeets
     */
    'payment_method'?: PaymentPayoutMethodTokenizedCreateDeets;
    /**
     * 
     * @type {PaymentPayoutMethodTokenizedCreateDeets}
     * memberof PaymentPayoutMethodCreateDeets
     */
    'payout_method'?: PaymentPayoutMethodTokenizedCreateDeets;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof PaymentPayoutMethodCreateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentPayoutMethodCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentPayoutMethodTokenizedCreateDeets
 */
export interface PaymentPayoutMethodTokenizedCreateDeets {
    /**
     * 
     * @type {string}
     * memberof PaymentPayoutMethodTokenizedCreateDeets
     */
    'BankAccountToken'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentPayoutMethodTokenizedCreateDeets
     */
    'CardToken'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentProcessingDetails
 */
export interface PaymentProcessingDetails {
    /**
     * 
     * @type {Amount}
     * memberof PaymentProcessingDetails
     */
    'amount_submitted'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentProcessingDetails
     */
    'payee_transaction_fee'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentProcessingDetails
     */
    'net_amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentProcessingDetails
     */
    'amount_paid'?: Amount;
    /**
     * Last 4 card digits in case of PaymentMethod = card
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'Last4CardDigits'?: string | null;
    /**
     * Account number
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'account_number'?: string | null;
    /**
     * Account Routing
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'account_routing'?: string | null;
    /**
     * Payment provider ref code
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'payment_provider_ref_code'?: string | null;
    /**
     * Debit date
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'debit_date'?: string | null;
    /**
     * Clearing Date
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'clearing_date'?: string | null;
    /**
     * Value date
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'value_date'?: string | null;
    /**
     * Payment method
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'payment_method'?: string | null;
    /**
     * 
     * @type {PaymentDetailsDirection}
     * memberof PaymentProcessingDetails
     */
    'direction'?: PaymentDetailsDirection;
    /**
     * Provider account
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'provider_account'?: string | null;
    /**
     * Internal Number
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'internal_number'?: string | null;
    /**
     * External ID
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'external_id'?: string | null;
    /**
     * Payee Internal ID
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'payee_internal_id'?: string | null;
    /**
     * Processing Details Status
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'card_brand'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'accounting_from'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'accounting_to'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentProcessingDetails
     */
    'created_at'?: string;
}


/**
 * 
 * export
 * @interface PaymentPushBulkCreateDeets
 */
export interface PaymentPushBulkCreateDeets {
    /**
     * 
     * @type {Array<PaymentPushCreateDeets>}
     * memberof PaymentPushBulkCreateDeets
     */
    'data'?: Array<PaymentPushCreateDeets> | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof PaymentPushBulkCreateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentPushBulkCreateDeets
     */
    'object'?: string | null;
}
/**
 * PaymentPush_CreateDeets used for creating PaymentPushes
 * export
 * @interface PaymentPushCreateDeets
 */
export interface PaymentPushCreateDeets {
    /**
     * 
     * @type {BasicContactDeets}
     * memberof PaymentPushCreateDeets
     */
    'from'?: BasicContactDeets;
    /**
     * 
     * @type {BasicContactDeets}
     * memberof PaymentPushCreateDeets
     */
    'to': BasicContactDeets;
    /**
     * A memo to include with the payment
     * @type {string}
     * memberof PaymentPushCreateDeets
     */
    'memo'?: string | null;
    /**
     * 
     * @type {Amount}
     * memberof PaymentPushCreateDeets
     */
    'amount': Amount;
    /**
     * 
     * @type {FeeDirection}
     * memberof PaymentPushCreateDeets
     */
    'fee_direction': FeeDirection;
    /**
     * <p>Setting to true will ignore contracts for this tenant tied to the payee or payer.              If unspecified or false, contracts, such as recoupables, will be applied by default</p>
     * @type {boolean}
     * memberof PaymentPushCreateDeets
     */
    'ignore_contracts'?: boolean;
    /**
     * 
     * @type {FundingSource}
     * memberof PaymentPushCreateDeets
     */
    'funding_source'?: FundingSource;
    /**
     * 
     * @type {PaymentSource}
     * memberof PaymentPushCreateDeets
     */
    'payment_source'?: PaymentSource;
    /**
     * <p>Invoice External ID for Payment Cycle Invoice Funding Source </p>
     * @type {string}
     * memberof PaymentPushCreateDeets
     */
    'invoice_id'?: string | null;
    /**
     * 
     * @type {PaymentDirection}
     * memberof PaymentPushCreateDeets
     */
    'payment_direction'?: PaymentDirection;
    /**
     * 
     * @type {string}
     * memberof PaymentPushCreateDeets
     */
    'accounting_from'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentPushCreateDeets
     */
    'accounting_to'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentPushCreateDeets
     */
    'object'?: string | null;
}


/**
 * PaymentPush_CreateDeets used for creating PaymentPushes
 * export
 * @interface PaymentPushCreateJournalDeets
 */
export interface PaymentPushCreateJournalDeets {
    /**
     * <p>The date of the journal entry in UTC</p>
     * @type {string}
     * memberof PaymentPushCreateJournalDeets
     */
    'journal_date'?: string;
    /**
     * 
     * @type {BasicContactDeets}
     * memberof PaymentPushCreateJournalDeets
     */
    'from'?: BasicContactDeets;
    /**
     * 
     * @type {BasicContactDeets}
     * memberof PaymentPushCreateJournalDeets
     */
    'to': BasicContactDeets;
    /**
     * A memo to include with the payment
     * @type {string}
     * memberof PaymentPushCreateJournalDeets
     */
    'memo'?: string | null;
    /**
     * 
     * @type {Amount}
     * memberof PaymentPushCreateJournalDeets
     */
    'amount': Amount;
    /**
     * 
     * @type {FeeDirection}
     * memberof PaymentPushCreateJournalDeets
     */
    'fee_direction': FeeDirection;
    /**
     * <p>Setting to true will ignore contracts for this tenant tied to the payee or payer.              If unspecified or false, contracts, such as recoupables, will be applied by default</p>
     * @type {boolean}
     * memberof PaymentPushCreateJournalDeets
     */
    'ignore_contracts'?: boolean;
    /**
     * 
     * @type {FundingSource}
     * memberof PaymentPushCreateJournalDeets
     */
    'funding_source'?: FundingSource;
    /**
     * 
     * @type {PaymentSource}
     * memberof PaymentPushCreateJournalDeets
     */
    'payment_source'?: PaymentSource;
    /**
     * <p>Invoice External ID for Payment Cycle Invoice Funding Source </p>
     * @type {string}
     * memberof PaymentPushCreateJournalDeets
     */
    'invoice_id'?: string | null;
    /**
     * 
     * @type {PaymentDirection}
     * memberof PaymentPushCreateJournalDeets
     */
    'payment_direction'?: PaymentDirection;
    /**
     * 
     * @type {string}
     * memberof PaymentPushCreateJournalDeets
     */
    'accounting_from'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentPushCreateJournalDeets
     */
    'accounting_to'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentPushCreateJournalDeets
     */
    'object'?: string | null;
}


/**
 * 
 * export
 * @interface PaymentPushResponse
 */
export interface PaymentPushResponse {
    /**
     * A list of one or more payments that match the search request
     * @type {Array<Payment>}
     * memberof PaymentPushResponse
     */
    'payments'?: Array<Payment> | null;
    /**
     * 
     * @type {string}
     * memberof PaymentPushResponse
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentPushResponse
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentPushResponse
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface PaymentPushUpdateDeets
 */
export interface PaymentPushUpdateDeets {
    /**
     * 
     * @type {PaymentSourceEnum}
     * memberof PaymentPushUpdateDeets
     */
    'payment_source'?: PaymentSourceEnum;
    /**
     * 
     * @type {string}
     * memberof PaymentPushUpdateDeets
     */
    'payment_source_id'?: string | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof PaymentPushUpdateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentPushUpdateDeets
     */
    'object'?: string | null;
}


/**
 *   in  out
 * export
 * @enum {string}
 */

export const PaymentRecordDirection = {
    /**
    * 
    */
    In: 'in',
    /**
    * 
    */
    Out: 'out'
} as const;

export type PaymentRecordDirection = typeof PaymentRecordDirection[keyof typeof PaymentRecordDirection];


/**
 * 
 * export
 * @interface PaymentSource
 */
export interface PaymentSource {
    /**
     * 
     * @type {string}
     * memberof PaymentSource
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentSource
     */
    'payment_source'?: string | null;
}
/**
 *   contract  simpleContract  paymentCycle  tipLink
 * export
 * @enum {string}
 */

export const PaymentSourceEnum = {
    /**
    * 
    */
    Contract: 'contract',
    /**
    * 
    */
    SimpleContract: 'simpleContract',
    /**
    * 
    */
    PaymentCycle: 'paymentCycle',
    /**
    * 
    */
    TipLink: 'tipLink'
} as const;

export type PaymentSourceEnum = typeof PaymentSourceEnum[keyof typeof PaymentSourceEnum];


/**
 * 
 * export
 * @interface PaymentTransfer
 */
export interface PaymentTransfer {
    /**
     * 
     * @type {string}
     * memberof PaymentTransfer
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {Amount}
     * memberof PaymentTransfer
     */
    'transfer_amount'?: Amount;
    /**
     * Transaction IDs are used internally to group payment objects
     * @type {string}
     * memberof PaymentTransfer
     */
    'transaction_id'?: string | null;
    /**
     * 
     * @type {BasicContact}
     * memberof PaymentTransfer
     */
    'from'?: BasicContact;
    /**
     * 
     * @type {BasicContact}
     * memberof PaymentTransfer
     */
    'to'?: BasicContact;
    /**
     * A memo to include with the payment
     * @type {string}
     * memberof PaymentTransfer
     */
    'memo'?: string | null;
    /**
     * 
     * @type {Amount}
     * memberof PaymentTransfer
     */
    'amount'?: Amount;
    /**
     * 
     * @type {Amount}
     * memberof PaymentTransfer
     */
    'original_amount'?: Amount;
    /**
     * 
     * @type {FeeDirection}
     * memberof PaymentTransfer
     */
    'fee_direction'?: FeeDirection;
    /**
     * 
     * @type {PaymentDirection}
     * memberof PaymentTransfer
     */
    'direction'?: PaymentDirection;
    /**
     * The status of the payment
     * @type {string}
     * memberof PaymentTransfer
     */
    'status'?: string | null;
    /**
     * User Display Status
     * @type {string}
     * memberof PaymentTransfer
     */
    'user_status'?: string | null;
    /**
     * Id of the initiating user
     * @type {string}
     * memberof PaymentTransfer
     */
    'user_id'?: string | null;
    /**
     * Id of the account authorized to send payments
     * @type {string}
     * memberof PaymentTransfer
     */
    'tenant_id'?: string | null;
    /**
     * The transaction identifier from the wallet provider (external id)
     * @type {string}
     * memberof PaymentTransfer
     */
    'wallet_transaction_id'?: string | null;
    /**
     * 
     * @type {Array<LineItem>}
     * memberof PaymentTransfer
     */
    'Fees'?: Array<LineItem> | null;
    /**
     * 
     * @type {string}
     * memberof PaymentTransfer
     */
    'funding_id'?: string | null;
    /**
     * 
     * @type {FundingType}
     * memberof PaymentTransfer
     */
    'funding_type'?: FundingType;
    /**
     * To store various payment-related information
     * @type {string}
     * memberof PaymentTransfer
     */
    'messsage'?: string | null;
    /**
     * 
     * @type {PaymentProcessingDetails}
     * memberof PaymentTransfer
     */
    'payment_processing_details'?: PaymentProcessingDetails;
    /**
     * Payment transfer id
     * @type {string}
     * memberof PaymentTransfer
     */
    'transfer_id'?: string | null;
    /**
     * <p>Payment Cycle identifier.</p>
     * @type {string}
     * memberof PaymentTransfer
     */
    'payment_cycle_id'?: string | null;
    /**
     * 
     * @type {PaymentSource}
     * memberof PaymentTransfer
     */
    'payment_source'?: PaymentSource;
    /**
     * <p>Invoice External ID for Payment Cycle Invoice Funding Source </p>
     * @type {string}
     * memberof PaymentTransfer
     */
    'invoice_id'?: string | null;
    /**
     * 
     * @type {Amount}
     * memberof PaymentTransfer
     */
    'total_fees'?: Amount;
    /**
     * 
     * @type {PaymentRecordDirection}
     * memberof PaymentTransfer
     */
    'payment_direction'?: PaymentRecordDirection;
    /**
     * Wallet id
     * @type {string}
     * memberof PaymentTransfer
     */
    'wallet_key'?: string | null;
    /**
     * Payment payout id
     * @type {string}
     * memberof PaymentTransfer
     */
    'payout_id'?: string | null;
    /**
     * 
     * @type {LedgerType}
     * memberof PaymentTransfer
     */
    'ledger_type'?: LedgerType;
    /**
     * 
     * @type {string}
     * memberof PaymentTransfer
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentTransfer
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentTransfer
     */
    'created_at'?: string;
}


/**
 * 
 * export
 * @interface PaymentTransferCreateDeets
 */
export interface PaymentTransferCreateDeets {
    /**
     * 
     * @type {Amount}
     * memberof PaymentTransferCreateDeets
     */
    'amount'?: Amount;
    /**
     * Wwallet Key e.g \"stripe-us\"
     * @type {string}
     * memberof PaymentTransferCreateDeets
     */
    'wallet_key'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentTransferCreateDeets
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentTransferCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PaymentTransferListResponse
 */
export interface PaymentTransferListResponse {
    /**
     * 
     * @type {Array<PaymentTransfer>}
     * memberof PaymentTransferListResponse
     */
    'data'?: Array<PaymentTransfer> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof PaymentTransferListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof PaymentTransferListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof PaymentTransferListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface PaymentTransferReadDeets
 */
export interface PaymentTransferReadDeets {
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof PaymentTransferReadDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PaymentTransferReadDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PayoutBankAccountDeets
 */
export interface PayoutBankAccountDeets {
    /**
     * 
     * @type {string}
     * memberof PayoutBankAccountDeets
     */
    'account_holder_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutBankAccountDeets
     */
    'account_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutBankAccountDeets
     */
    'aba_routing_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutBankAccountDeets
     */
    'swift_code'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutBankAccountDeets
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutBankAccountDeets
     */
    'country'?: string | null;
}
/**
 * 
 * export
 * @interface PayoutMethod
 */
export interface PayoutMethod {
    /**
     * 
     * @type {string}
     * memberof PayoutMethod
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutMethod
     */
    'payout_method_type'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof PayoutMethod
     */
    'default_for_currency'?: boolean;
    /**
     * 
     * @type {string}
     * memberof PayoutMethod
     */
    'last_four'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutMethod
     */
    'brand'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutMethod
     */
    'account_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutMethod
     */
    'routing_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutMethod
     */
    'cvv'?: string | null;
    /**
     * 
     * @type {Expiration}
     * memberof PayoutMethod
     */
    'exp'?: Expiration;
    /**
     * When Type = Bank, Name of the bank associated with the routing number
     * @type {string}
     * memberof PayoutMethod
     */
    'account_bank_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutMethod
     */
    'account_holder_name'?: string | null;
}
/**
 * 
 * export
 * @interface PayoutMethodCreateDeets
 */
export interface PayoutMethodCreateDeets {
    /**
     * 
     * @type {PayoutBankAccountDeets}
     * memberof PayoutMethodCreateDeets
     */
    'bank_account'?: PayoutBankAccountDeets;
    /**
     * 
     * @type {TokenizedAccountDeets}
     * memberof PayoutMethodCreateDeets
     */
    'tokenized_account'?: TokenizedAccountDeets;
    /**
     * 
     * @type {boolean}
     * memberof PayoutMethodCreateDeets
     */
    'default_for_currency'?: boolean;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof PayoutMethodCreateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutMethodCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface PayoutMethodDefaultUpdateDeets
 */
export interface PayoutMethodDefaultUpdateDeets {
    /**
     * 
     * @type {string}
     * memberof PayoutMethodDefaultUpdateDeets
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PayoutMethodDefaultUpdateDeets
     */
    'object'?: string | null;
}
/**
 *   automated (AUTOMATED)  offPlatform (OFF_PLATFORM)
 * export
 * @enum {string}
 */

export const PayoutStrategy = {
    /**
    * AUTOMATED
    */
    Automated: 'automated',
    /**
    * OFF_PLATFORM
    */
    OffPlatform: 'offPlatform'
} as const;

export type PayoutStrategy = typeof PayoutStrategy[keyof typeof PayoutStrategy];


/**
 * 
 * export
 * @interface PayoutTerm
 */
export interface PayoutTerm {
    /**
     * 
     * @type {PayoutStrategy}
     * memberof PayoutTerm
     */
    'strategy'?: PayoutStrategy;
}


/**
 * 
 * export
 * @interface Person
 */
export interface Person {
    /**
     * Id of the persona
     * @type {string}
     * memberof Person
     */
    'id'?: string | null;
    /**
     * First name of the person
     * @type {string}
     * memberof Person
     */
    'first_name'?: string | null;
    /**
     * Last name of the person
     * @type {string}
     * memberof Person
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof Person
     */
    'address'?: AddressDeets;
    /**
     * The birthdate of the person
     * @type {string}
     * memberof Person
     */
    'dob'?: string | null;
    /**
     * Phone number of the person
     * @type {string}
     * memberof Person
     */
    'phone'?: string | null;
    /**
     * Email address of the person
     * @type {string}
     * memberof Person
     */
    'email'?: string | null;
    /**
     * Federal Tax Identifier / SSN of the person
     * @type {string}
     * memberof Person
     */
    'federal_tax_id'?: string | null;
    /**
     * Job title of person
     * @type {string}
     * memberof Person
     */
    'job_title'?: string | null;
    /**
     * Remote Person Id: i.e from Stripe
     * @type {string}
     * memberof Person
     */
    'remote_person_id'?: string | null;
    /**
     * 
     * @type {RelationshipOptionsPerson}
     * memberof Person
     */
    'relationship_options'?: RelationshipOptionsPerson;
    /**
     * Verification status of person
     * @type {string}
     * memberof Person
     */
    'verification_status'?: string | null;
}
/**
 * 
 * export
 * @interface PersonaPendingPaymentsResponse
 */
export interface PersonaPendingPaymentsResponse {
    /**
     * persona id
     * @type {string}
     * memberof PersonaPendingPaymentsResponse
     */
    'persona_id'?: string | null;
    /**
     * Name of persona
     * @type {string}
     * memberof PersonaPendingPaymentsResponse
     */
    'known_name'?: string | null;
    /**
     * email address of persona
     * @type {string}
     * memberof PersonaPendingPaymentsResponse
     */
    'email'?: string | null;
    /**
     * Pending amount.
     * @type {number}
     * memberof PersonaPendingPaymentsResponse
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * memberof PersonaPendingPaymentsResponse
     */
    'formatted_amount'?: string | null;
    /**
     * sender account id
     * @type {string}
     * memberof PersonaPendingPaymentsResponse
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PersonaPendingPaymentsResponse
     */
    'avatar_url'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PersonaPendingPaymentsResponse
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PersonaPendingPaymentsResponse
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PersonaPendingPaymentsResponse
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface PersonaPendingPaymentsResponseListResponse
 */
export interface PersonaPendingPaymentsResponseListResponse {
    /**
     * 
     * @type {Array<PersonaPendingPaymentsResponse>}
     * memberof PersonaPendingPaymentsResponseListResponse
     */
    'data'?: Array<PersonaPendingPaymentsResponse> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof PersonaPendingPaymentsResponseListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof PersonaPendingPaymentsResponseListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof PersonaPendingPaymentsResponseListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface PersonaSetting
 */
export interface PersonaSetting {
    /**
     * 
     * @type {string}
     * memberof PersonaSetting
     */
    'PersonaId'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof PersonaSetting
     */
    'NotificationsEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof PersonaSetting
     */
    'WebNotificationsEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof PersonaSetting
     */
    'SMSNotificationsEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof PersonaSetting
     */
    'EmailNotificationsEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof PersonaSetting
     */
    'MobileAppNotificationsEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * memberof PersonaSetting
     */
    'LanguageCulture'?: string | null;
}
/**
 * 
 * export
 * @interface PersonalAccessToken
 */
export interface PersonalAccessToken {
    /**
     * 
     * @type {number}
     * memberof PersonalAccessToken
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * memberof PersonalAccessToken
     */
    'Token'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PersonalAccessToken
     */
    'CreatedDateTimeUtc'?: string;
    /**
     * 
     * @type {string}
     * memberof PersonalAccessToken
     */
    'ExpirationDateTimeUtc'?: string;
}
/**
 * 
 * export
 * @interface Phone
 */
export interface Phone {
    /**
     * 
     * @type {string}
     * memberof Phone
     */
    'number'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof Phone
     */
    'is_mobile'?: boolean;
    /**
     * 
     * @type {string}
     * memberof Phone
     */
    'country_code'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Phone
     */
    'label'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof Phone
     */
    'is_primary'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof Phone
     */
    'is_validated'?: boolean;
    /**
     * 
     * @type {string}
     * memberof Phone
     */
    'digital_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Phone
     */
    'decorated_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Phone
     */
    'full_number'?: string | null;
}
/**
 * 
 * export
 * @interface PhoneDeets
 */
export interface PhoneDeets {
    /**
     * 
     * @type {string}
     * memberof PhoneDeets
     */
    'number'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof PhoneDeets
     */
    'is_mobile'?: boolean;
    /**
     * 
     * @type {string}
     * memberof PhoneDeets
     */
    'country_code'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PhoneDeets
     */
    'label'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof PhoneDeets
     */
    'is_primary'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof PhoneDeets
     */
    'is_validated'?: boolean;
    /**
     * 
     * @type {string}
     * memberof PhoneDeets
     */
    'digital_number': string;
    /**
     * 
     * @type {string}
     * memberof PhoneDeets
     */
    'decorated_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PhoneDeets
     */
    'full_number'?: string | null;
}
/**
 * 
 * export
 * @interface PortfolioCatalog
 */
export interface PortfolioCatalog {
    /**
     * The idea from the source third party
     * @type {string}
     * memberof PortfolioCatalog
     */
    'external_id'?: string | null;
    /**
     * The Title
     * @type {string}
     * memberof PortfolioCatalog
     */
    'title': string;
    /**
     * The decription
     * @type {string}
     * memberof PortfolioCatalog
     */
    'description'?: string | null;
    /**
     * A keyed list of other details related to the catalog  such as additional product details
     * @type {{ [key: string]: string | null; }}
     * memberof PortfolioCatalog
     */
    'details'?: { [key: string]: string | null; } | null;
    /**
     * The external href (optional)
     * @type {string}
     * memberof PortfolioCatalog
     */
    'href'?: string | null;
    /**
     * The type of catalog, such as album, video channel, shopping category, etc.
     * @type {string}
     * memberof PortfolioCatalog
     */
    'type'?: string | null;
    /**
     * The sub type of catalog
     * @type {string}
     * memberof PortfolioCatalog
     */
    'sub_type'?: string | null;
    /**
     * True if the catalog content is deemed explicit, otherwise false
     * @type {boolean}
     * memberof PortfolioCatalog
     */
    'explicit'?: boolean;
    /**
     * Minimum age in years if there is an age requirement such as 18+, otherise null or zero
     * @type {number}
     * memberof PortfolioCatalog
     */
    'min_age_years'?: number;
    /**
     * The external url
     * @type {{ [key: string]: string | null; }}
     * memberof PortfolioCatalog
     */
    'external_urls'?: { [key: string]: string | null; } | null;
    /**
     * Collection of external images
     * @type {Array<ExternalImageDeets>}
     * memberof PortfolioCatalog
     */
    'external_images'?: Array<ExternalImageDeets> | null;
    /**
     * Attributions are the credits or roles attaching Contact items   to this PortfolioCatalog
     * @type {Array<AttributionDeets>}
     * memberof PortfolioCatalog
     */
    'attributions'?: Array<AttributionDeets> | null;
    /**
     * Tenant account ID
     * @type {string}
     * memberof PortfolioCatalog
     */
    'account_id'?: string | null;
    /**
     * Updated date time
     * @type {string}
     * memberof PortfolioCatalog
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * memberof PortfolioCatalog
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PortfolioCatalog
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PortfolioCatalog
     */
    'created_at'?: string;
}
/**
 * A list of `Portfolio` items
 * export
 * @interface PortfolioCatalogListResponse
 */
export interface PortfolioCatalogListResponse {
    /**
     * 
     * @type {Array<PortfolioCatalog>}
     * memberof PortfolioCatalogListResponse
     */
    'data'?: Array<PortfolioCatalog> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof PortfolioCatalogListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof PortfolioCatalogListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof PortfolioCatalogListResponse
     */
    'total_count'?: number;
}
/**
 * Projects are in a tenants portfolio and are often a part of splits
 * export
 * @interface PortfolioItem
 */
export interface PortfolioItem {
    /**
     * The idea from the source third party
     * @type {string}
     * memberof PortfolioItem
     */
    'external_id'?: string | null;
    /**
     * The Title
     * @type {string}
     * memberof PortfolioItem
     */
    'title': string;
    /**
     * 
     * @type {AddressDeets}
     * memberof PortfolioItem
     */
    'Address'?: AddressDeets;
    /**
     * The decription
     * @type {string}
     * memberof PortfolioItem
     */
    'description'?: string | null;
    /**
     * A keyed list of other details related to the item  such as additional product details
     * @type {{ [key: string]: string | null; }}
     * memberof PortfolioItem
     */
    'details'?: { [key: string]: string | null; } | null;
    /**
     * The external href (optional)
     * @type {string}
     * memberof PortfolioItem
     */
    'href'?: string | null;
    /**
     * The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
     * @type {string}
     * memberof PortfolioItem
     */
    'type'?: string | null;
    /**
     * The sub type of item
     * @type {string}
     * memberof PortfolioItem
     */
    'sub_type'?: string | null;
    /**
     * True if the content is deemd explicity, otherwise false
     * @type {boolean}
     * memberof PortfolioItem
     */
    'explicit'?: boolean;
    /**
     * Duration in ms
     * @type {number}
     * memberof PortfolioItem
     */
    'duration_milliseconds'?: number;
    /**
     * Minimum age in years if there is an age requirement such as 18+, otherise null or zero
     * @type {number}
     * memberof PortfolioItem
     */
    'min_age_years'?: number;
    /**
     * The external url
     * @type {{ [key: string]: string | null; }}
     * memberof PortfolioItem
     */
    'external_urls'?: { [key: string]: string | null; } | null;
    /**
     * Collection of external images
     * @type {Array<ExternalImageDeets>}
     * memberof PortfolioItem
     */
    'external_images'?: Array<ExternalImageDeets> | null;
    /**
     * Attributions are the credits or roles attaching Contact items   to this PortfolioItem
     * @type {Array<AttributionDeets>}
     * memberof PortfolioItem
     */
    'attributions'?: Array<AttributionDeets> | null;
    /**
     * Tenant account ID
     * @type {string}
     * memberof PortfolioItem
     */
    'account_id'?: string | null;
    /**
     * Updated date time
     * @type {string}
     * memberof PortfolioItem
     */
    'updated_at'?: string | null;
    /**
     * Connector id
     * @type {string}
     * memberof PortfolioItem
     */
    'connector_id'?: string | null;
    /**
     * can be Channel id, playlist id, collection id etc
     * @type {string}
     * memberof PortfolioItem
     */
    'connector_sub_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PortfolioItem
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PortfolioItem
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof PortfolioItem
     */
    'created_at'?: string;
}
/**
 * A list of `Portfolio` items
 * export
 * @interface PortfolioItemListResponse
 */
export interface PortfolioItemListResponse {
    /**
     * 
     * @type {Array<PortfolioItem>}
     * memberof PortfolioItemListResponse
     */
    'data'?: Array<PortfolioItem> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof PortfolioItemListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof PortfolioItemListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof PortfolioItemListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    /**
     * 
     * @type {string}
     * memberof ProblemDetails
     */
    'Type'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ProblemDetails
     */
    'Title'?: string | null;
    /**
     * 
     * @type {number}
     * memberof ProblemDetails
     */
    'Status'?: number | null;
    /**
     * 
     * @type {string}
     * memberof ProblemDetails
     */
    'Detail'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ProblemDetails
     */
    'Instance'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * memberof ProblemDetails
     */
    'Extensions'?: { [key: string]: any; } | null;
}
/**
 * 
 * export
 * @interface ProviderAccount
 */
export interface ProviderAccount {
    /**
     * 
     * @type {ProviderAccountType}
     * memberof ProviderAccount
     */
    'provider_account_type'?: ProviderAccountType;
    /**
     * 
     * @type {string}
     * memberof ProviderAccount
     */
    'provider_account_id'?: string | null;
}


/**
 *   usa-usd-1  usa-multi-1  usa-usd-2  gbr-gbp-1  usa-btc-1
 * export
 * @enum {string}
 */

export const ProviderAccountType = {
    /**
    * 
    */
    Stripe: 'usa-usd-1',
    /**
    * 
    */
    Tipalti: 'usa-multi-1',
    /**
    * 
    */
    Dwolla: 'usa-usd-2',
    /**
    * 
    */
    StripeUK: 'gbr-gbp-1',
    /**
    * 
    */
    BitcoinLightning: 'usa-btc-1'
} as const;

export type ProviderAccountType = typeof ProviderAccountType[keyof typeof ProviderAccountType];


/**
 * Request model for purging messages from the dead-letter queue.
 * export
 * @interface PurgeRequestModel
 */
export interface PurgeRequestModel {
    /**
     * Number of days ago from which to start purging messages. Defaults to 7 days.
     * @type {number}
     * memberof PurgeRequestModel
     */
    'DaysAgo'?: number;
}
/**
 * 
 * export
 * @interface ReceivingAccountInfo
 */
export interface ReceivingAccountInfo {
    /**
     * 
     * @type {string}
     * memberof ReceivingAccountInfo
     */
    'account_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ReceivingAccountInfo
     */
    'routing_number'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ReceivingAccountInfo
     */
    'swift_code'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ReceivingAccountInfo
     */
    'bank_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ReceivingAccountInfo
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ReceivingAccountInfo
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ReceivingAccountInfo
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ReceivingAccountInfo
     */
    'reference'?: string | null;
    /**
     * 
     * @type {string}
     * memberof ReceivingAccountInfo
     */
    'source_id'?: string | null;
}
/**
 * 
 * export
 * @interface RecoupableTerm
 */
export interface RecoupableTerm extends BaseTerms {
    /**
     * 
     * @type {string}
     * memberof RecoupableTerm
     */
    '$entity'?: string | null;
    /**
     * 
     * @type {number}
     * memberof RecoupableTerm
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * memberof RecoupableTerm
     */
    'balance'?: number;
    /**
     * 
     * @type {TakeMethod}
     * memberof RecoupableTerm
     */
    'take_method'?: TakeMethod;
    /**
     * 
     * @type {number}
     * memberof RecoupableTerm
     */
    'maximum_take'?: number;
    /**
     * 
     * @type {AccountUserPersona}
     * memberof RecoupableTerm
     */
    'from'?: AccountUserPersona;
    /**
     * 
     * @type {AccountUserPersona}
     * memberof RecoupableTerm
     */
    'to'?: AccountUserPersona;
}
/**
 * 
 * export
 * @interface RelationshipOptionsPerson
 */
export interface RelationshipOptionsPerson {
    /**
     * Is this person owner
     * @type {boolean}
     * memberof RelationshipOptionsPerson
     */
    'is_owner'?: boolean | null;
    /**
     * Is this person director
     * @type {boolean}
     * memberof RelationshipOptionsPerson
     */
    'is_director'?: boolean | null;
    /**
     * Is this person executive
     * @type {boolean}
     * memberof RelationshipOptionsPerson
     */
    'is_executive'?: boolean | null;
    /**
     * Is this person representative
     * @type {boolean}
     * memberof RelationshipOptionsPerson
     */
    'is_representative'?: boolean | null;
    /**
     * person ownership percentage
     * @type {number}
     * memberof RelationshipOptionsPerson
     */
    'percent_ownership'?: number | null;
}
/**
 * Request model for replaying messages from the dead-letter queue.
 * export
 * @interface ReplayRequestModel
 */
export interface ReplayRequestModel {
    /**
     * Optional start time to replay messages.
     * @type {string}
     * memberof ReplayRequestModel
     */
    'StartTime'?: string | null;
    /**
     * Optional end time to replay messages.
     * @type {string}
     * memberof ReplayRequestModel
     */
    'EndTime'?: string | null;
    /**
     * Optional list of message IDs to replay specific messages.
     * @type {Array<string>}
     * memberof ReplayRequestModel
     */
    'MessageIds'?: Array<string> | null;
}
/**
 * The SimpleContract is a simplified version of the advanced Contract
 * export
 * @interface SimpleContract
 */
export interface SimpleContract {
    /**
     * 
     * @type {string}
     * memberof SimpleContract
     */
    'partition_key'?: string | null;
    /**
     * One ore more Income terms which help provide scope  on how funds flow through the `Contract`
     * @type {Array<Income>}
     * memberof SimpleContract
     */
    'incomes'?: Array<Income> | null;
    /**
     * Unique Id and primary key of this Contract
     * @type {string}
     * memberof SimpleContract
     */
    'id'?: string | null;
    /**
     * Shared id of the contract for when multiple revisions may exist
     * @type {string}
     * memberof SimpleContract
     */
    'contract_id'?: string | null;
    /**
     * Display title
     * @type {string}
     * memberof SimpleContract
     */
    'title'?: string | null;
    /**
     * Description
     * @type {string}
     * memberof SimpleContract
     */
    'description'?: string | null;
    /**
     * 
     * @type {ContractHeader}
     * memberof SimpleContract
     */
    'header'?: ContractHeader;
    /**
     * 
     * @type {TieredSplitTieredGroupTerm}
     * memberof SimpleContract
     */
    'split_tiers'?: TieredSplitTieredGroupTerm;
    /**
     * Recoupables
     * @type {Array<RecoupableTerm>}
     * memberof SimpleContract
     */
    'recoupables'?: Array<RecoupableTerm> | null;
    /**
     * Tags to help set and identify the type of SimpleContract
     * @type {Array<string>}
     * memberof SimpleContract
     */
    'tags'?: Array<string> | null;
    /**
     * A list of collaborators who are not recieving splits but are a part of the Contract
     * @type {Array<AccountUserPersona>}
     * memberof SimpleContract
     */
    'other_collaborators'?: Array<AccountUserPersona> | null;
    /**
     * 
     * @type {boolean}
     * memberof SimpleContract
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * memberof SimpleContract
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof SimpleContract
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface SimpleContractCreateDeets
 */
export interface SimpleContractCreateDeets {
    /**
     * 
     * @type {SimpleContract}
     * memberof SimpleContractCreateDeets
     */
    'simple_contract'?: SimpleContract;
    /**
     * Base64 encoded byte array (PNG format) to upload as an avatar during SimpleContract creation.
     * @type {string}
     * memberof SimpleContractCreateDeets
     */
    'avatar_bytes'?: string | null;
    /**
     * 
     * @type {string}
     * memberof SimpleContractCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface SimpleContractListResponse
 */
export interface SimpleContractListResponse {
    /**
     * 
     * @type {Array<SimpleContract>}
     * memberof SimpleContractListResponse
     */
    'data'?: Array<SimpleContract> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof SimpleContractListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof SimpleContractListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof SimpleContractListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface SimpleContractUpdateDeets
 */
export interface SimpleContractUpdateDeets {
    /**
     * 
     * @type {SimpleContract}
     * memberof SimpleContractUpdateDeets
     */
    'simple_contract'?: SimpleContract;
    /**
     * Base64 encoded byte array (PNG format) to upload as an avatar during SimpleContract creation.
     * @type {string}
     * memberof SimpleContractUpdateDeets
     */
    'avatar_bytes'?: string | null;
    /**
     * 
     * @type {string}
     * memberof SimpleContractUpdateDeets
     */
    'object'?: string | null;
}
/**
 *   asRate (TAKE_RATE)  asFlatFee (TAKE_FEE)
 * export
 * @enum {string}
 */

export const TakeMethod = {
    /**
    * TAKE_RATE
    */
    AsRate: 'asRate',
    /**
    * TAKE_FEE
    */
    AsFlatFee: 'asFlatFee'
} as const;

export type TakeMethod = typeof TakeMethod[keyof typeof TakeMethod];


/**
 * 
 * export
 * @interface TaskList
 */
export interface TaskList {
    /**
     * 
     * @type {number}
     * memberof TaskList
     */
    'total_tasks'?: number;
    /**
     * 
     * @type {number}
     * memberof TaskList
     */
    'completed_tasks'?: number;
    /**
     * 
     * @type {string}
     * memberof TaskList
     */
    'title'?: string | null;
    /**
     * 
     * @type {Array<OnBoardingTask>}
     * memberof TaskList
     */
    'tasks'?: Array<OnBoardingTask> | null;
}
/**
 * 
 * export
 * @interface TaskUpdateStatusDeets
 */
export interface TaskUpdateStatusDeets {
    /**
     * 
     * @type {string}
     * memberof TaskUpdateStatusDeets
     */
    'id'?: string | null;
    /**
     * 
     * @type {OnBoardingTaskStatus}
     * memberof TaskUpdateStatusDeets
     */
    'status'?: OnBoardingTaskStatus;
    /**
     * 
     * @type {string}
     * memberof TaskUpdateStatusDeets
     */
    'object'?: string | null;
}


/**
 * 
 * export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * Tenant User ID
     * @type {string}
     * memberof Tenant
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Tenant
     */
    'account_id'?: string | null;
    /**
     * True if the account was created
     * @type {boolean}
     * memberof Tenant
     */
    'is_new'?: boolean;
    /**
     * 
     * @type {TenantStatus}
     * memberof Tenant
     */
    'status'?: TenantStatus;
    /**
     * 
     * @type {UserStatusVerification}
     * memberof Tenant
     */
    'verification'?: UserStatusVerification;
    /**
     * 
     * @type {TenantCapabilities}
     * memberof Tenant
     */
    'capabilities'?: TenantCapabilities;
    /**
     * 
     * @type {string}
     * memberof Tenant
     */
    'email_address'?: string | null;
    /**
     * First name of the account holder
     * @type {string}
     * memberof Tenant
     */
    'first_name'?: string | null;
    /**
     * Last name of the account holder
     * @type {string}
     * memberof Tenant
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof Tenant
     */
    'address'?: AddressDeets;
    /**
     * The birthdate of the account holder
     * @type {string}
     * memberof Tenant
     */
    'dob'?: string | null;
    /**
     * Phone number of the account holder
     * @type {string}
     * memberof Tenant
     */
    'phone'?: string | null;
    /**
     * Federal Tax Identifier / SSN of the account holder
     * @type {string}
     * memberof Tenant
     */
    'federal_tax_id'?: string | null;
    /**
     * Business Name
     * @type {string}
     * memberof Tenant
     */
    'business_name'?: string | null;
    /**
     * 
     * @type {EntityType}
     * memberof Tenant
     */
    'entity_type'?: EntityType;
    /**
     * Country code
     * @type {string}
     * memberof Tenant
     */
    'country_code'?: string | null;
    /**
     * 
     * @type {IUserBusinessDeets}
     * memberof Tenant
     */
    'business_details'?: IUserBusinessDeets;
    /**
     * 
     * @type {IUserIndividualDeets}
     * memberof Tenant
     */
    'individual_details'?: IUserIndividualDeets;
    /**
     * Returns the external accounts that the tenant is linked to.
     * @type {Array<ProviderAccount>}
     * memberof Tenant
     */
    'provider_accounts'?: Array<ProviderAccount> | null;
}


/**
 * 
 * export
 * @interface TenantCapabilities
 */
export interface TenantCapabilities {
    /**
     * 
     * @type {boolean}
     * memberof TenantCapabilities
     */
    'PaymentsEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof TenantCapabilities
     */
    'PayoutsEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * memberof TenantCapabilities
     */
    'AccountCapabilities'?: string | null;
}
/**
 * 
 * export
 * @interface TenantCreateDeets
 */
export interface TenantCreateDeets {
    /**
     * First name of the account holder
     * @type {string}
     * memberof TenantCreateDeets
     */
    'first_name'?: string | null;
    /**
     * Last name of the account holder
     * @type {string}
     * memberof TenantCreateDeets
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TenantCreateDeets
     */
    'email_address'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof TenantCreateDeets
     */
    'address'?: AddressDeets;
    /**
     * The birthdate of the account holder
     * @type {string}
     * memberof TenantCreateDeets
     */
    'dob'?: string;
    /**
     * Phone number of the account holder
     * @type {string}
     * memberof TenantCreateDeets
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TenantCreateDeets
     */
    'invite_token'?: string | null;
    /**
     * Federal Tax Identifier
     * @type {string}
     * memberof TenantCreateDeets
     */
    'federal_tax_id'?: string | null;
    /**
     * Business Name
     * @type {string}
     * memberof TenantCreateDeets
     */
    'business_name'?: string | null;
    /**
     * 
     * @type {EntityType}
     * memberof TenantCreateDeets
     */
    'entity_type'?: EntityType;
    /**
     * 
     * @type {IUserBusinessDeets}
     * memberof TenantCreateDeets
     */
    'business_details'?: IUserBusinessDeets;
    /**
     * 
     * @type {IUserIndividualDeets}
     * memberof TenantCreateDeets
     */
    'individual_details'?: IUserIndividualDeets;
    /**
     * 
     * @type {string}
     * memberof TenantCreateDeets
     */
    'object'?: string | null;
}


/**
 *   onboarded  invited  pending
 * export
 * @enum {string}
 */

export const TenantStatus = {
    /**
    * 
    */
    Onboarded: 'onboarded',
    /**
    * 
    */
    Invited: 'invited',
    /**
    * 
    */
    Pending: 'pending'
} as const;

export type TenantStatus = typeof TenantStatus[keyof typeof TenantStatus];


/**
 * 
 * export
 * @interface TenantUpdateVerificationDeets
 */
export interface TenantUpdateVerificationDeets {
    /**
     * 
     * @type {UserUpdateIndividualDeets}
     * memberof TenantUpdateVerificationDeets
     */
    'individual_details'?: UserUpdateIndividualDeets;
    /**
     * 
     * @type {UserUpdateBusinessDeets}
     * memberof TenantUpdateVerificationDeets
     */
    'business_details'?: UserUpdateBusinessDeets;
    /**
     * 
     * @type {string}
     * memberof TenantUpdateVerificationDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface TermBalance
 */
export interface TermBalance {
    /**
     * 
     * @type {number}
     * memberof TermBalance
     */
    'item_gross'?: number;
    /**
     * 
     * @type {number}
     * memberof TermBalance
     */
    'line_item_gross'?: number;
    /**
     * 
     * @type {number}
     * memberof TermBalance
     */
    'in'?: number;
    /**
     * 
     * @type {number}
     * memberof TermBalance
     */
    'left'?: number;
    /**
     * 
     * @type {number}
     * memberof TermBalance
     */
    'take'?: number;
}
/**
 * 
 * export
 * @interface TermHeader
 */
export interface TermHeader {
    /**
     * 
     * @type {TermOperationTargets}
     * memberof TermHeader
     */
    'operates_on'?: TermOperationTargets;
    /**
     * 
     * @type {boolean}
     * memberof TermHeader
     */
    'accumulates'?: boolean;
    /**
     * 
     * @type {string}
     * memberof TermHeader
     */
    'chart_of_accountI_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TermHeader
     */
    'system_description'?: string | null;
    /**
     * 
     * @type {number}
     * memberof TermHeader
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * memberof TermHeader
     */
    'guid'?: string | null;
    /**
     * 
     * @type {boolean}
     * memberof TermHeader
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * memberof TermHeader
     */
    'updated_at'?: string;
    /**
     * 
     * @type {AccountUserPersona}
     * memberof TermHeader
     */
    'initiated_by'?: AccountUserPersona;
    /**
     * 
     * @type {string}
     * memberof TermHeader
     */
    'partner_account_id'?: string | null;
    /**
     * 
     * @type {number}
     * memberof TermHeader
     */
    'priority'?: number;
    /**
     * 
     * @type {boolean}
     * memberof TermHeader
     */
    'accrues'?: boolean;
    /**
     * 
     * @type {string}
     * memberof TermHeader
     */
    'system_version'?: string | null;
}


/**
 *   gross (Resx.TermOperationTargets.Gross)  net (Resx.TermOperationTargets.Net)  income (Resx.TermOperationTargets.Income)  parent (Resx.TermOperationTargets.Parent)
 * export
 * @enum {string}
 */

export const TermOperationTargets = {
    /**
    * Resx.TermOperationTargets.Gross
    */
    Gross: 'gross',
    /**
    * Resx.TermOperationTargets.Net
    */
    Net: 'net',
    /**
    * Resx.TermOperationTargets.Income
    */
    Income: 'income',
    /**
    * Resx.TermOperationTargets.Parent
    */
    Parent: 'parent'
} as const;

export type TermOperationTargets = typeof TermOperationTargets[keyof typeof TermOperationTargets];


/**
 * 
 * export
 * @interface TermScope
 */
export interface TermScope {
    /**
     * If false then StartDate and EndDate are ignored for  calculator scopes
     * @type {boolean}
     * memberof TermScope
     */
    'is_date_limited'?: boolean;
    /**
     * If IsDateLimited=True, specifies the starting date from which to this term applies
     * @type {string}
     * memberof TermScope
     */
    'start_at'?: string;
    /**
     * If IsDateLimited=True, specifies the ending date to which to this term applies, can be null if no end date
     * @type {string}
     * memberof TermScope
     */
    'end_at'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * memberof TermScope
     */
    'territories'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * memberof TermScope
     */
    'royalty_types'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * memberof TermScope
     */
    'catalog_id'?: number;
    /**
     * 
     * @type {Array<string>}
     * memberof TermScope
     */
    'item_ids'?: Array<string> | null;
}
/**
 * 
 * export
 * @interface TieredSplit
 */
export interface TieredSplit {
    /**
     * 
     * @type {string}
     * memberof TieredSplit
     */
    '$entity'?: string | null;
    /**
     * 
     * @type {Array<FlatRateTerm>}
     * memberof TieredSplit
     */
    'child_terms'?: Array<FlatRateTerm> | null;
    /**
     * 
     * @type {number}
     * memberof TieredSplit
     */
    'ceiling'?: number;
    /**
     * 
     * @type {string}
     * memberof TieredSplit
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TieredSplit
     */
    'description'?: string | null;
    /**
     * 
     * @type {TermHeader}
     * memberof TieredSplit
     */
    'header'?: TermHeader;
    /**
     * 
     * @type {TermScope}
     * memberof TieredSplit
     */
    'scope'?: TermScope;
    /**
     * 
     * @type {PayoutTerm}
     * memberof TieredSplit
     */
    'payout'?: PayoutTerm;
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * memberof TieredSplit
     */
    'meta_data'?: { [key: string]: string | null; } | null;
    /**
     * 
     * @type {Array<BaseTermsDescendentsInner>}
     * memberof TieredSplit
     */
    'descendents'?: Array<BaseTermsDescendentsInner> | null;
    /**
     * 
     * @type {TermBalance}
     * memberof TieredSplit
     */
    'previous_balance'?: TermBalance;
}
/**
 * 
 * export
 * @interface TieredSplitTieredGroupTerm
 */
export interface TieredSplitTieredGroupTerm {
    /**
     * 
     * @type {string}
     * memberof TieredSplitTieredGroupTerm
     */
    '$entity'?: string | null;
    /**
     * 
     * @type {number}
     * memberof TieredSplitTieredGroupTerm
     */
    'ceiling'?: number;
    /**
     * 
     * @type {Array<TieredSplit>}
     * memberof TieredSplitTieredGroupTerm
     */
    'tiers'?: Array<TieredSplit> | null;
    /**
     * 
     * @type {string}
     * memberof TieredSplitTieredGroupTerm
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TieredSplitTieredGroupTerm
     */
    'description'?: string | null;
    /**
     * 
     * @type {TermHeader}
     * memberof TieredSplitTieredGroupTerm
     */
    'header'?: TermHeader;
    /**
     * 
     * @type {TermScope}
     * memberof TieredSplitTieredGroupTerm
     */
    'scope'?: TermScope;
    /**
     * 
     * @type {PayoutTerm}
     * memberof TieredSplitTieredGroupTerm
     */
    'payout'?: PayoutTerm;
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * memberof TieredSplitTieredGroupTerm
     */
    'meta_data'?: { [key: string]: string | null; } | null;
    /**
     * 
     * @type {Array<BaseTermsDescendentsInner>}
     * memberof TieredSplitTieredGroupTerm
     */
    'descendents'?: Array<BaseTermsDescendentsInner> | null;
    /**
     * 
     * @type {TermBalance}
     * memberof TieredSplitTieredGroupTerm
     */
    'previous_balance'?: TermBalance;
}
/**
 * 
 * export
 * @interface TieredTerm
 */
export interface TieredTerm extends BaseTerms {
    /**
     * 
     * @type {string}
     * memberof TieredTerm
     */
    '$entity'?: string | null;
    /**
     * 
     * @type {Array<BaseTerms | Income | FlatRateTerm | FlatAmountTerm | RecoupableTerm | TieredTermTieredGroupTerm | TieredTerm>}
     * memberof TieredTerm
     */
    'child_terms'?: Array<BaseTerms | Income | FlatRateTerm | FlatAmountTerm | RecoupableTerm | TieredTermTieredGroupTerm | TieredTerm> | null;
    /**
     * 
     * @type {number}
     * memberof TieredTerm
     */
    'ceiling'?: number;
}
/**
 * 
 * export
 * @interface TieredTermTieredGroupTerm
 */
export interface TieredTermTieredGroupTerm extends BaseTerms {
    /**
     * 
     * @type {string}
     * memberof TieredTermTieredGroupTerm
     */
    '$entity'?: string | null;
    /**
     * 
     * @type {number}
     * memberof TieredTermTieredGroupTerm
     */
    'ceiling'?: number;
    /**
     * 
     * @type {Array<TieredTerm>}
     * memberof TieredTermTieredGroupTerm
     */
    'tiers'?: Array<TieredTerm> | null;
}
/**
 * 
 * export
 * @interface TipLink
 */
export interface TipLink {
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'image_url'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'after_payment_message'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'contract_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'wallet_key'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'product_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'price_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'orchestration_id'?: string | null;
    /**
     * 
     * @type {Array<TipLinkSplitContact>}
     * memberof TipLink
     */
    'splits'?: Array<TipLinkSplitContact> | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLink
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface TipLinkCreateDeets
 */
export interface TipLinkCreateDeets {
    /**
     * Name this tip link. This should indicate something about the purpose. This is displayed on the payment page.
     * @type {string}
     * memberof TipLinkCreateDeets
     */
    'name': string;
    /**
     * Description this tip link. This should indicate description about the purpose. This is displayed on the payment page.
     * @type {string}
     * memberof TipLinkCreateDeets
     */
    'description': string;
    /**
     * ImageUrl this tip link.
     * @type {string}
     * memberof TipLinkCreateDeets
     */
    'image_url'?: string | null;
    /**
     * AfterPaymentMessage this tip link. This will show when payment complete.
     * @type {string}
     * memberof TipLinkCreateDeets
     */
    'after_payment_message': string;
    /**
     * A contract for the Tip Link. This is useful for more complex scenarios than simple flat splits.
     * @type {string}
     * memberof TipLinkCreateDeets
     */
    'contract_id'?: string | null;
    /**
     * These define simple splits between contacts. When a Tip Link is used, and funds clear, the money will automatically flow to these contacts as though it was coming from the user that owns the tip link.
     * @type {Array<TipLinkSplitContact>}
     * memberof TipLinkCreateDeets
     */
    'splits': Array<TipLinkSplitContact>;
    /**
     * 
     * @type {string}
     * memberof TipLinkCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface TipLinkListResponse
 */
export interface TipLinkListResponse {
    /**
     * 
     * @type {Array<TipLink>}
     * memberof TipLinkListResponse
     */
    'data'?: Array<TipLink> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof TipLinkListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof TipLinkListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof TipLinkListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface TipLinkSplitContact
 */
export interface TipLinkSplitContact {
    /**
     * 
     * @type {number}
     * memberof TipLinkSplitContact
     */
    'percent'?: number;
    /**
     * 
     * @type {BasicContactDeets}
     * memberof TipLinkSplitContact
     */
    'contact'?: BasicContactDeets;
}
/**
 * 
 * export
 * @interface TipLinkUpdateDeets
 */
export interface TipLinkUpdateDeets {
    /**
     * 
     * @type {string}
     * memberof TipLinkUpdateDeets
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLinkUpdateDeets
     */
    'description'?: string | null;
    /**
     * A contract for the Tip Link. This is useful for more complex scenarios than simple flat splits.
     * @type {string}
     * memberof TipLinkUpdateDeets
     */
    'contract_id'?: string | null;
    /**
     * ImageUrl this tip link.
     * @type {string}
     * memberof TipLinkUpdateDeets
     */
    'image_url'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLinkUpdateDeets
     */
    'after_payment_message'?: string | null;
    /**
     * 
     * @type {Array<TipLinkSplitContact>}
     * memberof TipLinkUpdateDeets
     */
    'splits'?: Array<TipLinkSplitContact> | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof TipLinkUpdateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLinkUpdateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface TipLinksImage
 */
export interface TipLinksImage {
    /**
     * 
     * @type {string}
     * memberof TipLinksImage
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLinksImage
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLinksImage
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLinksImage
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof TipLinksImage
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface TokenizedAccountDeets
 */
export interface TokenizedAccountDeets {
    /**
     * 
     * @type {string}
     * memberof TokenizedAccountDeets
     */
    'token'?: string | null;
}
/**
 * 
 * export
 * @interface UserApplication
 */
export interface UserApplication {
    /**
     * 
     * @type {string}
     * memberof UserApplication
     */
    'client_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserApplication
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserApplication
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserApplication
     */
    'client_secret'?: string | null;
}
/**
 * Create an application for calling the Mozaic API
 * export
 * @interface UserApplicationCreateDeets
 */
export interface UserApplicationCreateDeets {
    /**
     * A description for the application. Max 140 characters.
     * @type {string}
     * memberof UserApplicationCreateDeets
     */
    'description'?: string | null;
    /**
     * A name for the application
     * @type {string}
     * memberof UserApplicationCreateDeets
     */
    'name'?: string | null;
    /**
     * The user id to operate on their behalf (tenants only)
     * @type {string}
     * memberof UserApplicationCreateDeets
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserApplicationCreateDeets
     */
    'object'?: string | null;
}
/**
 * 
 * export
 * @interface UserApplicationListResponse
 */
export interface UserApplicationListResponse {
    /**
     * 
     * @type {Array<UserApplication>}
     * memberof UserApplicationListResponse
     */
    'data'?: Array<UserApplication> | null;
    /**
     * This is the count of records returned
     * @type {number}
     * memberof UserApplicationListResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * memberof UserApplicationListResponse
     */
    'page'?: number | null;
    /**
     * This is the total count of records available, Needed for pagination
     * @type {number}
     * memberof UserApplicationListResponse
     */
    'total_count'?: number;
}
/**
 * 
 * export
 * @interface UserStatus
 */
export interface UserStatus {
    /**
     * 
     * @type {UserStatusOnboarding}
     * memberof UserStatus
     */
    'onboarding'?: UserStatusOnboarding;
    /**
     * 
     * @type {UserStatusPayments}
     * memberof UserStatus
     */
    'payments'?: UserStatusPayments;
    /**
     * 
     * @type {UserStatusPayouts}
     * memberof UserStatus
     */
    'payouts'?: UserStatusPayouts;
    /**
     * 
     * @type {string}
     * memberof UserStatus
     */
    'capabilities'?: string | null;
    /**
     * 
     * @type {UserStatusVerification}
     * memberof UserStatus
     */
    'verification'?: UserStatusVerification;
    /**
     * 
     * @type {string}
     * memberof UserStatus
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserStatus
     */
    'tenant_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserStatus
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserStatus
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserStatus
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface UserStatusOnboarding
 */
export interface UserStatusOnboarding {
    /**
     * 
     * @type {boolean}
     * memberof UserStatusOnboarding
     */
    'is_complete'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof UserStatusOnboarding
     */
    'has_registered'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof UserStatusOnboarding
     */
    'has_onboarded'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof UserStatusOnboarding
     */
    'has_handle'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof UserStatusOnboarding
     */
    'has_profile_image'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof UserStatusOnboarding
     */
    'has_full_profile'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof UserStatusOnboarding
     */
    'has_documented_profile'?: boolean;
    /**
     * 
     * @type {boolean}
     * memberof UserStatusOnboarding
     */
    'has_toured'?: boolean;
    /**
     * 
     * @type {string}
     * memberof UserStatusOnboarding
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserStatusOnboarding
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserStatusOnboarding
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface UserStatusPayments
 */
export interface UserStatusPayments {
    /**
     * 
     * @type {boolean}
     * memberof UserStatusPayments
     */
    'is_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * memberof UserStatusPayments
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserStatusPayments
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserStatusPayments
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface UserStatusPayouts
 */
export interface UserStatusPayouts {
    /**
     * 
     * @type {boolean}
     * memberof UserStatusPayouts
     */
    'is_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * memberof UserStatusPayouts
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserStatusPayouts
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof UserStatusPayouts
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface UserStatusVerification
 */
export interface UserStatusVerification {
    /**
     * 
     * @type {string}
     * memberof UserStatusVerification
     */
    'status'?: string | null;
    /**
     * 
     * @type {UserStatusVerificationRequirements}
     * memberof UserStatusVerification
     */
    'requirements'?: UserStatusVerificationRequirements;
    /**
     * 
     * @type {Array<UserStatusVerificationErrors>}
     * memberof UserStatusVerification
     */
    'errors'?: Array<UserStatusVerificationErrors> | null;
}
/**
 * 
 * export
 * @interface UserStatusVerificationErrors
 */
export interface UserStatusVerificationErrors {
    /**
     * 
     * @type {string}
     * memberof UserStatusVerificationErrors
     */
    'code'?: string | null;
    /**
     * An informative message that indicates the error type and provides additional details  about the error.
     * @type {string}
     * memberof UserStatusVerificationErrors
     */
    'reason'?: string | null;
    /**
     * The specific user onboarding requirement field (in the requirements hash) that needs to  be resolved.
     * @type {string}
     * memberof UserStatusVerificationErrors
     */
    'requirement'?: string | null;
}
/**
 * 
 * export
 * @interface UserStatusVerificationRequirements
 */
export interface UserStatusVerificationRequirements {
    /**
     * 
     * @type {Array<string>}
     * memberof UserStatusVerificationRequirements
     */
    'eventually_due'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * memberof UserStatusVerificationRequirements
     */
    'currently_due'?: Array<string> | null;
}
/**
 * 
 * export
 * @interface UserUpdateBusinessDeets
 */
export interface UserUpdateBusinessDeets {
    /**
     * Business website
     * @type {string}
     * memberof UserUpdateBusinessDeets
     */
    'business_website'?: string | null;
    /**
     * Business EIN
     * @type {string}
     * memberof UserUpdateBusinessDeets
     */
    'business_ein'?: string | null;
    /**
     * Is owners provided for the business
     * @type {boolean}
     * memberof UserUpdateBusinessDeets
     */
    'is_business_owners_provided'?: boolean | null;
    /**
     * List of associated persons with business
     * @type {Array<UserUpdateBusinessDeetsPerson>}
     * memberof UserUpdateBusinessDeets
     */
    'business_persons'?: Array<UserUpdateBusinessDeetsPerson> | null;
}
/**
 * 
 * export
 * @interface UserUpdateBusinessDeetsPerson
 */
export interface UserUpdateBusinessDeetsPerson {
    /**
     * Id of the persona
     * @type {string}
     * memberof UserUpdateBusinessDeetsPerson
     */
    'id'?: string | null;
    /**
     * First name of the person
     * @type {string}
     * memberof UserUpdateBusinessDeetsPerson
     */
    'first_name'?: string | null;
    /**
     * Last name of the person
     * @type {string}
     * memberof UserUpdateBusinessDeetsPerson
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof UserUpdateBusinessDeetsPerson
     */
    'address'?: AddressDeets;
    /**
     * The birthdate of the person
     * @type {string}
     * memberof UserUpdateBusinessDeetsPerson
     */
    'dob'?: string | null;
    /**
     * Phone number of the person
     * @type {string}
     * memberof UserUpdateBusinessDeetsPerson
     */
    'phone'?: string | null;
    /**
     * Email address of the person
     * @type {string}
     * memberof UserUpdateBusinessDeetsPerson
     */
    'email'?: string | null;
    /**
     * Federal Tax Identifier
     * @type {string}
     * memberof UserUpdateBusinessDeetsPerson
     */
    'federal_tax_id'?: string | null;
    /**
     * Federal Tax Identifier / SSN of the account holder
     * @type {string}
     * memberof UserUpdateBusinessDeetsPerson
     */
    'full_ssn'?: string | null;
    /**
     * Job title of person
     * @type {string}
     * memberof UserUpdateBusinessDeetsPerson
     */
    'job_title'?: string | null;
    /**
     * 
     * @type {RelationshipOptionsPerson}
     * memberof UserUpdateBusinessDeetsPerson
     */
    'relationship_options'?: RelationshipOptionsPerson;
}
/**
 * 
 * export
 * @interface UserUpdateIndividualDeets
 */
export interface UserUpdateIndividualDeets {
    /**
     * Federal Tax Identifier / SSN of the account holder
     * @type {string}
     * memberof UserUpdateIndividualDeets
     */
    'full_ssn'?: string | null;
    /**
     * The birthdate of the account holder
     * @type {string}
     * memberof UserUpdateIndividualDeets
     */
    'dob'?: string | null;
    /**
     * 
     * @type {AddressDeets}
     * memberof UserUpdateIndividualDeets
     */
    'address'?: AddressDeets;
}
/**
 * validation error
 * export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {PaymentCycleFieldEnum}
     * memberof ValidationError
     */
    'field'?: PaymentCycleFieldEnum;
    /**
     * 
     * @type {PaymentCycleValidationType}
     * memberof ValidationError
     */
    'type'?: PaymentCycleValidationType;
    /**
     * validation message
     * @type {string}
     * memberof ValidationError
     */
    'message'?: string | null;
}


/**
 * 
 * export
 * @interface VirtualReceivingAccountInfo
 */
export interface VirtualReceivingAccountInfo {
    /**
     * 
     * @type {string}
     * memberof VirtualReceivingAccountInfo
     */
    'AccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * memberof VirtualReceivingAccountInfo
     */
    'RoutingNumber'?: string | null;
    /**
     * 
     * @type {string}
     * memberof VirtualReceivingAccountInfo
     */
    'SwiftCode'?: string | null;
    /**
     * 
     * @type {string}
     * memberof VirtualReceivingAccountInfo
     */
    'BankName'?: string | null;
    /**
     * 
     * @type {string}
     * memberof VirtualReceivingAccountInfo
     */
    'FirstName'?: string | null;
    /**
     * 
     * @type {string}
     * memberof VirtualReceivingAccountInfo
     */
    'LastName'?: string | null;
    /**
     * 
     * @type {string}
     * memberof VirtualReceivingAccountInfo
     */
    'Email'?: string | null;
}
/**
 * 
 * export
 * @interface WaitlistDeets
 */
export interface WaitlistDeets {
    /**
     * 
     * @type {HubSpotLifecycle}
     * memberof WaitlistDeets
     */
    'lifecycle'?: HubSpotLifecycle;
    /**
     * 
     * @type {string}
     * memberof WaitlistDeets
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof WaitlistDeets
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * memberof WaitlistDeets
     */
    'company'?: string | null;
    /**
     * 
     * @type {string}
     * memberof WaitlistDeets
     */
    'transaction_volume'?: string | null;
    /**
     * 
     * @type {string}
     * memberof WaitlistDeets
     */
    'country'?: string | null;
}


/**
 * 
 * export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * The wallet key
     * @type {string}
     * memberof Wallet
     */
    'key'?: string | null;
    /**
     * The ID of the user the Wallet belongs to
     * @type {string}
     * memberof Wallet
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Wallet
     */
    'account_id'?: string | null;
    /**
     * True if this Wallet has been enabled for the User  otherwise false
     * @type {boolean}
     * memberof Wallet
     */
    'enabled'?: boolean;
    /**
     * True if this Wallet supports charges for payments  otherwise false
     * @type {boolean}
     * memberof Wallet
     */
    'supports_payouts'?: boolean;
    /**
     * True if this Wallet supports sending  money to external accounts  otherwise false
     * @type {boolean}
     * memberof Wallet
     */
    'supports_payments'?: boolean;
    /**
     * 
     * @type {string}
     * memberof Wallet
     */
    'external_account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Wallet
     */
    'auth_token'?: string | null;
    /**
     * 
     * @type {Array<PayoutMethod>}
     * memberof Wallet
     */
    'payout_methods'?: Array<PayoutMethod> | null;
    /**
     * 
     * @type {Array<PaymentMethod>}
     * memberof Wallet
     */
    'payment_methods'?: Array<PaymentMethod> | null;
    /**
     * 
     * @type {string}
     * memberof Wallet
     */
    'short_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Wallet
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof Wallet
     */
    'created_at'?: string;
}
/**
 * 
 * export
 * @interface WalletEnableDeets
 */
export interface WalletEnableDeets {
    /**
     * 
     * @type {string}
     * memberof WalletEnableDeets
     */
    'external_account_id'?: string | null;
    /**
     * 
     * @type {string}
     * memberof WalletEnableDeets
     */
    'auth_token'?: string | null;
    /**
     * 
     * @type {string}
     * memberof WalletEnableDeets
     */
    'object'?: string | null;
}

/**
 * AccountApi - axios parameter creator
 * export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The account block action is irreversible through the API.   Users must contact support to unblock their accounts if this action was done in error.
         * summary Disables a user\'s account by marking it as blocked in Auth0.   The user ID is extracted from the JWT token provided in the Authorization header.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * The account block action is irreversible through the API.   Users must contact support to unblock their accounts if this action was done in error.
         * summary Disables a user\'s account by marking it as blocked in Auth0.   The user ID is extracted from the JWT token provided in the Authorization header.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.apiAccountDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * The account block action is irreversible through the API.   Users must contact support to unblock their accounts if this action was done in error.
         * summary Disables a user\'s account by marking it as blocked in Auth0.   The user ID is extracted from the JWT token provided in the Authorization header.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountDelete(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAccountDelete(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * The account block action is irreversible through the API.   Users must contact support to unblock their accounts if this action was done in error.
     * summary Disables a user\'s account by marking it as blocked in Auth0.   The user ID is extracted from the JWT token provided in the Authorization header.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof AccountApi
     */
    public apiAccountDelete(options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).apiAccountDelete(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ActivityApi - axios parameter creator
 * export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Retrieves the Activity with the specified key and activity type
         * @param {string} [key] The id of the object this activity is associated with
         * @param {ActivityType} [type] The type of activity being requested  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity: async (key?: string, type?: ActivityType, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieves the Task Activity with the specified key and activity type
         * @param {ActivityType} [type] The type of activity being requested  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskList: async (type?: ActivityType, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/activity/task-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create or update an Activity
         * @param {string} [key] The id of the object this activity is associated with
         * @param {ActivityType} [type] Specifies the type of the activity  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
         * @param {ActivityStatus} [status] Specifies the status of the activity  unknown  started  pending  completed  needsAttention  failed  notStarted
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivity: async (key?: string, type?: ActivityType, status?: ActivityStatus, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary update activity task status
         * @param {string} activityId 
         * @param {string} taskId 
         * @param {ActivityTaskUpdateDeets} [activityTaskUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityTask: async (activityId: string, taskId: string, activityTaskUpdateDeets?: ActivityTaskUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('updateActivityTask', 'activityId', activityId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('updateActivityTask', 'taskId', taskId)
            const localVarPath = `/api/activity/{activityId}/task/{taskId}`
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityTaskUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Retrieves the Activity with the specified key and activity type
         * @param {string} [key] The id of the object this activity is associated with
         * @param {ActivityType} [type] The type of activity being requested  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivity(key?: string, type?: ActivityType, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(key, type, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.getActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieves the Task Activity with the specified key and activity type
         * @param {ActivityType} [type] The type of activity being requested  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskList(type?: ActivityType, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskList(type, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.getTaskList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create or update an Activity
         * @param {string} [key] The id of the object this activity is associated with
         * @param {ActivityType} [type] Specifies the type of the activity  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
         * @param {ActivityStatus} [status] Specifies the status of the activity  unknown  started  pending  completed  needsAttention  failed  notStarted
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActivity(key?: string, type?: ActivityType, status?: ActivityStatus, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateActivity(key, type, status, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.updateActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary update activity task status
         * @param {string} activityId 
         * @param {string} taskId 
         * @param {ActivityTaskUpdateDeets} [activityTaskUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActivityTask(activityId: string, taskId: string, activityTaskUpdateDeets?: ActivityTaskUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateActivityTask(activityId, taskId, activityTaskUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.updateActivityTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivityApi - factory interface
 * export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         * 
         * summary Retrieves the Activity with the specified key and activity type
         * @param {string} [key] The id of the object this activity is associated with
         * @param {ActivityType} [type] The type of activity being requested  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(key?: string, type?: ActivityType, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Activity> {
            return localVarFp.getActivity(key, type, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieves the Task Activity with the specified key and activity type
         * @param {ActivityType} [type] The type of activity being requested  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskList(type?: ActivityType, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Activity> {
            return localVarFp.getTaskList(type, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create or update an Activity
         * @param {string} [key] The id of the object this activity is associated with
         * @param {ActivityType} [type] Specifies the type of the activity  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
         * @param {ActivityStatus} [status] Specifies the status of the activity  unknown  started  pending  completed  needsAttention  failed  notStarted
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivity(key?: string, type?: ActivityType, status?: ActivityStatus, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Activity> {
            return localVarFp.updateActivity(key, type, status, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary update activity task status
         * @param {string} activityId 
         * @param {string} taskId 
         * @param {ActivityTaskUpdateDeets} [activityTaskUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityTask(activityId: string, taskId: string, activityTaskUpdateDeets?: ActivityTaskUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<Activity> {
            return localVarFp.updateActivityTask(activityId, taskId, activityTaskUpdateDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityApi - object-oriented interface
 * export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * 
     * summary Retrieves the Activity with the specified key and activity type
     * @param {string} [key] The id of the object this activity is associated with
     * @param {ActivityType} [type] The type of activity being requested  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ActivityApi
     */
    public getActivity(key?: string, type?: ActivityType, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).getActivity(key, type, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieves the Task Activity with the specified key and activity type
     * @param {ActivityType} [type] The type of activity being requested  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ActivityApi
     */
    public getTaskList(type?: ActivityType, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).getTaskList(type, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create or update an Activity
     * @param {string} [key] The id of the object this activity is associated with
     * @param {ActivityType} [type] Specifies the type of the activity  contactCreated  invited  onboarded  readyForPayouts  firstPayout  firstPayment
     * @param {ActivityStatus} [status] Specifies the status of the activity  unknown  started  pending  completed  needsAttention  failed  notStarted
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ActivityApi
     */
    public updateActivity(key?: string, type?: ActivityType, status?: ActivityStatus, userId?: string, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).updateActivity(key, type, status, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary update activity task status
     * @param {string} activityId 
     * @param {string} taskId 
     * @param {ActivityTaskUpdateDeets} [activityTaskUpdateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ActivityApi
     */
    public updateActivityTask(activityId: string, taskId: string, activityTaskUpdateDeets?: ActivityTaskUpdateDeets, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).updateActivityTask(activityId, taskId, activityTaskUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnalyticsApi - axios parameter creator
 * export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Retrieve a list of Payments summed by date
         * @param {number} [minAmount] The minimum amount for filtering
         * @param {number} [maxAmount] The maximum amount for filtering
         * @param {string} [fromDate] The starting date for filtering
         * @param {string} [toDate] The end date for filtering
         * @param {Array<string>} [statuses] A list of statuses for filtering
         * @param {Array<string>} [paymentTypes] A list of payment types for filtering
         * @param {string} [id] 
         * @param {string} [shortId] 
         * @param {string} [toHandle] The Mozaic handle for a contact
         * @param {string} [toEmail] The email address of the contact
         * @param {string} [toPhone] The fully qualified phone number of the contact
         * @param {string} [toName] Loosely, the name of the contact. May be changed during registration
         * @param {string} [toPersonaId] Specifies the persona associated with this contact record
         * @param {string} [toUserId] Specifies the user associated with this contact record
         * @param {string} [toUserAccountId] Specifies the user account id associated with this contact record
         * @param {string} [toId] 
         * @param {string} [toCreated] 
         * @param {string} [toShortId] 
         * @param {string} [toObjectName] The name of this object
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsGet: async (minAmount?: number, maxAmount?: number, fromDate?: string, toDate?: string, statuses?: Array<string>, paymentTypes?: Array<string>, id?: string, shortId?: string, toHandle?: string, toEmail?: string, toPhone?: string, toName?: string, toPersonaId?: string, toUserId?: string, toUserAccountId?: string, toId?: string, toCreated?: string, toShortId?: string, toObjectName?: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (minAmount !== undefined) {
                localVarQueryParameter['MinAmount'] = minAmount;
            }

            if (maxAmount !== undefined) {
                localVarQueryParameter['MaxAmount'] = maxAmount;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['FromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['ToDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (statuses) {
                localVarQueryParameter['Statuses'] = statuses;
            }

            if (paymentTypes) {
                localVarQueryParameter['PaymentTypes'] = paymentTypes;
            }

            if (id !== undefined) {
                localVarQueryParameter['Id'] = id;
            }

            if (shortId !== undefined) {
                localVarQueryParameter['ShortId'] = shortId;
            }

            if (toHandle !== undefined) {
                localVarQueryParameter['To.Handle'] = toHandle;
            }

            if (toEmail !== undefined) {
                localVarQueryParameter['To.Email'] = toEmail;
            }

            if (toPhone !== undefined) {
                localVarQueryParameter['To.Phone'] = toPhone;
            }

            if (toName !== undefined) {
                localVarQueryParameter['To.Name'] = toName;
            }

            if (toPersonaId !== undefined) {
                localVarQueryParameter['To.PersonaId'] = toPersonaId;
            }

            if (toUserId !== undefined) {
                localVarQueryParameter['To.UserId'] = toUserId;
            }

            if (toUserAccountId !== undefined) {
                localVarQueryParameter['To.UserAccountId'] = toUserAccountId;
            }

            if (toId !== undefined) {
                localVarQueryParameter['To.Id'] = toId;
            }

            if (toCreated !== undefined) {
                localVarQueryParameter['To.Created'] = (toCreated as any instanceof Date) ?
                    (toCreated as any).toISOString() :
                    toCreated;
            }

            if (toShortId !== undefined) {
                localVarQueryParameter['To.ShortId'] = toShortId;
            }

            if (toObjectName !== undefined) {
                localVarQueryParameter['To.ObjectName'] = toObjectName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Retrieve a list of Payments summed by date
         * @param {number} [minAmount] The minimum amount for filtering
         * @param {number} [maxAmount] The maximum amount for filtering
         * @param {string} [fromDate] The starting date for filtering
         * @param {string} [toDate] The end date for filtering
         * @param {Array<string>} [statuses] A list of statuses for filtering
         * @param {Array<string>} [paymentTypes] A list of payment types for filtering
         * @param {string} [id] 
         * @param {string} [shortId] 
         * @param {string} [toHandle] The Mozaic handle for a contact
         * @param {string} [toEmail] The email address of the contact
         * @param {string} [toPhone] The fully qualified phone number of the contact
         * @param {string} [toName] Loosely, the name of the contact. May be changed during registration
         * @param {string} [toPersonaId] Specifies the persona associated with this contact record
         * @param {string} [toUserId] Specifies the user associated with this contact record
         * @param {string} [toUserAccountId] Specifies the user account id associated with this contact record
         * @param {string} [toId] 
         * @param {string} [toCreated] 
         * @param {string} [toShortId] 
         * @param {string} [toObjectName] The name of this object
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsGet(minAmount?: number, maxAmount?: number, fromDate?: string, toDate?: string, statuses?: Array<string>, paymentTypes?: Array<string>, id?: string, shortId?: string, toHandle?: string, toEmail?: string, toPhone?: string, toName?: string, toPersonaId?: string, toUserId?: string, toUserAccountId?: string, toId?: string, toCreated?: string, toShortId?: string, toObjectName?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DateTimeDecimalDataSeries>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsGet(minAmount, maxAmount, fromDate, toDate, statuses, paymentTypes, id, shortId, toHandle, toEmail, toPhone, toName, toPersonaId, toUserId, toUserAccountId, toId, toCreated, toShortId, toObjectName, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.apiAnalyticsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * 
         * summary Retrieve a list of Payments summed by date
         * @param {number} [minAmount] The minimum amount for filtering
         * @param {number} [maxAmount] The maximum amount for filtering
         * @param {string} [fromDate] The starting date for filtering
         * @param {string} [toDate] The end date for filtering
         * @param {Array<string>} [statuses] A list of statuses for filtering
         * @param {Array<string>} [paymentTypes] A list of payment types for filtering
         * @param {string} [id] 
         * @param {string} [shortId] 
         * @param {string} [toHandle] The Mozaic handle for a contact
         * @param {string} [toEmail] The email address of the contact
         * @param {string} [toPhone] The fully qualified phone number of the contact
         * @param {string} [toName] Loosely, the name of the contact. May be changed during registration
         * @param {string} [toPersonaId] Specifies the persona associated with this contact record
         * @param {string} [toUserId] Specifies the user associated with this contact record
         * @param {string} [toUserAccountId] Specifies the user account id associated with this contact record
         * @param {string} [toId] 
         * @param {string} [toCreated] 
         * @param {string} [toShortId] 
         * @param {string} [toObjectName] The name of this object
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsGet(minAmount?: number, maxAmount?: number, fromDate?: string, toDate?: string, statuses?: Array<string>, paymentTypes?: Array<string>, id?: string, shortId?: string, toHandle?: string, toEmail?: string, toPhone?: string, toName?: string, toPersonaId?: string, toUserId?: string, toUserAccountId?: string, toId?: string, toCreated?: string, toShortId?: string, toObjectName?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DateTimeDecimalDataSeries> {
            return localVarFp.apiAnalyticsGet(minAmount, maxAmount, fromDate, toDate, statuses, paymentTypes, id, shortId, toHandle, toEmail, toPhone, toName, toPersonaId, toUserId, toUserAccountId, toId, toCreated, toShortId, toObjectName, limit, page, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * 
     * summary Retrieve a list of Payments summed by date
     * @param {number} [minAmount] The minimum amount for filtering
     * @param {number} [maxAmount] The maximum amount for filtering
     * @param {string} [fromDate] The starting date for filtering
     * @param {string} [toDate] The end date for filtering
     * @param {Array<string>} [statuses] A list of statuses for filtering
     * @param {Array<string>} [paymentTypes] A list of payment types for filtering
     * @param {string} [id] 
     * @param {string} [shortId] 
     * @param {string} [toHandle] The Mozaic handle for a contact
     * @param {string} [toEmail] The email address of the contact
     * @param {string} [toPhone] The fully qualified phone number of the contact
     * @param {string} [toName] Loosely, the name of the contact. May be changed during registration
     * @param {string} [toPersonaId] Specifies the persona associated with this contact record
     * @param {string} [toUserId] Specifies the user associated with this contact record
     * @param {string} [toUserAccountId] Specifies the user account id associated with this contact record
     * @param {string} [toId] 
     * @param {string} [toCreated] 
     * @param {string} [toShortId] 
     * @param {string} [toObjectName] The name of this object
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof AnalyticsApi
     */
    public apiAnalyticsGet(minAmount?: number, maxAmount?: number, fromDate?: string, toDate?: string, statuses?: Array<string>, paymentTypes?: Array<string>, id?: string, shortId?: string, toHandle?: string, toEmail?: string, toPhone?: string, toName?: string, toPersonaId?: string, toUserId?: string, toUserAccountId?: string, toId?: string, toCreated?: string, toShortId?: string, toObjectName?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsGet(minAmount, maxAmount, fromDate, toDate, statuses, paymentTypes, id, shortId, toHandle, toEmail, toPhone, toName, toPersonaId, toUserId, toUserAccountId, toId, toCreated, toShortId, toObjectName, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiKeyApi - axios parameter creator
 * export
 */
export const ApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Deletes the current API key for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The user\'s account must have Jammber.RainCloud.ApiKey.Create. permissions
         * summary Retrieves the user\'s current API Keys if they already exist, otherwise a new ClientID and ClientSecret   will be generated for the user\'s account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/apikey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeyApi - functional programming interface
 * export
 */
export const ApiKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Deletes the current API key for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeyApi.apiKeyDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The user\'s account must have Jammber.RainCloud.ApiKey.Create. permissions
         * summary Retrieves the user\'s current API Keys if they already exist, otherwise a new ClientID and ClientSecret   will be generated for the user\'s account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeyGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeyGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeyApi.apiKeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiKeyApi - factory interface
 * export
 */
export const ApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeyApiFp(configuration)
    return {
        /**
         * 
         * summary Deletes the current API key for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyDelete(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiKeyDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * The user\'s account must have Jammber.RainCloud.ApiKey.Create. permissions
         * summary Retrieves the user\'s current API Keys if they already exist, otherwise a new ClientID and ClientSecret   will be generated for the user\'s account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeyGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiKeyGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeyApi - object-oriented interface
 * export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
    /**
     * 
     * summary Deletes the current API key for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ApiKeyApi
     */
    public apiKeyDelete(options?: RawAxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).apiKeyDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The user\'s account must have Jammber.RainCloud.ApiKey.Create. permissions
     * summary Retrieves the user\'s current API Keys if they already exist, otherwise a new ClientID and ClientSecret   will be generated for the user\'s account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ApiKeyApi
     */
    public apiKeyGet(options?: RawAxiosRequestConfig) {
        return ApiKeyApiFp(this.configuration).apiKeyGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AppsApi - axios parameter creator
 * export
 */
export const AppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Delete an application
         * @param {string} [id] The id for the application to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAppsDelete: async (id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve the info for applications you\'ve created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAppsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create an application that can call the Mozaic API.
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAppsIdPut: async (id: string, description?: string, name?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAppsIdPut', 'id', id)
            const localVarPath = `/api/apps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (description !== undefined) {
                localVarQueryParameter['Description'] = description;
            }

            if (name !== undefined) {
                localVarQueryParameter['Name'] = name;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create an application that can call the Mozaic API.
         * @param {string} [description] A description for the application. Max 140 characters.
         * @param {string} [name] A name for the application
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAppsPost: async (description?: string, name?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (description !== undefined) {
                localVarQueryParameter['Description'] = description;
            }

            if (name !== undefined) {
                localVarQueryParameter['Name'] = name;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 * export
 */
export const AppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Delete an application
         * @param {string} [id] The id for the application to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAppsDelete(id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAppsDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.apiAppsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve the info for applications you\'ve created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAppsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApplicationListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAppsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.apiAppsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create an application that can call the Mozaic API.
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAppsIdPut(id: string, description?: string, name?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApplicationCreateDeets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAppsIdPut(id, description, name, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.apiAppsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create an application that can call the Mozaic API.
         * @param {string} [description] A description for the application. Max 140 characters.
         * @param {string} [name] A name for the application
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAppsPost(description?: string, name?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserApplicationCreateDeets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAppsPost(description, name, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.apiAppsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppsApi - factory interface
 * export
 */
export const AppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsApiFp(configuration)
    return {
        /**
         * 
         * summary Delete an application
         * @param {string} [id] The id for the application to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAppsDelete(id?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAppsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve the info for applications you\'ve created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAppsGet(options?: RawAxiosRequestConfig): AxiosPromise<UserApplicationListResponse> {
            return localVarFp.apiAppsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create an application that can call the Mozaic API.
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [description] 
         * @param {string} [name] 
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAppsIdPut(id: string, description?: string, name?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserApplicationCreateDeets> {
            return localVarFp.apiAppsIdPut(id, description, name, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create an application that can call the Mozaic API.
         * @param {string} [description] A description for the application. Max 140 characters.
         * @param {string} [name] A name for the application
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAppsPost(description?: string, name?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserApplicationCreateDeets> {
            return localVarFp.apiAppsPost(description, name, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppsApi - object-oriented interface
 * export
 * @class AppsApi
 * @extends {BaseAPI}
 */
export class AppsApi extends BaseAPI {
    /**
     * 
     * summary Delete an application
     * @param {string} [id] The id for the application to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof AppsApi
     */
    public apiAppsDelete(id?: string, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).apiAppsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve the info for applications you\'ve created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof AppsApi
     */
    public apiAppsGet(options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).apiAppsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create an application that can call the Mozaic API.
     * @param {string} id The id of the record you wish to retrieve
     * @param {string} [description] 
     * @param {string} [name] 
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof AppsApi
     */
    public apiAppsIdPut(id: string, description?: string, name?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).apiAppsIdPut(id, description, name, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create an application that can call the Mozaic API.
     * @param {string} [description] A description for the application. Max 140 characters.
     * @param {string} [name] A name for the application
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof AppsApi
     */
    public apiAppsPost(description?: string, name?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).apiAppsPost(description, name, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AvatarsApi - axios parameter creator
 * export
 */
export const AvatarsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Retrieve a avatar by id and avatartype
         * @param {string} id The id of the record you wish to retrieve
         * @param {AvatarTypeEnum} [avatarType] avatar type  contact  simpleContarct  paymentCycle  profile
         * @param {string} [initials] 
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarGet: async (id: string, avatarType?: AvatarTypeEnum, initials?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('avatarGet', 'id', id)
            const localVarPath = `/api/avatars/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (avatarType !== undefined) {
                localVarQueryParameter['avatar-type'] = avatarType;
            }

            if (initials !== undefined) {
                localVarQueryParameter['initials'] = initials;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Upload avatar profile image via file
         * @param {string} id The id of the record you wish to retrieve
         * @param {AvatarTypeEnum} [avatarType] avatar type  contact  simpleContarct  paymentCycle  profile
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {File} [file] avatar image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarUpload: async (id: string, avatarType?: AvatarTypeEnum, userId?: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('avatarUpload', 'id', id)
            const localVarPath = `/api/avatars/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (avatarType !== undefined) {
                localVarQueryParameter['avatar-type'] = avatarType;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


            if (file !== undefined) { 
                localVarFormParams.append('File', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvatarsApi - functional programming interface
 * export
 */
export const AvatarsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AvatarsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Retrieve a avatar by id and avatartype
         * @param {string} id The id of the record you wish to retrieve
         * @param {AvatarTypeEnum} [avatarType] avatar type  contact  simpleContarct  paymentCycle  profile
         * @param {string} [initials] 
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avatarGet(id: string, avatarType?: AvatarTypeEnum, initials?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.avatarGet(id, avatarType, initials, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvatarsApi.avatarGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Upload avatar profile image via file
         * @param {string} id The id of the record you wish to retrieve
         * @param {AvatarTypeEnum} [avatarType] avatar type  contact  simpleContarct  paymentCycle  profile
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {File} [file] avatar image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avatarUpload(id: string, avatarType?: AvatarTypeEnum, userId?: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.avatarUpload(id, avatarType, userId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AvatarsApi.avatarUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AvatarsApi - factory interface
 * export
 */
export const AvatarsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AvatarsApiFp(configuration)
    return {
        /**
         * 
         * summary Retrieve a avatar by id and avatartype
         * @param {string} id The id of the record you wish to retrieve
         * @param {AvatarTypeEnum} [avatarType] avatar type  contact  simpleContarct  paymentCycle  profile
         * @param {string} [initials] 
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarGet(id: string, avatarType?: AvatarTypeEnum, initials?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.avatarGet(id, avatarType, initials, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Upload avatar profile image via file
         * @param {string} id The id of the record you wish to retrieve
         * @param {AvatarTypeEnum} [avatarType] avatar type  contact  simpleContarct  paymentCycle  profile
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {File} [file] avatar image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarUpload(id: string, avatarType?: AvatarTypeEnum, userId?: string, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.avatarUpload(id, avatarType, userId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvatarsApi - object-oriented interface
 * export
 * @class AvatarsApi
 * @extends {BaseAPI}
 */
export class AvatarsApi extends BaseAPI {
    /**
     * 
     * summary Retrieve a avatar by id and avatartype
     * @param {string} id The id of the record you wish to retrieve
     * @param {AvatarTypeEnum} [avatarType] avatar type  contact  simpleContarct  paymentCycle  profile
     * @param {string} [initials] 
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof AvatarsApi
     */
    public avatarGet(id: string, avatarType?: AvatarTypeEnum, initials?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).avatarGet(id, avatarType, initials, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Upload avatar profile image via file
     * @param {string} id The id of the record you wish to retrieve
     * @param {AvatarTypeEnum} [avatarType] avatar type  contact  simpleContarct  paymentCycle  profile
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {File} [file] avatar image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof AvatarsApi
     */
    public avatarUpload(id: string, avatarType?: AvatarTypeEnum, userId?: string, file?: File, options?: RawAxiosRequestConfig) {
        return AvatarsApiFp(this.configuration).avatarUpload(id, avatarType, userId, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectorsApi - axios parameter creator
 * export
 */
export const ConnectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Retreive portfolio items.
         * @param {string} [connectorName] 
         * @param {string} [keywords] 
         * @param {string} [channelId] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsItemsGet: async (connectorName?: string, keywords?: string, channelId?: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keywords !== undefined) {
                localVarQueryParameter['Keywords'] = keywords;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['ChannelId'] = channelId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (connectorName != null) {
                localVarHeaderParameter['connector-name'] = String(connectorName);
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Connector auth url for authentication.
         * @param {string} [connectorName] 
         * @param {boolean} [isSmartAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorAuthUrl: async (connectorName?: string, isSmartAuth?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors/auth-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isSmartAuth !== undefined) {
                localVarQueryParameter['IsSmartAuth'] = isSmartAuth;
            }

            if (connectorName != null) {
                localVarHeaderParameter['connector-name'] = String(connectorName);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Authentication with connector and store access info.
         * @param {string} [connectorName] 
         * @param {string} [code] 
         * @param {boolean} [isSmartAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorAuthenticate: async (connectorName?: string, code?: string, isSmartAuth?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (code !== undefined) {
                localVarQueryParameter['Code'] = code;
            }

            if (isSmartAuth !== undefined) {
                localVarQueryParameter['IsSmartAuth'] = isSmartAuth;
            }

            if (connectorName != null) {
                localVarHeaderParameter['connector-name'] = String(connectorName);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Check if already authenticated for connector
         * @param {string} [connectorName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorCheckAuth: async (connectorName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors/check-auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (connectorName != null) {
                localVarHeaderParameter['connector-name'] = String(connectorName);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Revoke access
         * @param {string} [connectorName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorRevokeAccess: async (connectorName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors/revoke-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (connectorName != null) {
                localVarHeaderParameter['connector-name'] = String(connectorName);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Smart auth callback to store token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorSmartAuthenticationCallback: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors/smart-auth-callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create a connector
         * @param {ConnectorDeet} [connectorDeet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorsPOST: async (connectorDeet?: ConnectorDeet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorDeet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a List all connectors.
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors: async (limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsApi - functional programming interface
 * export
 */
export const ConnectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Retreive portfolio items.
         * @param {string} [connectorName] 
         * @param {string} [keywords] 
         * @param {string} [channelId] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorsItemsGet(connectorName?: string, keywords?: string, channelId?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItemListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorsItemsGet(connectorName, keywords, channelId, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.apiConnectorsItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Connector auth url for authentication.
         * @param {string} [connectorName] 
         * @param {boolean} [isSmartAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorAuthUrl(connectorName?: string, isSmartAuth?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorAuthUrl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorAuthUrl(connectorName, isSmartAuth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.connectorAuthUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Authentication with connector and store access info.
         * @param {string} [connectorName] 
         * @param {string} [code] 
         * @param {boolean} [isSmartAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorAuthenticate(connectorName?: string, code?: string, isSmartAuth?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorAuthListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorAuthenticate(connectorName, code, isSmartAuth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.connectorAuthenticate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Check if already authenticated for connector
         * @param {string} [connectorName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorCheckAuth(connectorName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorAuthListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorCheckAuth(connectorName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.connectorCheckAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Revoke access
         * @param {string} [connectorName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorRevokeAccess(connectorName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorRevokeAccess(connectorName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.connectorRevokeAccess']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Smart auth callback to store token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorSmartAuthenticationCallback(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorSmartAuthenticationCallback(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.connectorSmartAuthenticationCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create a connector
         * @param {ConnectorDeet} [connectorDeet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectorsPOST(connectorDeet?: ConnectorDeet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectorsPOST(connectorDeet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.connectorsPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a List all connectors.
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectors(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectors(limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorsApi - factory interface
 * export
 */
export const ConnectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorsApiFp(configuration)
    return {
        /**
         * 
         * summary Retreive portfolio items.
         * @param {string} [connectorName] 
         * @param {string} [keywords] 
         * @param {string} [channelId] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsItemsGet(connectorName?: string, keywords?: string, channelId?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PortfolioItemListResponse> {
            return localVarFp.apiConnectorsItemsGet(connectorName, keywords, channelId, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Connector auth url for authentication.
         * @param {string} [connectorName] 
         * @param {boolean} [isSmartAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorAuthUrl(connectorName?: string, isSmartAuth?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorAuthUrl> {
            return localVarFp.connectorAuthUrl(connectorName, isSmartAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Authentication with connector and store access info.
         * @param {string} [connectorName] 
         * @param {string} [code] 
         * @param {boolean} [isSmartAuth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorAuthenticate(connectorName?: string, code?: string, isSmartAuth?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorAuthListResponse> {
            return localVarFp.connectorAuthenticate(connectorName, code, isSmartAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Check if already authenticated for connector
         * @param {string} [connectorName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorCheckAuth(connectorName?: string, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorAuthListResponse> {
            return localVarFp.connectorCheckAuth(connectorName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Revoke access
         * @param {string} [connectorName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorRevokeAccess(connectorName?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectorRevokeAccess(connectorName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Smart auth callback to store token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorSmartAuthenticationCallback(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectorSmartAuthenticationCallback(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create a connector
         * @param {ConnectorDeet} [connectorDeet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectorsPOST(connectorDeet?: ConnectorDeet, options?: RawAxiosRequestConfig): AxiosPromise<Connector> {
            return localVarFp.connectorsPOST(connectorDeet, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a List all connectors.
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorListResponse> {
            return localVarFp.getConnectors(limit, page, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorsApi - object-oriented interface
 * export
 * @class ConnectorsApi
 * @extends {BaseAPI}
 */
export class ConnectorsApi extends BaseAPI {
    /**
     * 
     * summary Retreive portfolio items.
     * @param {string} [connectorName] 
     * @param {string} [keywords] 
     * @param {string} [channelId] 
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ConnectorsApi
     */
    public apiConnectorsItemsGet(connectorName?: string, keywords?: string, channelId?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).apiConnectorsItemsGet(connectorName, keywords, channelId, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Connector auth url for authentication.
     * @param {string} [connectorName] 
     * @param {boolean} [isSmartAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ConnectorsApi
     */
    public connectorAuthUrl(connectorName?: string, isSmartAuth?: boolean, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).connectorAuthUrl(connectorName, isSmartAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Authentication with connector and store access info.
     * @param {string} [connectorName] 
     * @param {string} [code] 
     * @param {boolean} [isSmartAuth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ConnectorsApi
     */
    public connectorAuthenticate(connectorName?: string, code?: string, isSmartAuth?: boolean, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).connectorAuthenticate(connectorName, code, isSmartAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Check if already authenticated for connector
     * @param {string} [connectorName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ConnectorsApi
     */
    public connectorCheckAuth(connectorName?: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).connectorCheckAuth(connectorName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Revoke access
     * @param {string} [connectorName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ConnectorsApi
     */
    public connectorRevokeAccess(connectorName?: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).connectorRevokeAccess(connectorName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Smart auth callback to store token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ConnectorsApi
     */
    public connectorSmartAuthenticationCallback(options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).connectorSmartAuthenticationCallback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create a connector
     * @param {ConnectorDeet} [connectorDeet] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ConnectorsApi
     */
    public connectorsPOST(connectorDeet?: ConnectorDeet, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).connectorsPOST(connectorDeet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a List all connectors.
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ConnectorsApi
     */
    public getConnectors(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnectors(limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactsApi - axios parameter creator
 * export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Accept the contact invitation
         * @param {string} id 
         * @param {ContactStatusUpdateDeets} [contactStatusUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptContactRequest: async (id: string, contactStatusUpdateDeets?: ContactStatusUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('acceptContactRequest', 'id', id)
            const localVarPath = `/api/contacts/{id}/accept-request`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactStatusUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Bulk add contacts
         * @param {ContactBulkCreateDeets} [contactBulkCreateDeets] All the contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsBulkPOST: async (contactBulkCreateDeets?: ContactBulkCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contacts/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactBulkCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Delete an contact
         * @param {string} [id] The id for the contact to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDELETE: async (id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Reset avatar to the default
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDeleteAvatar: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactsDeleteAvatar', 'id', id)
            const localVarPath = `/api/contacts/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Get a single contact
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGETById: async (id: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactsGETById', 'id', id)
            const localVarPath = `/api/contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary List contacts
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGETList: async (limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary List of invited contacts
         * @param {ContactStatusPersonaFilter} [contactStatus]   all  invited  accepted  rejected
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGETRequests: async (contactStatus?: ContactStatusPersonaFilter, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contacts/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (contactStatus !== undefined) {
                localVarQueryParameter['ContactStatus'] = contactStatus;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve an avatar by id
         * @param {string} id The id of the record you wish to retrieve
         * @param {AvatarType} [avatarType]   default  contact  simpleContarct  paymentCycle
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGetAvatarById: async (id: string, avatarType?: AvatarType, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactsGetAvatarById', 'id', id)
            const localVarPath = `/api/contacts/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (avatarType !== undefined) {
                localVarQueryParameter['AvatarType'] = avatarType;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create a contact record - contact invite.
         * @param {ContactInviteCreateDeets} [contactInviteCreateDeets] The contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsInvitePOST: async (contactInviteCreateDeets?: ContactInviteCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contacts/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactInviteCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Update a contact record - contact invite.
         * @param {string} personaId 
         * @param {ContactInviteUpdateDeets} [contactInviteUpdateDeets] The contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsInvitePut: async (personaId: string, contactInviteUpdateDeets?: ContactInviteUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('contactsInvitePut', 'personaId', personaId)
            const localVarPath = `/api/contacts/invite/{personaId}`
                .replace(`{${"personaId"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactInviteUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create a contact record
         * @param {ContactCreateDeets} [contactCreateDeets] The contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPOST: async (contactCreateDeets?: ContactCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Search contacts in the network based on Name, KnownName, Business name or Handle              Returns a list of <span class=\"jmbr term\">EndUser_Deets</span>.</p>
         * summary Search contacts
         * @param {string} [term] The search term or keyword
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsSearch: async (term?: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contacts/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (term !== undefined) {
                localVarQueryParameter['Term'] = term;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
         * summary Upload avatar image via file
         * @param {string} id contact id
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsUpdateAvatar: async (id: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactsUpdateAvatar', 'id', id)
            const localVarPath = `/api/contacts/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
         * summary Upload avatar via JSON body
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {AvatarBytes} [avatarBytes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsUpdateAvatarByDeets: async (id: string, userId?: string, avatarBytes?: AvatarBytes, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactsUpdateAvatarByDeets', 'id', id)
            const localVarPath = `/api/contacts/{id}/image/base64`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avatarBytes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
         * summary Generate a new avatar image via AI prompt.
         * @param {string} id 
         * @param {AvatarPromptCreateDeets} [avatarPromptCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsUpdateAvatarByPrompt: async (id: string, avatarPromptCreateDeets?: AvatarPromptCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactsUpdateAvatarByPrompt', 'id', id)
            const localVarPath = `/api/contacts/{id}/image/ai`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avatarPromptCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve the payment acceptance status for an account
         * @param {string} [accountId] Account Id to accept payments from
         * @param {AcceptPaymentStatusEnum} [status] Accept payment status enum  pending  accepted  suspended
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptPaymentStatusByAccountId: async (accountId?: string, status?: AcceptPaymentStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contacts/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['AccountId'] = accountId;
            }

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Reject the contact invitation
         * @param {string} id 
         * @param {ContactStatusUpdateDeets} [contactStatusUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectContactRequest: async (id: string, contactStatusUpdateDeets?: ContactStatusUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectContactRequest', 'id', id)
            const localVarPath = `/api/contacts/{id}/reject-request`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactStatusUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary List requests
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestsGETList: async (limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contacts/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Accept the contact invitation
         * @param {string} id 
         * @param {ContactStatusUpdateDeets} [contactStatusUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptContactRequest(id: string, contactStatusUpdateDeets?: ContactStatusUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptContactRequest(id, contactStatusUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.acceptContactRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Bulk add contacts
         * @param {ContactBulkCreateDeets} [contactBulkCreateDeets] All the contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsBulkPOST(contactBulkCreateDeets?: ContactBulkCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsBulkPOST(contactBulkCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsBulkPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Delete an contact
         * @param {string} [id] The id for the contact to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDELETE(id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDELETE(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsDELETE']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Reset avatar to the default
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDeleteAvatar(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDeleteAvatar(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsDeleteAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Get a single contact
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGETById(id: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGETById(id, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsGETById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary List contacts
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGETList(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactInfoListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGETList(limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsGETList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary List of invited contacts
         * @param {ContactStatusPersonaFilter} [contactStatus]   all  invited  accepted  rejected
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGETRequests(contactStatus?: ContactStatusPersonaFilter, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactInfoListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGETRequests(contactStatus, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsGETRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve an avatar by id
         * @param {string} id The id of the record you wish to retrieve
         * @param {AvatarType} [avatarType]   default  contact  simpleContarct  paymentCycle
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGetAvatarById(id: string, avatarType?: AvatarType, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGetAvatarById(id, avatarType, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsGetAvatarById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create a contact record - contact invite.
         * @param {ContactInviteCreateDeets} [contactInviteCreateDeets] The contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsInvitePOST(contactInviteCreateDeets?: ContactInviteCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsInvitePOST(contactInviteCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsInvitePOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Update a contact record - contact invite.
         * @param {string} personaId 
         * @param {ContactInviteUpdateDeets} [contactInviteUpdateDeets] The contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsInvitePut(personaId: string, contactInviteUpdateDeets?: ContactInviteUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsInvitePut(personaId, contactInviteUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsInvitePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create a contact record
         * @param {ContactCreateDeets} [contactCreateDeets] The contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPOST(contactCreateDeets?: ContactCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPOST(contactCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Search contacts in the network based on Name, KnownName, Business name or Handle              Returns a list of <span class=\"jmbr term\">EndUser_Deets</span>.</p>
         * summary Search contacts
         * @param {string} [term] The search term or keyword
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsSearch(term?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactInfoListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsSearch(term, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
         * summary Upload avatar image via file
         * @param {string} id contact id
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsUpdateAvatar(id: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsUpdateAvatar(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsUpdateAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
         * summary Upload avatar via JSON body
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {AvatarBytes} [avatarBytes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsUpdateAvatarByDeets(id: string, userId?: string, avatarBytes?: AvatarBytes, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsUpdateAvatarByDeets(id, userId, avatarBytes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsUpdateAvatarByDeets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
         * summary Generate a new avatar image via AI prompt.
         * @param {string} id 
         * @param {AvatarPromptCreateDeets} [avatarPromptCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsUpdateAvatarByPrompt(id: string, avatarPromptCreateDeets?: AvatarPromptCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsUpdateAvatarByPrompt(id, avatarPromptCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsUpdateAvatarByPrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve the payment acceptance status for an account
         * @param {string} [accountId] Account Id to accept payments from
         * @param {AcceptPaymentStatusEnum} [status] Accept payment status enum  pending  accepted  suspended
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAcceptPaymentStatusByAccountId(accountId?: string, status?: AcceptPaymentStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentAcceptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAcceptPaymentStatusByAccountId(accountId, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.getAcceptPaymentStatusByAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Reject the contact invitation
         * @param {string} id 
         * @param {ContactStatusUpdateDeets} [contactStatusUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectContactRequest(id: string, contactStatusUpdateDeets?: ContactStatusUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectContactRequest(id, contactStatusUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.rejectContactRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary List requests
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestsGETList(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactInfoListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestsGETList(limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.requestsGETList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactsApi - factory interface
 * export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * 
         * summary Accept the contact invitation
         * @param {string} id 
         * @param {ContactStatusUpdateDeets} [contactStatusUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptContactRequest(id: string, contactStatusUpdateDeets?: ContactStatusUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<ContactInfo> {
            return localVarFp.acceptContactRequest(id, contactStatusUpdateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Bulk add contacts
         * @param {ContactBulkCreateDeets} [contactBulkCreateDeets] All the contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsBulkPOST(contactBulkCreateDeets?: ContactBulkCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<ContactInfo> {
            return localVarFp.contactsBulkPOST(contactBulkCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Delete an contact
         * @param {string} [id] The id for the contact to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDELETE(id?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactsDELETE(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Reset avatar to the default
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDeleteAvatar(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactsDeleteAvatar(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Get a single contact
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGETById(id: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactInfo> {
            return localVarFp.contactsGETById(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary List contacts
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGETList(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactInfoListResponse> {
            return localVarFp.contactsGETList(limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary List of invited contacts
         * @param {ContactStatusPersonaFilter} [contactStatus]   all  invited  accepted  rejected
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGETRequests(contactStatus?: ContactStatusPersonaFilter, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactInfoListResponse> {
            return localVarFp.contactsGETRequests(contactStatus, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve an avatar by id
         * @param {string} id The id of the record you wish to retrieve
         * @param {AvatarType} [avatarType]   default  contact  simpleContarct  paymentCycle
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGetAvatarById(id: string, avatarType?: AvatarType, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactsGetAvatarById(id, avatarType, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create a contact record - contact invite.
         * @param {ContactInviteCreateDeets} [contactInviteCreateDeets] The contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsInvitePOST(contactInviteCreateDeets?: ContactInviteCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<ContactInfo> {
            return localVarFp.contactsInvitePOST(contactInviteCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Update a contact record - contact invite.
         * @param {string} personaId 
         * @param {ContactInviteUpdateDeets} [contactInviteUpdateDeets] The contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsInvitePut(personaId: string, contactInviteUpdateDeets?: ContactInviteUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<ContactInfo> {
            return localVarFp.contactsInvitePut(personaId, contactInviteUpdateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create a contact record
         * @param {ContactCreateDeets} [contactCreateDeets] The contact details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPOST(contactCreateDeets?: ContactCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<ContactInfo> {
            return localVarFp.contactsPOST(contactCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Search contacts in the network based on Name, KnownName, Business name or Handle              Returns a list of <span class=\"jmbr term\">EndUser_Deets</span>.</p>
         * summary Search contacts
         * @param {string} [term] The search term or keyword
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsSearch(term?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactInfoListResponse> {
            return localVarFp.contactsSearch(term, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
         * summary Upload avatar image via file
         * @param {string} id contact id
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsUpdateAvatar(id: string, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactsUpdateAvatar(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
         * summary Upload avatar via JSON body
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {AvatarBytes} [avatarBytes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsUpdateAvatarByDeets(id: string, userId?: string, avatarBytes?: AvatarBytes, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactsUpdateAvatarByDeets(id, userId, avatarBytes, options).then((request) => request(axios, basePath));
        },
        /**
         * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
         * summary Generate a new avatar image via AI prompt.
         * @param {string} id 
         * @param {AvatarPromptCreateDeets} [avatarPromptCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsUpdateAvatarByPrompt(id: string, avatarPromptCreateDeets?: AvatarPromptCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contactsUpdateAvatarByPrompt(id, avatarPromptCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve the payment acceptance status for an account
         * @param {string} [accountId] Account Id to accept payments from
         * @param {AcceptPaymentStatusEnum} [status] Accept payment status enum  pending  accepted  suspended
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptPaymentStatusByAccountId(accountId?: string, status?: AcceptPaymentStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<PaymentAcceptResponse> {
            return localVarFp.getAcceptPaymentStatusByAccountId(accountId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Reject the contact invitation
         * @param {string} id 
         * @param {ContactStatusUpdateDeets} [contactStatusUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectContactRequest(id: string, contactStatusUpdateDeets?: ContactStatusUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<ContactInfo> {
            return localVarFp.rejectContactRequest(id, contactStatusUpdateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary List requests
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestsGETList(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContactInfoListResponse> {
            return localVarFp.requestsGETList(limit, page, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactsApi - object-oriented interface
 * export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * 
     * summary Accept the contact invitation
     * @param {string} id 
     * @param {ContactStatusUpdateDeets} [contactStatusUpdateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public acceptContactRequest(id: string, contactStatusUpdateDeets?: ContactStatusUpdateDeets, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).acceptContactRequest(id, contactStatusUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Bulk add contacts
     * @param {ContactBulkCreateDeets} [contactBulkCreateDeets] All the contact details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsBulkPOST(contactBulkCreateDeets?: ContactBulkCreateDeets, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsBulkPOST(contactBulkCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Delete an contact
     * @param {string} [id] The id for the contact to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsDELETE(id?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsDELETE(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Reset avatar to the default
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsDeleteAvatar(id: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsDeleteAvatar(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Get a single contact
     * @param {string} id The id of the record you wish to retrieve
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsGETById(id: string, userId?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsGETById(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary List contacts
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsGETList(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsGETList(limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary List of invited contacts
     * @param {ContactStatusPersonaFilter} [contactStatus]   all  invited  accepted  rejected
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsGETRequests(contactStatus?: ContactStatusPersonaFilter, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsGETRequests(contactStatus, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve an avatar by id
     * @param {string} id The id of the record you wish to retrieve
     * @param {AvatarType} [avatarType]   default  contact  simpleContarct  paymentCycle
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsGetAvatarById(id: string, avatarType?: AvatarType, userId?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsGetAvatarById(id, avatarType, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create a contact record - contact invite.
     * @param {ContactInviteCreateDeets} [contactInviteCreateDeets] The contact details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsInvitePOST(contactInviteCreateDeets?: ContactInviteCreateDeets, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsInvitePOST(contactInviteCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Update a contact record - contact invite.
     * @param {string} personaId 
     * @param {ContactInviteUpdateDeets} [contactInviteUpdateDeets] The contact details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsInvitePut(personaId: string, contactInviteUpdateDeets?: ContactInviteUpdateDeets, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsInvitePut(personaId, contactInviteUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create a contact record
     * @param {ContactCreateDeets} [contactCreateDeets] The contact details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsPOST(contactCreateDeets?: ContactCreateDeets, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsPOST(contactCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Search contacts in the network based on Name, KnownName, Business name or Handle              Returns a list of <span class=\"jmbr term\">EndUser_Deets</span>.</p>
     * summary Search contacts
     * @param {string} [term] The search term or keyword
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsSearch(term?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsSearch(term, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
     * summary Upload avatar image via file
     * @param {string} id contact id
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsUpdateAvatar(id: string, file?: File, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsUpdateAvatar(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
     * summary Upload avatar via JSON body
     * @param {string} id The id of the record you wish to retrieve
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {AvatarBytes} [avatarBytes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsUpdateAvatarByDeets(id: string, userId?: string, avatarBytes?: AvatarBytes, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsUpdateAvatarByDeets(id, userId, avatarBytes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * avatar_id could be tenant.id, contact.id, work.id, project.id, team.id, etc
     * summary Generate a new avatar image via AI prompt.
     * @param {string} id 
     * @param {AvatarPromptCreateDeets} [avatarPromptCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public contactsUpdateAvatarByPrompt(id: string, avatarPromptCreateDeets?: AvatarPromptCreateDeets, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsUpdateAvatarByPrompt(id, avatarPromptCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve the payment acceptance status for an account
     * @param {string} [accountId] Account Id to accept payments from
     * @param {AcceptPaymentStatusEnum} [status] Accept payment status enum  pending  accepted  suspended
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public getAcceptPaymentStatusByAccountId(accountId?: string, status?: AcceptPaymentStatusEnum, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getAcceptPaymentStatusByAccountId(accountId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Reject the contact invitation
     * @param {string} id 
     * @param {ContactStatusUpdateDeets} [contactStatusUpdateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public rejectContactRequest(id: string, contactStatusUpdateDeets?: ContactStatusUpdateDeets, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).rejectContactRequest(id, contactStatusUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary List requests
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContactsApi
     */
    public requestsGETList(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).requestsGETList(limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContractsApi - axios parameter creator
 * export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Returns a single `Contract` object based on the specified id</p>
         * summary Retrieve a contract
         * @param {string} contractId The id of the contract you want to retrieve
         * @param {number} [revision] The optional revision number of the contract you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContractsContractIdGet: async (contractId: string, revision?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('apiContractsContractIdGet', 'contractId', contractId)
            const localVarPath = `/api/contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (revision !== undefined) {
                localVarQueryParameter['revision'] = revision;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Delete a contract
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContractsDelete: async (id?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Used to create new contracts or link to a existing contract group</p>
         * summary Create a contract
         * @param {Contract} [contract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContractsPost: async (contract?: Contract, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contract, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Update a contract
         * @param {number} [id] 
         * @param {Contract} [contract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContractsPut: async (id?: number, contract?: Contract, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contract, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve the total payments associated with a contract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractPaymentTotals: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractPaymentTotals', 'id', id)
            const localVarPath = `/api/contracts/{id}/payments/totals`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a list of all related payments
         * @param {string} id 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractPayments: async (id: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractPayments', 'id', id)
            const localVarPath = `/api/contracts/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Contracts are core to the Splits API, they contain Income              objects which have child terms used to specify the rules              of how income should be split or sent to payees.</p>
         * summary List all contracts
         * @param {boolean} [activeOnly] If set to true, then this only returns active contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsGetAll: async (activeOnly?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (activeOnly !== undefined) {
                localVarQueryParameter['activeOnly'] = activeOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsApi - functional programming interface
 * export
 */
export const ContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Returns a single `Contract` object based on the specified id</p>
         * summary Retrieve a contract
         * @param {string} contractId The id of the contract you want to retrieve
         * @param {number} [revision] The optional revision number of the contract you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiContractsContractIdGet(contractId: string, revision?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiContractsContractIdGet(contractId, revision, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.apiContractsContractIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Delete a contract
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiContractsDelete(id?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiContractsDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.apiContractsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Used to create new contracts or link to a existing contract group</p>
         * summary Create a contract
         * @param {Contract} [contract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiContractsPost(contract?: Contract, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiContractsPost(contract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.apiContractsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Update a contract
         * @param {number} [id] 
         * @param {Contract} [contract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiContractsPut(id?: number, contract?: Contract, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiContractsPut(id, contract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.apiContractsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve the total payments associated with a contract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractPaymentTotals(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractPaymentTotals(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.contractPaymentTotals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a list of all related payments
         * @param {string} id 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractPayments(id: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractPayments(id, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.contractPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Contracts are core to the Splits API, they contain Income              objects which have child terms used to specify the rules              of how income should be split or sent to payees.</p>
         * summary List all contracts
         * @param {boolean} [activeOnly] If set to true, then this only returns active contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsGetAll(activeOnly?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contract>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsGetAll(activeOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.contractsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContractsApi - factory interface
 * export
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsApiFp(configuration)
    return {
        /**
         * <p>Returns a single `Contract` object based on the specified id</p>
         * summary Retrieve a contract
         * @param {string} contractId The id of the contract you want to retrieve
         * @param {number} [revision] The optional revision number of the contract you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContractsContractIdGet(contractId: string, revision?: number, options?: RawAxiosRequestConfig): AxiosPromise<Contract> {
            return localVarFp.apiContractsContractIdGet(contractId, revision, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Delete a contract
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContractsDelete(id?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiContractsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Used to create new contracts or link to a existing contract group</p>
         * summary Create a contract
         * @param {Contract} [contract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContractsPost(contract?: Contract, options?: RawAxiosRequestConfig): AxiosPromise<Contract> {
            return localVarFp.apiContractsPost(contract, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Update a contract
         * @param {number} [id] 
         * @param {Contract} [contract] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiContractsPut(id?: number, contract?: Contract, options?: RawAxiosRequestConfig): AxiosPromise<Contract> {
            return localVarFp.apiContractsPut(id, contract, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve the total payments associated with a contract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractPaymentTotals(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleListResponse> {
            return localVarFp.contractPaymentTotals(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a list of all related payments
         * @param {string} id 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractPayments(id: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleListResponse> {
            return localVarFp.contractPayments(id, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Contracts are core to the Splits API, they contain Income              objects which have child terms used to specify the rules              of how income should be split or sent to payees.</p>
         * summary List all contracts
         * @param {boolean} [activeOnly] If set to true, then this only returns active contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsGetAll(activeOnly?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Contract>> {
            return localVarFp.contractsGetAll(activeOnly, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractsApi - object-oriented interface
 * export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
    /**
     * <p>Returns a single `Contract` object based on the specified id</p>
     * summary Retrieve a contract
     * @param {string} contractId The id of the contract you want to retrieve
     * @param {number} [revision] The optional revision number of the contract you want to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContractsApi
     */
    public apiContractsContractIdGet(contractId: string, revision?: number, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).apiContractsContractIdGet(contractId, revision, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Delete a contract
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContractsApi
     */
    public apiContractsDelete(id?: number, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).apiContractsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Used to create new contracts or link to a existing contract group</p>
     * summary Create a contract
     * @param {Contract} [contract] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContractsApi
     */
    public apiContractsPost(contract?: Contract, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).apiContractsPost(contract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Update a contract
     * @param {number} [id] 
     * @param {Contract} [contract] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContractsApi
     */
    public apiContractsPut(id?: number, contract?: Contract, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).apiContractsPut(id, contract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve the total payments associated with a contract
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContractsApi
     */
    public contractPaymentTotals(id: string, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractPaymentTotals(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a list of all related payments
     * @param {string} id 
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContractsApi
     */
    public contractPayments(id: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractPayments(id, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Contracts are core to the Splits API, they contain Income              objects which have child terms used to specify the rules              of how income should be split or sent to payees.</p>
     * summary List all contracts
     * @param {boolean} [activeOnly] If set to true, then this only returns active contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof ContractsApi
     */
    public contractsGetAll(activeOnly?: boolean, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsGetAll(activeOnly, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeadLetterQueueApi - axios parameter creator
 * export
 */
export const DeadLetterQueueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Purges messages older than the specified number of days from the dead-letter queue.
         * @param {PurgeRequestModel} [purgeRequestModel] The request model containing the number of days ago to start purging.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeadletterPurgeDlqPost: async (purgeRequestModel?: PurgeRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/deadletter/purge-dlq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(purgeRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Replays messages from the dead-letter queue based on the specified message IDs or a time range.
         * @param {ReplayRequestModel} [replayRequestModel] The request model containing the time range or specific message IDs to replay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeadletterReplayPost: async (replayRequestModel?: ReplayRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/deadletter/replay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replayRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeadLetterQueueApi - functional programming interface
 * export
 */
export const DeadLetterQueueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeadLetterQueueApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Purges messages older than the specified number of days from the dead-letter queue.
         * @param {PurgeRequestModel} [purgeRequestModel] The request model containing the number of days ago to start purging.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDeadletterPurgeDlqPost(purgeRequestModel?: PurgeRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDeadletterPurgeDlqPost(purgeRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeadLetterQueueApi.apiDeadletterPurgeDlqPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Replays messages from the dead-letter queue based on the specified message IDs or a time range.
         * @param {ReplayRequestModel} [replayRequestModel] The request model containing the time range or specific message IDs to replay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDeadletterReplayPost(replayRequestModel?: ReplayRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDeadletterReplayPost(replayRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeadLetterQueueApi.apiDeadletterReplayPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeadLetterQueueApi - factory interface
 * export
 */
export const DeadLetterQueueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeadLetterQueueApiFp(configuration)
    return {
        /**
         * 
         * summary Purges messages older than the specified number of days from the dead-letter queue.
         * @param {PurgeRequestModel} [purgeRequestModel] The request model containing the number of days ago to start purging.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeadletterPurgeDlqPost(purgeRequestModel?: PurgeRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiDeadletterPurgeDlqPost(purgeRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Replays messages from the dead-letter queue based on the specified message IDs or a time range.
         * @param {ReplayRequestModel} [replayRequestModel] The request model containing the time range or specific message IDs to replay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeadletterReplayPost(replayRequestModel?: ReplayRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiDeadletterReplayPost(replayRequestModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeadLetterQueueApi - object-oriented interface
 * export
 * @class DeadLetterQueueApi
 * @extends {BaseAPI}
 */
export class DeadLetterQueueApi extends BaseAPI {
    /**
     * 
     * summary Purges messages older than the specified number of days from the dead-letter queue.
     * @param {PurgeRequestModel} [purgeRequestModel] The request model containing the number of days ago to start purging.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof DeadLetterQueueApi
     */
    public apiDeadletterPurgeDlqPost(purgeRequestModel?: PurgeRequestModel, options?: RawAxiosRequestConfig) {
        return DeadLetterQueueApiFp(this.configuration).apiDeadletterPurgeDlqPost(purgeRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Replays messages from the dead-letter queue based on the specified message IDs or a time range.
     * @param {ReplayRequestModel} [replayRequestModel] The request model containing the time range or specific message IDs to replay.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof DeadLetterQueueApi
     */
    public apiDeadletterReplayPost(replayRequestModel?: ReplayRequestModel, options?: RawAxiosRequestConfig) {
        return DeadLetterQueueApiFp(this.configuration).apiDeadletterReplayPost(replayRequestModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DiagnosticsApi - axios parameter creator
 * export
 */
export const DiagnosticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The API ping is the simplest way to test availbility and authentcation of the Mozaic API
         * summary Simple ping test call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDiagnosticsPingGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/diagnostics/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDiagnosticsSignalRExample1Get: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/diagnostics/signal-r-example-1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDiagnosticsSignalRExample2Get: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/diagnostics/signal-r-example-2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiagnosticsApi - functional programming interface
 * export
 */
export const DiagnosticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiagnosticsApiAxiosParamCreator(configuration)
    return {
        /**
         * The API ping is the simplest way to test availbility and authentcation of the Mozaic API
         * summary Simple ping test call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDiagnosticsPingGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDiagnosticsPingGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiagnosticsApi.apiDiagnosticsPingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDiagnosticsSignalRExample1Get(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDiagnosticsSignalRExample1Get(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiagnosticsApi.apiDiagnosticsSignalRExample1Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDiagnosticsSignalRExample2Get(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDiagnosticsSignalRExample2Get(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiagnosticsApi.apiDiagnosticsSignalRExample2Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DiagnosticsApi - factory interface
 * export
 */
export const DiagnosticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiagnosticsApiFp(configuration)
    return {
        /**
         * The API ping is the simplest way to test availbility and authentcation of the Mozaic API
         * summary Simple ping test call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDiagnosticsPingGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiDiagnosticsPingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDiagnosticsSignalRExample1Get(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiDiagnosticsSignalRExample1Get(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDiagnosticsSignalRExample2Get(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiDiagnosticsSignalRExample2Get(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiagnosticsApi - object-oriented interface
 * export
 * @class DiagnosticsApi
 * @extends {BaseAPI}
 */
export class DiagnosticsApi extends BaseAPI {
    /**
     * The API ping is the simplest way to test availbility and authentcation of the Mozaic API
     * summary Simple ping test call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof DiagnosticsApi
     */
    public apiDiagnosticsPingGet(options?: RawAxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).apiDiagnosticsPingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof DiagnosticsApi
     */
    public apiDiagnosticsSignalRExample1Get(options?: RawAxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).apiDiagnosticsSignalRExample1Get(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof DiagnosticsApi
     */
    public apiDiagnosticsSignalRExample2Get(options?: RawAxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).apiDiagnosticsSignalRExample2Get(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EndUsersApi - axios parameter creator
 * export
 */
export const EndUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEndUsersBulkFilePost: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/end-users/bulk/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EndUserReadDeets} [endUserReadDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEndUsersInvitePost: async (endUserReadDeets?: EndUserReadDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/end-users/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(endUserReadDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create an end user for a tenant
         * @param {EndUserCreateDeets} [endUserCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEndUsersPost: async (endUserCreateDeets?: EndUserCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/end-users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(endUserCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndUsersApi - functional programming interface
 * export
 */
export const EndUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EndUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEndUsersBulkFilePost(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EndUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEndUsersBulkFilePost(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndUsersApi.apiEndUsersBulkFilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EndUserReadDeets} [endUserReadDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEndUsersInvitePost(endUserReadDeets?: EndUserReadDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEndUsersInvitePost(endUserReadDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndUsersApi.apiEndUsersInvitePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create an end user for a tenant
         * @param {EndUserCreateDeets} [endUserCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEndUsersPost(endUserCreateDeets?: EndUserCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEndUsersPost(endUserCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndUsersApi.apiEndUsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EndUsersApi - factory interface
 * export
 */
export const EndUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EndUsersApiFp(configuration)
    return {
        /**
         * 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEndUsersBulkFilePost(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<Array<EndUser>> {
            return localVarFp.apiEndUsersBulkFilePost(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EndUserReadDeets} [endUserReadDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEndUsersInvitePost(endUserReadDeets?: EndUserReadDeets, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.apiEndUsersInvitePost(endUserReadDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create an end user for a tenant
         * @param {EndUserCreateDeets} [endUserCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEndUsersPost(endUserCreateDeets?: EndUserCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<EndUser> {
            return localVarFp.apiEndUsersPost(endUserCreateDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EndUsersApi - object-oriented interface
 * export
 * @class EndUsersApi
 * @extends {BaseAPI}
 */
export class EndUsersApi extends BaseAPI {
    /**
     * 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof EndUsersApi
     */
    public apiEndUsersBulkFilePost(file?: File, options?: RawAxiosRequestConfig) {
        return EndUsersApiFp(this.configuration).apiEndUsersBulkFilePost(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EndUserReadDeets} [endUserReadDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof EndUsersApi
     */
    public apiEndUsersInvitePost(endUserReadDeets?: EndUserReadDeets, options?: RawAxiosRequestConfig) {
        return EndUsersApiFp(this.configuration).apiEndUsersInvitePost(endUserReadDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create an end user for a tenant
     * @param {EndUserCreateDeets} [endUserCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof EndUsersApi
     */
    public apiEndUsersPost(endUserCreateDeets?: EndUserCreateDeets, options?: RawAxiosRequestConfig) {
        return EndUsersApiFp(this.configuration).apiEndUsersPost(endUserCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 * export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Upload a file for validationa and store in blob for payouts
         * @param {string} [paymentCycleId] Include the payment cycle ID associated with the uploaded file.
         * @param {PaymentCycleFileType} [fileType] payment cycle file type.  payouts
         * @param {File} [file] file to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutsUpload: async (paymentCycleId?: string, fileType?: PaymentCycleFileType, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/files/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (paymentCycleId !== undefined) {
                localVarQueryParameter['PaymentCycleId'] = paymentCycleId;
            }

            if (fileType !== undefined) {
                localVarQueryParameter['FileType'] = fileType;
            }


            if (file !== undefined) { 
                localVarFormParams.append('File', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Upload a file for validationa and store in blob for payouts
         * @param {string} [paymentCycleId] Include the payment cycle ID associated with the uploaded file.
         * @param {PaymentCycleFileType} [fileType] payment cycle file type.  payouts
         * @param {File} [file] file to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payoutsUpload(paymentCycleId?: string, fileType?: PaymentCycleFileType, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payoutsUpload(paymentCycleId, fileType, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.payoutsUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * summary Upload a file for validationa and store in blob for payouts
         * @param {string} [paymentCycleId] Include the payment cycle ID associated with the uploaded file.
         * @param {PaymentCycleFileType} [fileType] payment cycle file type.  payouts
         * @param {File} [file] file to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutsUpload(paymentCycleId?: string, fileType?: PaymentCycleFileType, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleFile> {
            return localVarFp.payoutsUpload(paymentCycleId, fileType, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * summary Upload a file for validationa and store in blob for payouts
     * @param {string} [paymentCycleId] Include the payment cycle ID associated with the uploaded file.
     * @param {PaymentCycleFileType} [fileType] payment cycle file type.  payouts
     * @param {File} [file] file to upload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof FilesApi
     */
    public payoutsUpload(paymentCycleId?: string, fileType?: PaymentCycleFileType, file?: File, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).payoutsUpload(paymentCycleId, fileType, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IncomesApi - axios parameter creator
 * export
 */
export const IncomesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Used to create new contracts or link to a existing contract group
         * summary Create a contract
         * @param {string} id 
         * @param {string} incomeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIncomesApiContractsIdIncomesIncomeIdGet: async (id: string, incomeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIncomesApiContractsIdIncomesIncomeIdGet', 'id', id)
            // verify required parameter 'incomeId' is not null or undefined
            assertParamExists('apiIncomesApiContractsIdIncomesIncomeIdGet', 'incomeId', incomeId)
            const localVarPath = `/api/incomes/api/contracts/{id}/incomes/{incomeId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"incomeId"}}`, encodeURIComponent(String(incomeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to create new contracts or link to a existing contract group
         * summary Create a contract
         * @param {string} id 
         * @param {Income} [income] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIncomesApiContractsIdIncomesPost: async (id: string, income?: Income, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIncomesApiContractsIdIncomesPost', 'id', id)
            const localVarPath = `/api/incomes/api/contracts/{id}/incomes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(income, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IncomesApi - functional programming interface
 * export
 */
export const IncomesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IncomesApiAxiosParamCreator(configuration)
    return {
        /**
         * Used to create new contracts or link to a existing contract group
         * summary Create a contract
         * @param {string} id 
         * @param {string} incomeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIncomesApiContractsIdIncomesIncomeIdGet(id: string, incomeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Income>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIncomesApiContractsIdIncomesIncomeIdGet(id, incomeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomesApi.apiIncomesApiContractsIdIncomesIncomeIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Used to create new contracts or link to a existing contract group
         * summary Create a contract
         * @param {string} id 
         * @param {Income} [income] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIncomesApiContractsIdIncomesPost(id: string, income?: Income, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Income>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIncomesApiContractsIdIncomesPost(id, income, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncomesApi.apiIncomesApiContractsIdIncomesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IncomesApi - factory interface
 * export
 */
export const IncomesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IncomesApiFp(configuration)
    return {
        /**
         * Used to create new contracts or link to a existing contract group
         * summary Create a contract
         * @param {string} id 
         * @param {string} incomeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIncomesApiContractsIdIncomesIncomeIdGet(id: string, incomeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Income> {
            return localVarFp.apiIncomesApiContractsIdIncomesIncomeIdGet(id, incomeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to create new contracts or link to a existing contract group
         * summary Create a contract
         * @param {string} id 
         * @param {Income} [income] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIncomesApiContractsIdIncomesPost(id: string, income?: Income, options?: RawAxiosRequestConfig): AxiosPromise<Income> {
            return localVarFp.apiIncomesApiContractsIdIncomesPost(id, income, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IncomesApi - object-oriented interface
 * export
 * @class IncomesApi
 * @extends {BaseAPI}
 */
export class IncomesApi extends BaseAPI {
    /**
     * Used to create new contracts or link to a existing contract group
     * summary Create a contract
     * @param {string} id 
     * @param {string} incomeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof IncomesApi
     */
    public apiIncomesApiContractsIdIncomesIncomeIdGet(id: string, incomeId: string, options?: RawAxiosRequestConfig) {
        return IncomesApiFp(this.configuration).apiIncomesApiContractsIdIncomesIncomeIdGet(id, incomeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to create new contracts or link to a existing contract group
     * summary Create a contract
     * @param {string} id 
     * @param {Income} [income] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof IncomesApi
     */
    public apiIncomesApiContractsIdIncomesPost(id: string, income?: Income, options?: RawAxiosRequestConfig) {
        return IncomesApiFp(this.configuration).apiIncomesApiContractsIdIncomesPost(id, income, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InviteTokensApi - axios parameter creator
 * export
 */
export const InviteTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Decrypt an invite token and return information for display
         * @param {string} [token] The encrypted token value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteTokenDecryptGet: async (token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-token/decrypt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Send an invite token
         * @param {InviteSendDeets} [inviteSendDeets] The invite details, including the token value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteTokenSendPost: async (inviteSendDeets?: InviteSendDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-token/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteSendDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InviteTokensApi - functional programming interface
 * export
 */
export const InviteTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InviteTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Decrypt an invite token and return information for display
         * @param {string} [token] The encrypted token value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteTokenDecryptGet(token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteTokenDecryptGet(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteTokensApi.apiInviteTokenDecryptGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Send an invite token
         * @param {InviteSendDeets} [inviteSendDeets] The invite details, including the token value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteTokenSendPost(inviteSendDeets?: InviteSendDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteTokenSendPost(inviteSendDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteTokensApi.apiInviteTokenSendPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InviteTokensApi - factory interface
 * export
 */
export const InviteTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InviteTokensApiFp(configuration)
    return {
        /**
         * 
         * summary Decrypt an invite token and return information for display
         * @param {string} [token] The encrypted token value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteTokenDecryptGet(token?: string, options?: RawAxiosRequestConfig): AxiosPromise<InviteInfo> {
            return localVarFp.apiInviteTokenDecryptGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Send an invite token
         * @param {InviteSendDeets} [inviteSendDeets] The invite details, including the token value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteTokenSendPost(inviteSendDeets?: InviteSendDeets, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiInviteTokenSendPost(inviteSendDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InviteTokensApi - object-oriented interface
 * export
 * @class InviteTokensApi
 * @extends {BaseAPI}
 */
export class InviteTokensApi extends BaseAPI {
    /**
     * 
     * summary Decrypt an invite token and return information for display
     * @param {string} [token] The encrypted token value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof InviteTokensApi
     */
    public apiInviteTokenDecryptGet(token?: string, options?: RawAxiosRequestConfig) {
        return InviteTokensApiFp(this.configuration).apiInviteTokenDecryptGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Send an invite token
     * @param {InviteSendDeets} [inviteSendDeets] The invite details, including the token value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof InviteTokensApi
     */
    public apiInviteTokenSendPost(inviteSendDeets?: InviteSendDeets, options?: RawAxiosRequestConfig) {
        return InviteTokensApiFp(this.configuration).apiInviteTokenSendPost(inviteSendDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoicesApi - axios parameter creator
 * export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Invoices represent the lifecyle of moving funds from start to finish.              Once a <span class=\"jmbr term\">Invoice</span> completes it provides the resulting              invoices and payment ledgers for double-entry Invoiceing. Most              Invoices are single-use.</p>
         * summary Retrieve a list of Invoices
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvoicesGet: async (limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Invoice if found
         * summary Find a Invoice by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvoicesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiInvoicesIdGet', 'id', id)
            const localVarPath = `/api/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invoices are used as funding sources that are attached to Orchestrations.
         * summary Create a Invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvoicesPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Download invoice pdf
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoice: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadInvoice', 'id', id)
            const localVarPath = `/api/invoices/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Finalize draft invoive
         * @param {string} id 
         * @param {InvoiceFinalizeDeets} [invoiceFinalizeDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeInvoice: async (id: string, invoiceFinalizeDeets?: InvoiceFinalizeDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('finalizeInvoice', 'id', id)
            const localVarPath = `/api/invoices/{id}/finalize`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceFinalizeDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicePaymentDetails: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invoicePaymentDetails', 'id', id)
            const localVarPath = `/api/invoices/{id}/payment-details`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Pay finalized invoice
         * @param {string} id 
         * @param {InvoicePayDeets} [invoicePayDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payInvoice: async (id: string, invoicePayDeets?: InvoicePayDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('payInvoice', 'id', id)
            const localVarPath = `/api/invoices/{id}/pay`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoicePayDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Invoices represent the lifecyle of moving funds from start to finish.              Once a <span class=\"jmbr term\">Invoice</span> completes it provides the resulting              invoices and payment ledgers for double-entry Invoiceing. Most              Invoices are single-use.</p>
         * summary Retrieve a list of Invoices
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInvoicesGet(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInvoicesGet(limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.apiInvoicesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single Invoice if found
         * summary Find a Invoice by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInvoicesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInvoicesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.apiInvoicesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invoices are used as funding sources that are attached to Orchestrations.
         * summary Create a Invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInvoicesPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInvoicesPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.apiInvoicesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Download invoice pdf
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadInvoice(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadInvoice(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.downloadInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Finalize draft invoive
         * @param {string} id 
         * @param {InvoiceFinalizeDeets} [invoiceFinalizeDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finalizeInvoice(id: string, invoiceFinalizeDeets?: InvoiceFinalizeDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finalizeInvoice(id, invoiceFinalizeDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.finalizeInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invoicePaymentDetails(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoicePaymentDetails(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.invoicePaymentDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Pay finalized invoice
         * @param {string} id 
         * @param {InvoicePayDeets} [invoicePayDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payInvoice(id: string, invoicePayDeets?: InvoicePayDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payInvoice(id, invoicePayDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.payInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * <p>Invoices represent the lifecyle of moving funds from start to finish.              Once a <span class=\"jmbr term\">Invoice</span> completes it provides the resulting              invoices and payment ledgers for double-entry Invoiceing. Most              Invoices are single-use.</p>
         * summary Retrieve a list of Invoices
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvoicesGet(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Invoice>> {
            return localVarFp.apiInvoicesGet(limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single Invoice if found
         * summary Find a Invoice by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvoicesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Invoice> {
            return localVarFp.apiInvoicesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Invoices are used as funding sources that are attached to Orchestrations.
         * summary Create a Invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvoicesPost(options?: RawAxiosRequestConfig): AxiosPromise<Invoice> {
            return localVarFp.apiInvoicesPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Download invoice pdf
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoice(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.downloadInvoice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Finalize draft invoive
         * @param {string} id 
         * @param {InvoiceFinalizeDeets} [invoiceFinalizeDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeInvoice(id: string, invoiceFinalizeDeets?: InvoiceFinalizeDeets, options?: RawAxiosRequestConfig): AxiosPromise<Invoice> {
            return localVarFp.finalizeInvoice(id, invoiceFinalizeDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicePaymentDetails(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.invoicePaymentDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Pay finalized invoice
         * @param {string} id 
         * @param {InvoicePayDeets} [invoicePayDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payInvoice(id: string, invoicePayDeets?: InvoicePayDeets, options?: RawAxiosRequestConfig): AxiosPromise<Invoice> {
            return localVarFp.payInvoice(id, invoicePayDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * <p>Invoices represent the lifecyle of moving funds from start to finish.              Once a <span class=\"jmbr term\">Invoice</span> completes it provides the resulting              invoices and payment ledgers for double-entry Invoiceing. Most              Invoices are single-use.</p>
     * summary Retrieve a list of Invoices
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof InvoicesApi
     */
    public apiInvoicesGet(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).apiInvoicesGet(limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single Invoice if found
     * summary Find a Invoice by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof InvoicesApi
     */
    public apiInvoicesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).apiInvoicesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invoices are used as funding sources that are attached to Orchestrations.
     * summary Create a Invoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof InvoicesApi
     */
    public apiInvoicesPost(options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).apiInvoicesPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Download invoice pdf
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof InvoicesApi
     */
    public downloadInvoice(id: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).downloadInvoice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Finalize draft invoive
     * @param {string} id 
     * @param {InvoiceFinalizeDeets} [invoiceFinalizeDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof InvoicesApi
     */
    public finalizeInvoice(id: string, invoiceFinalizeDeets?: InvoiceFinalizeDeets, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).finalizeInvoice(id, invoiceFinalizeDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof InvoicesApi
     */
    public invoicePaymentDetails(id: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).invoicePaymentDetails(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Pay finalized invoice
     * @param {string} id 
     * @param {InvoicePayDeets} [invoicePayDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof InvoicesApi
     */
    public payInvoice(id: string, invoicePayDeets?: InvoicePayDeets, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).payInvoice(id, invoicePayDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Update one or many Notifications (mark as read)
         * @param {NotificationsBulkUpdateDeets} [notificationsBulkUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsBulkPut: async (notificationsBulkUpdateDeets?: NotificationsBulkUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationsBulkUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve notifications counts
         * @param {boolean} [markAsRead] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsCountGet: async (markAsRead?: boolean, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (markAsRead !== undefined) {
                localVarQueryParameter['mark_as_read'] = markAsRead;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Notifications are brief dated messages.               A <span class=\"jmbr term\">Notification</span> may be marked read or deleted</p>
         * summary Retrieve a list of Notifications
         * @param {boolean} [markAsRead] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsGet: async (markAsRead?: boolean, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (markAsRead !== undefined) {
                localVarQueryParameter['mark_as_read'] = markAsRead;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Deletes a Notification
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiNotificationsIdDelete', 'id', id)
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Update a Notification (mark as read)
         * @param {string} id 
         * @param {NotificationsUpdateDeets} [notificationsUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsIdPut: async (id: string, notificationsUpdateDeets?: NotificationsUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiNotificationsIdPut', 'id', id)
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationsUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsNotificationNegotiatePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications/notification/negotiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Update one or many Notifications (mark as read)
         * @param {NotificationsBulkUpdateDeets} [notificationsBulkUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsBulkPut(notificationsBulkUpdateDeets?: NotificationsBulkUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNotificationsBulkPut(notificationsBulkUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.apiNotificationsBulkPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve notifications counts
         * @param {boolean} [markAsRead] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsCountGet(markAsRead?: boolean, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationAggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNotificationsCountGet(markAsRead, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.apiNotificationsCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Notifications are brief dated messages.               A <span class=\"jmbr term\">Notification</span> may be marked read or deleted</p>
         * summary Retrieve a list of Notifications
         * @param {boolean} [markAsRead] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsGet(markAsRead?: boolean, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNotificationsGet(markAsRead, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.apiNotificationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Deletes a Notification
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNotificationsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.apiNotificationsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Update a Notification (mark as read)
         * @param {string} id 
         * @param {NotificationsUpdateDeets} [notificationsUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsIdPut(id: string, notificationsUpdateDeets?: NotificationsUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNotificationsIdPut(id, notificationsUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.apiNotificationsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsNotificationNegotiatePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNotificationsNotificationNegotiatePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.apiNotificationsNotificationNegotiatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * summary Update one or many Notifications (mark as read)
         * @param {NotificationsBulkUpdateDeets} [notificationsBulkUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsBulkPut(notificationsBulkUpdateDeets?: NotificationsBulkUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.apiNotificationsBulkPut(notificationsBulkUpdateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve notifications counts
         * @param {boolean} [markAsRead] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsCountGet(markAsRead?: boolean, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationAggregate> {
            return localVarFp.apiNotificationsCountGet(markAsRead, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Notifications are brief dated messages.               A <span class=\"jmbr term\">Notification</span> may be marked read or deleted</p>
         * summary Retrieve a list of Notifications
         * @param {boolean} [markAsRead] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsGet(markAsRead?: boolean, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<NotificationResponse>> {
            return localVarFp.apiNotificationsGet(markAsRead, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Deletes a Notification
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.apiNotificationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Update a Notification (mark as read)
         * @param {string} id 
         * @param {NotificationsUpdateDeets} [notificationsUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsIdPut(id: string, notificationsUpdateDeets?: NotificationsUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.apiNotificationsIdPut(id, notificationsUpdateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsNotificationNegotiatePost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiNotificationsNotificationNegotiatePost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * summary Update one or many Notifications (mark as read)
     * @param {NotificationsBulkUpdateDeets} [notificationsBulkUpdateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof NotificationsApi
     */
    public apiNotificationsBulkPut(notificationsBulkUpdateDeets?: NotificationsBulkUpdateDeets, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).apiNotificationsBulkPut(notificationsBulkUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve notifications counts
     * @param {boolean} [markAsRead] 
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof NotificationsApi
     */
    public apiNotificationsCountGet(markAsRead?: boolean, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).apiNotificationsCountGet(markAsRead, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Notifications are brief dated messages.               A <span class=\"jmbr term\">Notification</span> may be marked read or deleted</p>
     * summary Retrieve a list of Notifications
     * @param {boolean} [markAsRead] 
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof NotificationsApi
     */
    public apiNotificationsGet(markAsRead?: boolean, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).apiNotificationsGet(markAsRead, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Deletes a Notification
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof NotificationsApi
     */
    public apiNotificationsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).apiNotificationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Update a Notification (mark as read)
     * @param {string} id 
     * @param {NotificationsUpdateDeets} [notificationsUpdateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof NotificationsApi
     */
    public apiNotificationsIdPut(id: string, notificationsUpdateDeets?: NotificationsUpdateDeets, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).apiNotificationsIdPut(id, notificationsUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof NotificationsApi
     */
    public apiNotificationsNotificationNegotiatePost(options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).apiNotificationsNotificationNegotiatePost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrchestrationsApi - axios parameter creator
 * export
 */
export const OrchestrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Attach a funding source to an `Orchestration`. This defines funding origin.
         * @param {string} id The Orchestration ID
         * @param {FundingAttachDeets} [fundingAttachDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchectrationsATTACHFunding: async (id: string, fundingAttachDeets?: FundingAttachDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orchectrationsATTACHFunding', 'id', id)
            const localVarPath = `/api/orchestrations/{id}/funding/attach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fundingAttachDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Attaches a payment push to an `Orchestration` in a pending state.
         * @param {string} id The Orchestration Identifier
         * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] The payment push details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsATTACHPaymentPush: async (id: string, paymentPushCreateDeets?: PaymentPushCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orchestrationsATTACHPaymentPush', 'id', id)
            const localVarPath = `/api/orchestrations/{id}/payment-pushes/attach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentPushCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>    <span class=\"jmbr term\">Orchestrations</span> greatly simplify payment routines and              facilitate split payments. <span class=\"jmbr term\">Orchestrations</span> can import sales data, distill catalog              information, requests payments, send payouts, and automatically reconcile funding              with just a few API calls.</p>
         * summary Create an `Orchestration`
         * @param {OrchestrationCreateDeets} [orchestrationCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsCREATE: async (orchestrationCreateDeets?: OrchestrationCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/orchestrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orchestrationCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Orchestration if found
         * summary Retrieve an `Orchestration` by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsGETById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orchestrationsGETById', 'id', id)
            const localVarPath = `/api/orchestrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>An Orchestration represents the lifecycle of moving funds from start to finish.              Once an <span class=\"jmbr term\">Orchestration</span> completes, it provides the resulting              invoices and payment ledgers for double-entry accounting. </p>
         * summary Retrieve a list of `Orchestrations`
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsGETList: async (limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/orchestrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This phase behaves differently depending on the mode.
         * summary Runs the funding phase for an `Orchestration`
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsRUNFunding: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orchestrationsRUNFunding', 'id', id)
            const localVarPath = `/api/orchestrations/{id}/funding/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Runs the payments phase for the specified `Orchestration`
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsRUNPayments: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orchestrationsRUNPayments', 'id', id)
            const localVarPath = `/api/orchestrations/{id}/payments/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrchestrationsApi - functional programming interface
 * export
 */
export const OrchestrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrchestrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Attach a funding source to an `Orchestration`. This defines funding origin.
         * @param {string} id The Orchestration ID
         * @param {FundingAttachDeets} [fundingAttachDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orchectrationsATTACHFunding(id: string, fundingAttachDeets?: FundingAttachDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Orchestration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orchectrationsATTACHFunding(id, fundingAttachDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrchestrationsApi.orchectrationsATTACHFunding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Attaches a payment push to an `Orchestration` in a pending state.
         * @param {string} id The Orchestration Identifier
         * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] The payment push details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orchestrationsATTACHPaymentPush(id: string, paymentPushCreateDeets?: PaymentPushCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Orchestration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orchestrationsATTACHPaymentPush(id, paymentPushCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrchestrationsApi.orchestrationsATTACHPaymentPush']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>    <span class=\"jmbr term\">Orchestrations</span> greatly simplify payment routines and              facilitate split payments. <span class=\"jmbr term\">Orchestrations</span> can import sales data, distill catalog              information, requests payments, send payouts, and automatically reconcile funding              with just a few API calls.</p>
         * summary Create an `Orchestration`
         * @param {OrchestrationCreateDeets} [orchestrationCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orchestrationsCREATE(orchestrationCreateDeets?: OrchestrationCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Orchestration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orchestrationsCREATE(orchestrationCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrchestrationsApi.orchestrationsCREATE']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single Orchestration if found
         * summary Retrieve an `Orchestration` by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orchestrationsGETById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Orchestration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orchestrationsGETById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrchestrationsApi.orchestrationsGETById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>An Orchestration represents the lifecycle of moving funds from start to finish.              Once an <span class=\"jmbr term\">Orchestration</span> completes, it provides the resulting              invoices and payment ledgers for double-entry accounting. </p>
         * summary Retrieve a list of `Orchestrations`
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orchestrationsGETList(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Orchestration>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orchestrationsGETList(limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrchestrationsApi.orchestrationsGETList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This phase behaves differently depending on the mode.
         * summary Runs the funding phase for an `Orchestration`
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orchestrationsRUNFunding(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrchestrationRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orchestrationsRUNFunding(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrchestrationsApi.orchestrationsRUNFunding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Runs the payments phase for the specified `Orchestration`
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orchestrationsRUNPayments(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrchestrationRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orchestrationsRUNPayments(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrchestrationsApi.orchestrationsRUNPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrchestrationsApi - factory interface
 * export
 */
export const OrchestrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrchestrationsApiFp(configuration)
    return {
        /**
         * 
         * summary Attach a funding source to an `Orchestration`. This defines funding origin.
         * @param {string} id The Orchestration ID
         * @param {FundingAttachDeets} [fundingAttachDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchectrationsATTACHFunding(id: string, fundingAttachDeets?: FundingAttachDeets, options?: RawAxiosRequestConfig): AxiosPromise<Orchestration> {
            return localVarFp.orchectrationsATTACHFunding(id, fundingAttachDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Attaches a payment push to an `Orchestration` in a pending state.
         * @param {string} id The Orchestration Identifier
         * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] The payment push details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsATTACHPaymentPush(id: string, paymentPushCreateDeets?: PaymentPushCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<Orchestration> {
            return localVarFp.orchestrationsATTACHPaymentPush(id, paymentPushCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>    <span class=\"jmbr term\">Orchestrations</span> greatly simplify payment routines and              facilitate split payments. <span class=\"jmbr term\">Orchestrations</span> can import sales data, distill catalog              information, requests payments, send payouts, and automatically reconcile funding              with just a few API calls.</p>
         * summary Create an `Orchestration`
         * @param {OrchestrationCreateDeets} [orchestrationCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsCREATE(orchestrationCreateDeets?: OrchestrationCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<Orchestration> {
            return localVarFp.orchestrationsCREATE(orchestrationCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single Orchestration if found
         * summary Retrieve an `Orchestration` by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsGETById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Orchestration> {
            return localVarFp.orchestrationsGETById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>An Orchestration represents the lifecycle of moving funds from start to finish.              Once an <span class=\"jmbr term\">Orchestration</span> completes, it provides the resulting              invoices and payment ledgers for double-entry accounting. </p>
         * summary Retrieve a list of `Orchestrations`
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsGETList(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Orchestration>> {
            return localVarFp.orchestrationsGETList(limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * This phase behaves differently depending on the mode.
         * summary Runs the funding phase for an `Orchestration`
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsRUNFunding(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OrchestrationRun> {
            return localVarFp.orchestrationsRUNFunding(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Runs the payments phase for the specified `Orchestration`
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orchestrationsRUNPayments(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OrchestrationRun> {
            return localVarFp.orchestrationsRUNPayments(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrchestrationsApi - object-oriented interface
 * export
 * @class OrchestrationsApi
 * @extends {BaseAPI}
 */
export class OrchestrationsApi extends BaseAPI {
    /**
     * 
     * summary Attach a funding source to an `Orchestration`. This defines funding origin.
     * @param {string} id The Orchestration ID
     * @param {FundingAttachDeets} [fundingAttachDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof OrchestrationsApi
     */
    public orchectrationsATTACHFunding(id: string, fundingAttachDeets?: FundingAttachDeets, options?: RawAxiosRequestConfig) {
        return OrchestrationsApiFp(this.configuration).orchectrationsATTACHFunding(id, fundingAttachDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Attaches a payment push to an `Orchestration` in a pending state.
     * @param {string} id The Orchestration Identifier
     * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] The payment push details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof OrchestrationsApi
     */
    public orchestrationsATTACHPaymentPush(id: string, paymentPushCreateDeets?: PaymentPushCreateDeets, options?: RawAxiosRequestConfig) {
        return OrchestrationsApiFp(this.configuration).orchestrationsATTACHPaymentPush(id, paymentPushCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>    <span class=\"jmbr term\">Orchestrations</span> greatly simplify payment routines and              facilitate split payments. <span class=\"jmbr term\">Orchestrations</span> can import sales data, distill catalog              information, requests payments, send payouts, and automatically reconcile funding              with just a few API calls.</p>
     * summary Create an `Orchestration`
     * @param {OrchestrationCreateDeets} [orchestrationCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof OrchestrationsApi
     */
    public orchestrationsCREATE(orchestrationCreateDeets?: OrchestrationCreateDeets, options?: RawAxiosRequestConfig) {
        return OrchestrationsApiFp(this.configuration).orchestrationsCREATE(orchestrationCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single Orchestration if found
     * summary Retrieve an `Orchestration` by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof OrchestrationsApi
     */
    public orchestrationsGETById(id: string, options?: RawAxiosRequestConfig) {
        return OrchestrationsApiFp(this.configuration).orchestrationsGETById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>An Orchestration represents the lifecycle of moving funds from start to finish.              Once an <span class=\"jmbr term\">Orchestration</span> completes, it provides the resulting              invoices and payment ledgers for double-entry accounting. </p>
     * summary Retrieve a list of `Orchestrations`
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof OrchestrationsApi
     */
    public orchestrationsGETList(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return OrchestrationsApiFp(this.configuration).orchestrationsGETList(limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This phase behaves differently depending on the mode.
     * summary Runs the funding phase for an `Orchestration`
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof OrchestrationsApi
     */
    public orchestrationsRUNFunding(id: string, options?: RawAxiosRequestConfig) {
        return OrchestrationsApiFp(this.configuration).orchestrationsRUNFunding(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Runs the payments phase for the specified `Orchestration`
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof OrchestrationsApi
     */
    public orchestrationsRUNPayments(id: string, options?: RawAxiosRequestConfig) {
        return OrchestrationsApiFp(this.configuration).orchestrationsRUNPayments(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OtpApi - axios parameter creator
 * export
 */
export const OtpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Sends a one-time passcode (OTP) to the provided email address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOtpSendPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/otp/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OtpApi - functional programming interface
 * export
 */
export const OtpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OtpApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Sends a one-time passcode (OTP) to the provided email address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOtpSendPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOtpSendPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OtpApi.apiOtpSendPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OtpApi - factory interface
 * export
 */
export const OtpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OtpApiFp(configuration)
    return {
        /**
         * 
         * summary Sends a one-time passcode (OTP) to the provided email address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOtpSendPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiOtpSendPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OtpApi - object-oriented interface
 * export
 * @class OtpApi
 * @extends {BaseAPI}
 */
export class OtpApi extends BaseAPI {
    /**
     * 
     * summary Sends a one-time passcode (OTP) to the provided email address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof OtpApi
     */
    public apiOtpSendPost(options?: RawAxiosRequestConfig) {
        return OtpApiFp(this.configuration).apiOtpSendPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PayerInvitesApi - axios parameter creator
 * export
 */
export const PayerInvitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Accept payer invite
         * @param {PaymentInviteAcceptCreateDeets} [paymentInviteAcceptCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptPayerInvite: async (paymentInviteAcceptCreateDeets?: PaymentInviteAcceptCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payer-invite/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentInviteAcceptCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Get payer invite details by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayerInviteById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPayerInviteById', 'id', id)
            const localVarPath = `/api/payer-invite/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Get the current user payer profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayerInviteProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payer-invite/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a list of sent payer invites
         * @param {string} [emailAddress] 
         * @param {PayerInviteStatus} [inviteStatus]   sent  accepted  expired
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayerInvites: async (emailAddress?: string, inviteStatus?: PayerInviteStatus, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payer-invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (emailAddress !== undefined) {
                localVarQueryParameter['EmailAddress'] = emailAddress;
            }

            if (inviteStatus !== undefined) {
                localVarQueryParameter['InviteStatus'] = inviteStatus;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Send payer invite request.
         * @param {PaymentInviteCreateDeets} [paymentInviteCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayerInvite: async (paymentInviteCreateDeets?: PaymentInviteCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payer-invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentInviteCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayerInvitesApi - functional programming interface
 * export
 */
export const PayerInvitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayerInvitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Accept payer invite
         * @param {PaymentInviteAcceptCreateDeets} [paymentInviteAcceptCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptPayerInvite(paymentInviteAcceptCreateDeets?: PaymentInviteAcceptCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayerInviteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptPayerInvite(paymentInviteAcceptCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayerInvitesApi.acceptPayerInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Get payer invite details by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayerInviteById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayerInviteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayerInviteById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayerInvitesApi.getPayerInviteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Get the current user payer profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayerInviteProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayerInviteProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayerInviteProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayerInvitesApi.getPayerInviteProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a list of sent payer invites
         * @param {string} [emailAddress] 
         * @param {PayerInviteStatus} [inviteStatus]   sent  accepted  expired
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayerInvites(emailAddress?: string, inviteStatus?: PayerInviteStatus, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayerInviteResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayerInvites(emailAddress, inviteStatus, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayerInvitesApi.listPayerInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Send payer invite request.
         * @param {PaymentInviteCreateDeets} [paymentInviteCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPayerInvite(paymentInviteCreateDeets?: PaymentInviteCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayerInviteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPayerInvite(paymentInviteCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PayerInvitesApi.sendPayerInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PayerInvitesApi - factory interface
 * export
 */
export const PayerInvitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayerInvitesApiFp(configuration)
    return {
        /**
         * 
         * summary Accept payer invite
         * @param {PaymentInviteAcceptCreateDeets} [paymentInviteAcceptCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptPayerInvite(paymentInviteAcceptCreateDeets?: PaymentInviteAcceptCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<PayerInviteResponse> {
            return localVarFp.acceptPayerInvite(paymentInviteAcceptCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Get payer invite details by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayerInviteById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PayerInviteResponse> {
            return localVarFp.getPayerInviteById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Get the current user payer profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayerInviteProfile(options?: RawAxiosRequestConfig): AxiosPromise<PayerInviteProfileResponse> {
            return localVarFp.getPayerInviteProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a list of sent payer invites
         * @param {string} [emailAddress] 
         * @param {PayerInviteStatus} [inviteStatus]   sent  accepted  expired
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayerInvites(emailAddress?: string, inviteStatus?: PayerInviteStatus, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PayerInviteResponseListResponse> {
            return localVarFp.listPayerInvites(emailAddress, inviteStatus, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Send payer invite request.
         * @param {PaymentInviteCreateDeets} [paymentInviteCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayerInvite(paymentInviteCreateDeets?: PaymentInviteCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<PayerInviteResponse> {
            return localVarFp.sendPayerInvite(paymentInviteCreateDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayerInvitesApi - object-oriented interface
 * export
 * @class PayerInvitesApi
 * @extends {BaseAPI}
 */
export class PayerInvitesApi extends BaseAPI {
    /**
     * 
     * summary Accept payer invite
     * @param {PaymentInviteAcceptCreateDeets} [paymentInviteAcceptCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PayerInvitesApi
     */
    public acceptPayerInvite(paymentInviteAcceptCreateDeets?: PaymentInviteAcceptCreateDeets, options?: RawAxiosRequestConfig) {
        return PayerInvitesApiFp(this.configuration).acceptPayerInvite(paymentInviteAcceptCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Get payer invite details by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PayerInvitesApi
     */
    public getPayerInviteById(id: string, options?: RawAxiosRequestConfig) {
        return PayerInvitesApiFp(this.configuration).getPayerInviteById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Get the current user payer profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PayerInvitesApi
     */
    public getPayerInviteProfile(options?: RawAxiosRequestConfig) {
        return PayerInvitesApiFp(this.configuration).getPayerInviteProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a list of sent payer invites
     * @param {string} [emailAddress] 
     * @param {PayerInviteStatus} [inviteStatus]   sent  accepted  expired
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PayerInvitesApi
     */
    public listPayerInvites(emailAddress?: string, inviteStatus?: PayerInviteStatus, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return PayerInvitesApiFp(this.configuration).listPayerInvites(emailAddress, inviteStatus, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Send payer invite request.
     * @param {PaymentInviteCreateDeets} [paymentInviteCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PayerInvitesApi
     */
    public sendPayerInvite(paymentInviteCreateDeets?: PaymentInviteCreateDeets, options?: RawAxiosRequestConfig) {
        return PayerInvitesApiFp(this.configuration).sendPayerInvite(paymentInviteCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentCyclesApi - axios parameter creator
 * export
 */
export const PaymentCyclesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Bulk Create a payment entries for a payment cycle
         * @param {string} id 
         * @param {PaymentCycleBulkEntryCreateDeets} [paymentCycleBulkEntryCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreatePaymentCycleEntry: async (id: string, paymentCycleBulkEntryCreateDeets?: PaymentCycleBulkEntryCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bulkCreatePaymentCycleEntry', 'id', id)
            const localVarPath = `/api/payment-cycles/{id}/bulk-entry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCycleBulkEntryCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create payment cycle details
         * @param {PaymentCycleCreateDeets} [paymentCycleCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentCycle: async (paymentCycleCreateDeets?: PaymentCycleCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payment-cycles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCycleCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create a payment entry for a payment cycle
         * @param {string} id 
         * @param {PaymentCycleEntryCreateDeets} [paymentCycleEntryCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentCycleEntry: async (id: string, paymentCycleEntryCreateDeets?: PaymentCycleEntryCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPaymentCycleEntry', 'id', id)
            const localVarPath = `/api/payment-cycles/{id}/entry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCycleEntryCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Delete a payment cycle and all associated payment cycle entries.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentCycle: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePaymentCycle', 'id', id)
            const localVarPath = `/api/payment-cycles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Delete a payment entry for a payment cycle
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentCycleEntry: async (id: string, entryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePaymentCycleEntry', 'id', id)
            // verify required parameter 'entryId' is not null or undefined
            assertParamExists('deletePaymentCycleEntry', 'entryId', entryId)
            const localVarPath = `/api/payment-cycles/{id}/entry/{entry-id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"entry-id"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Finalize to generate and pay invoice
         * @param {string} id 
         * @param {PaymentCycleFinalizeDeets} [paymentCycleFinalizeDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizePaymentCycleEntry: async (id: string, paymentCycleFinalizeDeets?: PaymentCycleFinalizeDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('finalizePaymentCycleEntry', 'id', id)
            const localVarPath = `/api/payment-cycles/{id}/finalize`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCycleFinalizeDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve payment cycle details by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCycleById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPaymentCycleById', 'id', id)
            const localVarPath = `/api/payment-cycles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Get payment entry by id
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCycleEntryById: async (id: string, entryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPaymentCycleEntryById', 'id', id)
            // verify required parameter 'entryId' is not null or undefined
            assertParamExists('getPaymentCycleEntryById', 'entryId', entryId)
            const localVarPath = `/api/payment-cycles/{id}/entry/{entry-id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"entry-id"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a list of payment entries for a cycles
         * @param {string} id 
         * @param {PaymentCycleEntryStatus} [status]   draft  success  warning  error  processing
         * @param {string} [name] 
         * @param {string} [email] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentCycleEntries: async (id: string, status?: PaymentCycleEntryStatus, name?: string, email?: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listPaymentCycleEntries', 'id', id)
            const localVarPath = `/api/payment-cycles/{id}/entry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }

            if (name !== undefined) {
                localVarQueryParameter['Name'] = name;
            }

            if (email !== undefined) {
                localVarQueryParameter['Email'] = email;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a list of payments cycles
         * @param {FeeDirection} [feeDirection]   default (Use the platform default fee direction which is to the Payee)  payer (Fees are charged to the Payer)  payee (Fees are charged to the Payee)  split (Fees are split equally between Payer and Payee.   Any remaineder is paid by the Payee)
         * @param {PaymentCycleStatus} [status]   draft  locked  processing  invoicing  cancelled  completed  completedWithErrors  failed
         * @param {string} [name] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentCycles: async (feeDirection?: FeeDirection, status?: PaymentCycleStatus, name?: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payment-cycles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (feeDirection !== undefined) {
                localVarQueryParameter['FeeDirection'] = feeDirection;
            }

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }

            if (name !== undefined) {
                localVarQueryParameter['Name'] = name;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a list of all related payments
         * @param {string} id 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentCyclePayments: async (id: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentCyclePayments', 'id', id)
            const localVarPath = `/api/payment-cycles/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Delete a payment entry for a payment cycle
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentEntryAvatar: async (id: string, entryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentEntryAvatar', 'id', id)
            // verify required parameter 'entryId' is not null or undefined
            assertParamExists('paymentEntryAvatar', 'entryId', entryId)
            const localVarPath = `/api/payment-cycles/{id}/entry/{entry-id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"entry-id"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Update payment cycle details
         * @param {string} id 
         * @param {PaymentCycleUpdateDeets} [paymentCycleUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentCycle: async (id: string, paymentCycleUpdateDeets?: PaymentCycleUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePaymentCycle', 'id', id)
            const localVarPath = `/api/payment-cycles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCycleUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Update a payment entry for a payment cycle
         * @param {string} id 
         * @param {string} entryId 
         * @param {PaymentCycleEntryUpdateDeets} [paymentCycleEntryUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentCycleEntry: async (id: string, entryId: string, paymentCycleEntryUpdateDeets?: PaymentCycleEntryUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePaymentCycleEntry', 'id', id)
            // verify required parameter 'entryId' is not null or undefined
            assertParamExists('updatePaymentCycleEntry', 'entryId', entryId)
            const localVarPath = `/api/payment-cycles/{id}/entry/{entry-id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"entry-id"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCycleEntryUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentCyclesApi - functional programming interface
 * export
 */
export const PaymentCyclesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentCyclesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Bulk Create a payment entries for a payment cycle
         * @param {string} id 
         * @param {PaymentCycleBulkEntryCreateDeets} [paymentCycleBulkEntryCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkCreatePaymentCycleEntry(id: string, paymentCycleBulkEntryCreateDeets?: PaymentCycleBulkEntryCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleEntryBulkResultResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreatePaymentCycleEntry(id, paymentCycleBulkEntryCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.bulkCreatePaymentCycleEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create payment cycle details
         * @param {PaymentCycleCreateDeets} [paymentCycleCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentCycle(paymentCycleCreateDeets?: PaymentCycleCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentCycle(paymentCycleCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.createPaymentCycle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create a payment entry for a payment cycle
         * @param {string} id 
         * @param {PaymentCycleEntryCreateDeets} [paymentCycleEntryCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentCycleEntry(id: string, paymentCycleEntryCreateDeets?: PaymentCycleEntryCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentCycleEntry(id, paymentCycleEntryCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.createPaymentCycleEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Delete a payment cycle and all associated payment cycle entries.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentCycle(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogicResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentCycle(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.deletePaymentCycle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Delete a payment entry for a payment cycle
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentCycleEntry(id: string, entryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogicResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentCycleEntry(id, entryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.deletePaymentCycleEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Finalize to generate and pay invoice
         * @param {string} id 
         * @param {PaymentCycleFinalizeDeets} [paymentCycleFinalizeDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finalizePaymentCycleEntry(id: string, paymentCycleFinalizeDeets?: PaymentCycleFinalizeDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleFinalizeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finalizePaymentCycleEntry(id, paymentCycleFinalizeDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.finalizePaymentCycleEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve payment cycle details by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentCycleById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentCycleById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.getPaymentCycleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Get payment entry by id
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentCycleEntryById(id: string, entryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentCycleEntryById(id, entryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.getPaymentCycleEntryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a list of payment entries for a cycles
         * @param {string} id 
         * @param {PaymentCycleEntryStatus} [status]   draft  success  warning  error  processing
         * @param {string} [name] 
         * @param {string} [email] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaymentCycleEntries(id: string, status?: PaymentCycleEntryStatus, name?: string, email?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleEntryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentCycleEntries(id, status, name, email, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.listPaymentCycleEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a list of payments cycles
         * @param {FeeDirection} [feeDirection]   default (Use the platform default fee direction which is to the Payee)  payer (Fees are charged to the Payer)  payee (Fees are charged to the Payee)  split (Fees are split equally between Payer and Payee.   Any remaineder is paid by the Payee)
         * @param {PaymentCycleStatus} [status]   draft  locked  processing  invoicing  cancelled  completed  completedWithErrors  failed
         * @param {string} [name] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaymentCycles(feeDirection?: FeeDirection, status?: PaymentCycleStatus, name?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentCycles(feeDirection, status, name, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.listPaymentCycles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a list of all related payments
         * @param {string} id 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentCyclePayments(id: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentCyclePayments(id, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.paymentCyclePayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Delete a payment entry for a payment cycle
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentEntryAvatar(id: string, entryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentEntryAvatar(id, entryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.paymentEntryAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Update payment cycle details
         * @param {string} id 
         * @param {PaymentCycleUpdateDeets} [paymentCycleUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentCycle(id: string, paymentCycleUpdateDeets?: PaymentCycleUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentCycle(id, paymentCycleUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.updatePaymentCycle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Update a payment entry for a payment cycle
         * @param {string} id 
         * @param {string} entryId 
         * @param {PaymentCycleEntryUpdateDeets} [paymentCycleEntryUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentCycleEntry(id: string, entryId: string, paymentCycleEntryUpdateDeets?: PaymentCycleEntryUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentCycleEntry(id, entryId, paymentCycleEntryUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentCyclesApi.updatePaymentCycleEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentCyclesApi - factory interface
 * export
 */
export const PaymentCyclesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentCyclesApiFp(configuration)
    return {
        /**
         * 
         * summary Bulk Create a payment entries for a payment cycle
         * @param {string} id 
         * @param {PaymentCycleBulkEntryCreateDeets} [paymentCycleBulkEntryCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreatePaymentCycleEntry(id: string, paymentCycleBulkEntryCreateDeets?: PaymentCycleBulkEntryCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleEntryBulkResultResponseListResponse> {
            return localVarFp.bulkCreatePaymentCycleEntry(id, paymentCycleBulkEntryCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create payment cycle details
         * @param {PaymentCycleCreateDeets} [paymentCycleCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentCycle(paymentCycleCreateDeets?: PaymentCycleCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycle> {
            return localVarFp.createPaymentCycle(paymentCycleCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create a payment entry for a payment cycle
         * @param {string} id 
         * @param {PaymentCycleEntryCreateDeets} [paymentCycleEntryCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentCycleEntry(id: string, paymentCycleEntryCreateDeets?: PaymentCycleEntryCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleEntry> {
            return localVarFp.createPaymentCycleEntry(id, paymentCycleEntryCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Delete a payment cycle and all associated payment cycle entries.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentCycle(id: string, options?: RawAxiosRequestConfig): AxiosPromise<LogicResult> {
            return localVarFp.deletePaymentCycle(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Delete a payment entry for a payment cycle
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentCycleEntry(id: string, entryId: string, options?: RawAxiosRequestConfig): AxiosPromise<LogicResult> {
            return localVarFp.deletePaymentCycleEntry(id, entryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Finalize to generate and pay invoice
         * @param {string} id 
         * @param {PaymentCycleFinalizeDeets} [paymentCycleFinalizeDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizePaymentCycleEntry(id: string, paymentCycleFinalizeDeets?: PaymentCycleFinalizeDeets, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleFinalizeResponse> {
            return localVarFp.finalizePaymentCycleEntry(id, paymentCycleFinalizeDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve payment cycle details by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCycleById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycle> {
            return localVarFp.getPaymentCycleById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Get payment entry by id
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCycleEntryById(id: string, entryId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleEntry> {
            return localVarFp.getPaymentCycleEntryById(id, entryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a list of payment entries for a cycles
         * @param {string} id 
         * @param {PaymentCycleEntryStatus} [status]   draft  success  warning  error  processing
         * @param {string} [name] 
         * @param {string} [email] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentCycleEntries(id: string, status?: PaymentCycleEntryStatus, name?: string, email?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleEntryListResponse> {
            return localVarFp.listPaymentCycleEntries(id, status, name, email, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a list of payments cycles
         * @param {FeeDirection} [feeDirection]   default (Use the platform default fee direction which is to the Payee)  payer (Fees are charged to the Payer)  payee (Fees are charged to the Payee)  split (Fees are split equally between Payer and Payee.   Any remaineder is paid by the Payee)
         * @param {PaymentCycleStatus} [status]   draft  locked  processing  invoicing  cancelled  completed  completedWithErrors  failed
         * @param {string} [name] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentCycles(feeDirection?: FeeDirection, status?: PaymentCycleStatus, name?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleListResponse> {
            return localVarFp.listPaymentCycles(feeDirection, status, name, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a list of all related payments
         * @param {string} id 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentCyclePayments(id: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleListResponse> {
            return localVarFp.paymentCyclePayments(id, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Delete a payment entry for a payment cycle
         * @param {string} id 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentEntryAvatar(id: string, entryId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.paymentEntryAvatar(id, entryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Update payment cycle details
         * @param {string} id 
         * @param {PaymentCycleUpdateDeets} [paymentCycleUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentCycle(id: string, paymentCycleUpdateDeets?: PaymentCycleUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycle> {
            return localVarFp.updatePaymentCycle(id, paymentCycleUpdateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Update a payment entry for a payment cycle
         * @param {string} id 
         * @param {string} entryId 
         * @param {PaymentCycleEntryUpdateDeets} [paymentCycleEntryUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentCycleEntry(id: string, entryId: string, paymentCycleEntryUpdateDeets?: PaymentCycleEntryUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleEntry> {
            return localVarFp.updatePaymentCycleEntry(id, entryId, paymentCycleEntryUpdateDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentCyclesApi - object-oriented interface
 * export
 * @class PaymentCyclesApi
 * @extends {BaseAPI}
 */
export class PaymentCyclesApi extends BaseAPI {
    /**
     * 
     * summary Bulk Create a payment entries for a payment cycle
     * @param {string} id 
     * @param {PaymentCycleBulkEntryCreateDeets} [paymentCycleBulkEntryCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public bulkCreatePaymentCycleEntry(id: string, paymentCycleBulkEntryCreateDeets?: PaymentCycleBulkEntryCreateDeets, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).bulkCreatePaymentCycleEntry(id, paymentCycleBulkEntryCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create payment cycle details
     * @param {PaymentCycleCreateDeets} [paymentCycleCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public createPaymentCycle(paymentCycleCreateDeets?: PaymentCycleCreateDeets, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).createPaymentCycle(paymentCycleCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create a payment entry for a payment cycle
     * @param {string} id 
     * @param {PaymentCycleEntryCreateDeets} [paymentCycleEntryCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public createPaymentCycleEntry(id: string, paymentCycleEntryCreateDeets?: PaymentCycleEntryCreateDeets, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).createPaymentCycleEntry(id, paymentCycleEntryCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Delete a payment cycle and all associated payment cycle entries.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public deletePaymentCycle(id: string, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).deletePaymentCycle(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Delete a payment entry for a payment cycle
     * @param {string} id 
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public deletePaymentCycleEntry(id: string, entryId: string, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).deletePaymentCycleEntry(id, entryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Finalize to generate and pay invoice
     * @param {string} id 
     * @param {PaymentCycleFinalizeDeets} [paymentCycleFinalizeDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public finalizePaymentCycleEntry(id: string, paymentCycleFinalizeDeets?: PaymentCycleFinalizeDeets, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).finalizePaymentCycleEntry(id, paymentCycleFinalizeDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve payment cycle details by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public getPaymentCycleById(id: string, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).getPaymentCycleById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Get payment entry by id
     * @param {string} id 
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public getPaymentCycleEntryById(id: string, entryId: string, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).getPaymentCycleEntryById(id, entryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a list of payment entries for a cycles
     * @param {string} id 
     * @param {PaymentCycleEntryStatus} [status]   draft  success  warning  error  processing
     * @param {string} [name] 
     * @param {string} [email] 
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public listPaymentCycleEntries(id: string, status?: PaymentCycleEntryStatus, name?: string, email?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).listPaymentCycleEntries(id, status, name, email, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a list of payments cycles
     * @param {FeeDirection} [feeDirection]   default (Use the platform default fee direction which is to the Payee)  payer (Fees are charged to the Payer)  payee (Fees are charged to the Payee)  split (Fees are split equally between Payer and Payee.   Any remaineder is paid by the Payee)
     * @param {PaymentCycleStatus} [status]   draft  locked  processing  invoicing  cancelled  completed  completedWithErrors  failed
     * @param {string} [name] 
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public listPaymentCycles(feeDirection?: FeeDirection, status?: PaymentCycleStatus, name?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).listPaymentCycles(feeDirection, status, name, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a list of all related payments
     * @param {string} id 
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public paymentCyclePayments(id: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).paymentCyclePayments(id, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Delete a payment entry for a payment cycle
     * @param {string} id 
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public paymentEntryAvatar(id: string, entryId: string, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).paymentEntryAvatar(id, entryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Update payment cycle details
     * @param {string} id 
     * @param {PaymentCycleUpdateDeets} [paymentCycleUpdateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public updatePaymentCycle(id: string, paymentCycleUpdateDeets?: PaymentCycleUpdateDeets, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).updatePaymentCycle(id, paymentCycleUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Update a payment entry for a payment cycle
     * @param {string} id 
     * @param {string} entryId 
     * @param {PaymentCycleEntryUpdateDeets} [paymentCycleEntryUpdateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentCyclesApi
     */
    public updatePaymentCycleEntry(id: string, entryId: string, paymentCycleEntryUpdateDeets?: PaymentCycleEntryUpdateDeets, options?: RawAxiosRequestConfig) {
        return PaymentCyclesApiFp(this.configuration).updatePaymentCycleEntry(id, entryId, paymentCycleEntryUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentPushesApi - axios parameter creator
 * export
 */
export const PaymentPushesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Creates <span class=\"jmbr term\">PaymentPushes</span> in bulk, which send payments              to the specified recipients. In order to create <strong>PaymentPushes</strong> on behalf of someone other              than the logged in account the sender must be registered as a Tenant and have PaymentPush create scope.</p>  <p>Create scope permissions<c ref=\"\"></c>              for the sending user. The PaymentPush workflow is high-level payment api abstracting many details about how              The funds are flowing. For more information see <see href=\"\">Understanding Payments in Mozaic</see></p>
         * summary Create payment pushes in bulk
         * @param {PaymentPushBulkCreateDeets} [paymentPushBulkCreateDeets] PaymentPushBulk_CreateDeets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentPushesBulkPost: async (paymentPushBulkCreateDeets?: PaymentPushBulkCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payment-pushes/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentPushBulkCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentPushesFeesPost: async (paymentPushCreateDeets?: PaymentPushCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payment-pushes/fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentPushCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Creates a <span class=\"jmbr term\">PaymentPush</span> which sends a payment              to the specified recipient. In order to create <strong>PaymentPushes</strong> on behalf of someone other              than the logged in account the sender must be registered as a Tenant and have PaymentPush create scope.</p>  <p>Create scope permissions<c ref=\"\"></c>              for the sending user. The PaymentPush workflow is high-level payment api abstracting many details about how              The funds are flowing. For more information see <see href=\"\">Understanding Payments in Mozaic</see></p>
         * summary Create a PaymentPush
         * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] PaymentPush_CreateDeets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentPush: async (paymentPushCreateDeets?: PaymentPushCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payment-pushes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentPushCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Calculate fee estimates for individual transactions within a bulk payment.
         * @param {PaymentPushBulkCreateDeets} [paymentPushBulkCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkFees: async (paymentPushBulkCreateDeets?: PaymentPushBulkCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payment-pushes/fees-bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentPushBulkCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single PaymentPushCreate if found
         * summary Find a PaymentPushCreate by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentPushesById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPaymentPushesById', 'id', id)
            const localVarPath = `/api/payment-pushes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Update push payment record
         * @param {string} id 
         * @param {PaymentPushUpdateDeets} [paymentPushUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePushPayment: async (id: string, paymentPushUpdateDeets?: PaymentPushUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePushPayment', 'id', id)
            const localVarPath = `/api/payment-pushes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentPushUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentPushesApi - functional programming interface
 * export
 */
export const PaymentPushesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentPushesApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Creates <span class=\"jmbr term\">PaymentPushes</span> in bulk, which send payments              to the specified recipients. In order to create <strong>PaymentPushes</strong> on behalf of someone other              than the logged in account the sender must be registered as a Tenant and have PaymentPush create scope.</p>  <p>Create scope permissions<c ref=\"\"></c>              for the sending user. The PaymentPush workflow is high-level payment api abstracting many details about how              The funds are flowing. For more information see <see href=\"\">Understanding Payments in Mozaic</see></p>
         * summary Create payment pushes in bulk
         * @param {PaymentPushBulkCreateDeets} [paymentPushBulkCreateDeets] PaymentPushBulk_CreateDeets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentPushesBulkPost(paymentPushBulkCreateDeets?: PaymentPushBulkCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentBulkResultResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentPushesBulkPost(paymentPushBulkCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentPushesApi.apiPaymentPushesBulkPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentPushesFeesPost(paymentPushCreateDeets?: PaymentPushCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fees>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentPushesFeesPost(paymentPushCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentPushesApi.apiPaymentPushesFeesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Creates a <span class=\"jmbr term\">PaymentPush</span> which sends a payment              to the specified recipient. In order to create <strong>PaymentPushes</strong> on behalf of someone other              than the logged in account the sender must be registered as a Tenant and have PaymentPush create scope.</p>  <p>Create scope permissions<c ref=\"\"></c>              for the sending user. The PaymentPush workflow is high-level payment api abstracting many details about how              The funds are flowing. For more information see <see href=\"\">Understanding Payments in Mozaic</see></p>
         * summary Create a PaymentPush
         * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] PaymentPush_CreateDeets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentPush(paymentPushCreateDeets?: PaymentPushCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentPush(paymentPushCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentPushesApi.createPaymentPush']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Calculate fee estimates for individual transactions within a bulk payment.
         * @param {PaymentPushBulkCreateDeets} [paymentPushBulkCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBulkFees(paymentPushBulkCreateDeets?: PaymentPushBulkCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeesBulkListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBulkFees(paymentPushBulkCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentPushesApi.getBulkFees']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single PaymentPushCreate if found
         * summary Find a PaymentPushCreate by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentPushesById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentPushResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentPushesById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentPushesApi.getPaymentPushesById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Update push payment record
         * @param {string} id 
         * @param {PaymentPushUpdateDeets} [paymentPushUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePushPayment(id: string, paymentPushUpdateDeets?: PaymentPushUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePushPayment(id, paymentPushUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentPushesApi.updatePushPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentPushesApi - factory interface
 * export
 */
export const PaymentPushesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentPushesApiFp(configuration)
    return {
        /**
         * <p>Creates <span class=\"jmbr term\">PaymentPushes</span> in bulk, which send payments              to the specified recipients. In order to create <strong>PaymentPushes</strong> on behalf of someone other              than the logged in account the sender must be registered as a Tenant and have PaymentPush create scope.</p>  <p>Create scope permissions<c ref=\"\"></c>              for the sending user. The PaymentPush workflow is high-level payment api abstracting many details about how              The funds are flowing. For more information see <see href=\"\">Understanding Payments in Mozaic</see></p>
         * summary Create payment pushes in bulk
         * @param {PaymentPushBulkCreateDeets} [paymentPushBulkCreateDeets] PaymentPushBulk_CreateDeets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentPushesBulkPost(paymentPushBulkCreateDeets?: PaymentPushBulkCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<PaymentBulkResultResponseListResponse> {
            return localVarFp.apiPaymentPushesBulkPost(paymentPushBulkCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentPushesFeesPost(paymentPushCreateDeets?: PaymentPushCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<Fees> {
            return localVarFp.apiPaymentPushesFeesPost(paymentPushCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Creates a <span class=\"jmbr term\">PaymentPush</span> which sends a payment              to the specified recipient. In order to create <strong>PaymentPushes</strong> on behalf of someone other              than the logged in account the sender must be registered as a Tenant and have PaymentPush create scope.</p>  <p>Create scope permissions<c ref=\"\"></c>              for the sending user. The PaymentPush workflow is high-level payment api abstracting many details about how              The funds are flowing. For more information see <see href=\"\">Understanding Payments in Mozaic</see></p>
         * summary Create a PaymentPush
         * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] PaymentPush_CreateDeets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentPush(paymentPushCreateDeets?: PaymentPushCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.createPaymentPush(paymentPushCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Calculate fee estimates for individual transactions within a bulk payment.
         * @param {PaymentPushBulkCreateDeets} [paymentPushBulkCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkFees(paymentPushBulkCreateDeets?: PaymentPushBulkCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<FeesBulkListResponse> {
            return localVarFp.getBulkFees(paymentPushBulkCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single PaymentPushCreate if found
         * summary Find a PaymentPushCreate by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentPushesById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentPushResponse> {
            return localVarFp.getPaymentPushesById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Update push payment record
         * @param {string} id 
         * @param {PaymentPushUpdateDeets} [paymentPushUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePushPayment(id: string, paymentPushUpdateDeets?: PaymentPushUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.updatePushPayment(id, paymentPushUpdateDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentPushesApi - object-oriented interface
 * export
 * @class PaymentPushesApi
 * @extends {BaseAPI}
 */
export class PaymentPushesApi extends BaseAPI {
    /**
     * <p>Creates <span class=\"jmbr term\">PaymentPushes</span> in bulk, which send payments              to the specified recipients. In order to create <strong>PaymentPushes</strong> on behalf of someone other              than the logged in account the sender must be registered as a Tenant and have PaymentPush create scope.</p>  <p>Create scope permissions<c ref=\"\"></c>              for the sending user. The PaymentPush workflow is high-level payment api abstracting many details about how              The funds are flowing. For more information see <see href=\"\">Understanding Payments in Mozaic</see></p>
     * summary Create payment pushes in bulk
     * @param {PaymentPushBulkCreateDeets} [paymentPushBulkCreateDeets] PaymentPushBulk_CreateDeets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentPushesApi
     */
    public apiPaymentPushesBulkPost(paymentPushBulkCreateDeets?: PaymentPushBulkCreateDeets, options?: RawAxiosRequestConfig) {
        return PaymentPushesApiFp(this.configuration).apiPaymentPushesBulkPost(paymentPushBulkCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentPushesApi
     */
    public apiPaymentPushesFeesPost(paymentPushCreateDeets?: PaymentPushCreateDeets, options?: RawAxiosRequestConfig) {
        return PaymentPushesApiFp(this.configuration).apiPaymentPushesFeesPost(paymentPushCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Creates a <span class=\"jmbr term\">PaymentPush</span> which sends a payment              to the specified recipient. In order to create <strong>PaymentPushes</strong> on behalf of someone other              than the logged in account the sender must be registered as a Tenant and have PaymentPush create scope.</p>  <p>Create scope permissions<c ref=\"\"></c>              for the sending user. The PaymentPush workflow is high-level payment api abstracting many details about how              The funds are flowing. For more information see <see href=\"\">Understanding Payments in Mozaic</see></p>
     * summary Create a PaymentPush
     * @param {PaymentPushCreateDeets} [paymentPushCreateDeets] PaymentPush_CreateDeets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentPushesApi
     */
    public createPaymentPush(paymentPushCreateDeets?: PaymentPushCreateDeets, options?: RawAxiosRequestConfig) {
        return PaymentPushesApiFp(this.configuration).createPaymentPush(paymentPushCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Calculate fee estimates for individual transactions within a bulk payment.
     * @param {PaymentPushBulkCreateDeets} [paymentPushBulkCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentPushesApi
     */
    public getBulkFees(paymentPushBulkCreateDeets?: PaymentPushBulkCreateDeets, options?: RawAxiosRequestConfig) {
        return PaymentPushesApiFp(this.configuration).getBulkFees(paymentPushBulkCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single PaymentPushCreate if found
     * summary Find a PaymentPushCreate by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentPushesApi
     */
    public getPaymentPushesById(id: string, options?: RawAxiosRequestConfig) {
        return PaymentPushesApiFp(this.configuration).getPaymentPushesById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Update push payment record
     * @param {string} id 
     * @param {PaymentPushUpdateDeets} [paymentPushUpdateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentPushesApi
     */
    public updatePushPayment(id: string, paymentPushUpdateDeets?: PaymentPushUpdateDeets, options?: RawAxiosRequestConfig) {
        return PaymentPushesApiFp(this.configuration).updatePushPayment(id, paymentPushUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentTransferApi - axios parameter creator
 * export
 */
export const PaymentTransferApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Cancel pending transfer
         * @param {PaymentTransferReadDeets} [paymentTransferReadDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentTransferCancelPut: async (paymentTransferReadDeets?: PaymentTransferReadDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payment-transfer/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentTransferReadDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a payment transfer by ID
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransferDetails: async (id: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransferDetails', 'id', id)
            const localVarPath = `/api/payment-transfer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Initiate balance withdrawal
         * @param {PaymentTransferCreateDeets} [paymentTransferCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateTransfer: async (paymentTransferCreateDeets?: PaymentTransferCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payment-transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentTransferCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a list of payment transfers
         * @param {string} [status] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentTransfers: async (status?: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payment-transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentTransferApi - functional programming interface
 * export
 */
export const PaymentTransferApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentTransferApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Cancel pending transfer
         * @param {PaymentTransferReadDeets} [paymentTransferReadDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentTransferCancelPut(paymentTransferReadDeets?: PaymentTransferReadDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentTransferCancelPut(paymentTransferReadDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentTransferApi.apiPaymentTransferCancelPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a payment transfer by ID
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransferDetails(id: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransferDetails(id, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentTransferApi.getTransferDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Initiate balance withdrawal
         * @param {PaymentTransferCreateDeets} [paymentTransferCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateTransfer(paymentTransferCreateDeets?: PaymentTransferCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateTransfer(paymentTransferCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentTransferApi.initiateTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a list of payment transfers
         * @param {string} [status] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaymentTransfers(status?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTransferListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentTransfers(status, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentTransferApi.listPaymentTransfers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentTransferApi - factory interface
 * export
 */
export const PaymentTransferApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentTransferApiFp(configuration)
    return {
        /**
         * 
         * summary Cancel pending transfer
         * @param {PaymentTransferReadDeets} [paymentTransferReadDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentTransferCancelPut(paymentTransferReadDeets?: PaymentTransferReadDeets, options?: RawAxiosRequestConfig): AxiosPromise<PaymentTransfer> {
            return localVarFp.apiPaymentTransferCancelPut(paymentTransferReadDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a payment transfer by ID
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransferDetails(id: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentTransfer> {
            return localVarFp.getTransferDetails(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Initiate balance withdrawal
         * @param {PaymentTransferCreateDeets} [paymentTransferCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateTransfer(paymentTransferCreateDeets?: PaymentTransferCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<PaymentTransfer> {
            return localVarFp.initiateTransfer(paymentTransferCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a list of payment transfers
         * @param {string} [status] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentTransfers(status?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentTransferListResponse> {
            return localVarFp.listPaymentTransfers(status, limit, page, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentTransferApi - object-oriented interface
 * export
 * @class PaymentTransferApi
 * @extends {BaseAPI}
 */
export class PaymentTransferApi extends BaseAPI {
    /**
     * 
     * summary Cancel pending transfer
     * @param {PaymentTransferReadDeets} [paymentTransferReadDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentTransferApi
     */
    public apiPaymentTransferCancelPut(paymentTransferReadDeets?: PaymentTransferReadDeets, options?: RawAxiosRequestConfig) {
        return PaymentTransferApiFp(this.configuration).apiPaymentTransferCancelPut(paymentTransferReadDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a payment transfer by ID
     * @param {string} id The id of the record you wish to retrieve
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentTransferApi
     */
    public getTransferDetails(id: string, userId?: string, options?: RawAxiosRequestConfig) {
        return PaymentTransferApiFp(this.configuration).getTransferDetails(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Initiate balance withdrawal
     * @param {PaymentTransferCreateDeets} [paymentTransferCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentTransferApi
     */
    public initiateTransfer(paymentTransferCreateDeets?: PaymentTransferCreateDeets, options?: RawAxiosRequestConfig) {
        return PaymentTransferApiFp(this.configuration).initiateTransfer(paymentTransferCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a list of payment transfers
     * @param {string} [status] 
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentTransferApi
     */
    public listPaymentTransfers(status?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return PaymentTransferApiFp(this.configuration).listPaymentTransfers(status, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 * export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Cancel a payment
         * @param {PaymentCancelDeets} [paymentCancelDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsCancelPut: async (paymentCancelDeets?: PaymentCancelDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCancelDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Test method for invoice payment intent generation
         * @param {PaymentIntentRequestDeets} [paymentIntentRequestDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsCreatePaymentIntentPost: async (paymentIntentRequestDeets?: PaymentIntentRequestDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments/create-payment-intent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentIntentRequestDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a list of payments
         * @param {string} [orchestrationId] The id of the payment cycle for which to list the payments
         * @param {string} [paymentSource] 
         * @param {string} [paymentSourceId] 
         * @param {AcceptPaymentStatusEnum} [paymentAcceptStatus]   pending  accepted  suspended
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsGet: async (orchestrationId?: string, paymentSource?: string, paymentSourceId?: string, paymentAcceptStatus?: AcceptPaymentStatusEnum, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orchestrationId !== undefined) {
                localVarQueryParameter['OrchestrationId'] = orchestrationId;
            }

            if (paymentSource !== undefined) {
                localVarQueryParameter['payment_source'] = paymentSource;
            }

            if (paymentSourceId !== undefined) {
                localVarQueryParameter['payment_source_id'] = paymentSourceId;
            }

            if (paymentAcceptStatus !== undefined) {
                localVarQueryParameter['payment_accept_status'] = paymentAcceptStatus;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a true/false for any payment or contact if found
         * summary Retrieve if has any payment or contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsHasPaymentsOrContactsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments/has-payments-or-contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Updates a <span class=\"jmbr term\">Payment </span></p>
         * summary Update a Payment Details
         * @param {string} id 
         * @param {PaymentDetailsUpdateDeets} [paymentDetailsUpdateDeets] PaymentDetails_UpdateDeets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdDetailsPut: async (id: string, paymentDetailsUpdateDeets?: PaymentDetailsUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPaymentsIdDetailsPut', 'id', id)
            const localVarPath = `/api/payments/{id}/details`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentDetailsUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single payment if found
         * summary Retrieve a payment by ID
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdGet: async (id: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPaymentsIdGet', 'id', id)
            const localVarPath = `/api/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Search payments (e.g. between dates, amounts, etc.)
         * @param {number} [minAmount] The minimum amount for filtering
         * @param {number} [maxAmount] The maximum amount for filtering
         * @param {string} [fromDate] The starting date for filtering
         * @param {string} [toDate] The end date for filtering
         * @param {Array<string>} [statuses] A list of statuses for filtering
         * @param {Array<string>} [paymentTypes] A list of payment types for filtering
         * @param {string} [id] 
         * @param {string} [shortId] 
         * @param {string} [toHandle] The Mozaic handle for a contact
         * @param {string} [toEmail] The email address of the contact
         * @param {string} [toPhone] The fully qualified phone number of the contact
         * @param {string} [toName] Loosely, the name of the contact. May be changed during registration
         * @param {string} [toPersonaId] Specifies the persona associated with this contact record
         * @param {string} [toUserId] Specifies the user associated with this contact record
         * @param {string} [toUserAccountId] Specifies the user account id associated with this contact record
         * @param {string} [toId] 
         * @param {string} [toCreated] 
         * @param {string} [toShortId] 
         * @param {string} [toObjectName] The name of this object
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsSearchGet: async (minAmount?: number, maxAmount?: number, fromDate?: string, toDate?: string, statuses?: Array<string>, paymentTypes?: Array<string>, id?: string, shortId?: string, toHandle?: string, toEmail?: string, toPhone?: string, toName?: string, toPersonaId?: string, toUserId?: string, toUserAccountId?: string, toId?: string, toCreated?: string, toShortId?: string, toObjectName?: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (minAmount !== undefined) {
                localVarQueryParameter['MinAmount'] = minAmount;
            }

            if (maxAmount !== undefined) {
                localVarQueryParameter['MaxAmount'] = maxAmount;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['FromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['ToDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (statuses) {
                localVarQueryParameter['Statuses'] = statuses;
            }

            if (paymentTypes) {
                localVarQueryParameter['PaymentTypes'] = paymentTypes;
            }

            if (id !== undefined) {
                localVarQueryParameter['Id'] = id;
            }

            if (shortId !== undefined) {
                localVarQueryParameter['ShortId'] = shortId;
            }

            if (toHandle !== undefined) {
                localVarQueryParameter['To.Handle'] = toHandle;
            }

            if (toEmail !== undefined) {
                localVarQueryParameter['To.Email'] = toEmail;
            }

            if (toPhone !== undefined) {
                localVarQueryParameter['To.Phone'] = toPhone;
            }

            if (toName !== undefined) {
                localVarQueryParameter['To.Name'] = toName;
            }

            if (toPersonaId !== undefined) {
                localVarQueryParameter['To.PersonaId'] = toPersonaId;
            }

            if (toUserId !== undefined) {
                localVarQueryParameter['To.UserId'] = toUserId;
            }

            if (toUserAccountId !== undefined) {
                localVarQueryParameter['To.UserAccountId'] = toUserAccountId;
            }

            if (toId !== undefined) {
                localVarQueryParameter['To.Id'] = toId;
            }

            if (toCreated !== undefined) {
                localVarQueryParameter['To.Created'] = (toCreated as any instanceof Date) ?
                    (toCreated as any).toISOString() :
                    toCreated;
            }

            if (toShortId !== undefined) {
                localVarQueryParameter['To.ShortId'] = toShortId;
            }

            if (toObjectName !== undefined) {
                localVarQueryParameter['To.ObjectName'] = toObjectName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary List aggregated Pending or Suspended payments
         * @param {AcceptPaymentStatusEnum} [status]   pending  accepted  suspended
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingPayments: async (status?: AcceptPaymentStatusEnum, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments/pending-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary List Transaction Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionStatuses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments/statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve Customer Virtual Receiving Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualReceivingAccount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments/virtual-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Accept or Suspend payments from an account.
         * @param {PaymentAcceptDeets} [paymentAcceptDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePendingPayments: async (paymentAcceptDeets?: PaymentAcceptDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments/pending-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentAcceptDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Cancel a payment
         * @param {PaymentCancelDeets} [paymentCancelDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsCancelPut(paymentCancelDeets?: PaymentCancelDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsCancelPut(paymentCancelDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.apiPaymentsCancelPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Test method for invoice payment intent generation
         * @param {PaymentIntentRequestDeets} [paymentIntentRequestDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsCreatePaymentIntentPost(paymentIntentRequestDeets?: PaymentIntentRequestDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsCreatePaymentIntentPost(paymentIntentRequestDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.apiPaymentsCreatePaymentIntentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a list of payments
         * @param {string} [orchestrationId] The id of the payment cycle for which to list the payments
         * @param {string} [paymentSource] 
         * @param {string} [paymentSourceId] 
         * @param {AcceptPaymentStatusEnum} [paymentAcceptStatus]   pending  accepted  suspended
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsGet(orchestrationId?: string, paymentSource?: string, paymentSourceId?: string, paymentAcceptStatus?: AcceptPaymentStatusEnum, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsGet(orchestrationId, paymentSource, paymentSourceId, paymentAcceptStatus, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.apiPaymentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a true/false for any payment or contact if found
         * summary Retrieve if has any payment or contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsHasPaymentsOrContactsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsHasPaymentsOrContactsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.apiPaymentsHasPaymentsOrContactsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Updates a <span class=\"jmbr term\">Payment </span></p>
         * summary Update a Payment Details
         * @param {string} id 
         * @param {PaymentDetailsUpdateDeets} [paymentDetailsUpdateDeets] PaymentDetails_UpdateDeets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsIdDetailsPut(id: string, paymentDetailsUpdateDeets?: PaymentDetailsUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsIdDetailsPut(id, paymentDetailsUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.apiPaymentsIdDetailsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single payment if found
         * summary Retrieve a payment by ID
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsIdGet(id: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsIdGet(id, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.apiPaymentsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Search payments (e.g. between dates, amounts, etc.)
         * @param {number} [minAmount] The minimum amount for filtering
         * @param {number} [maxAmount] The maximum amount for filtering
         * @param {string} [fromDate] The starting date for filtering
         * @param {string} [toDate] The end date for filtering
         * @param {Array<string>} [statuses] A list of statuses for filtering
         * @param {Array<string>} [paymentTypes] A list of payment types for filtering
         * @param {string} [id] 
         * @param {string} [shortId] 
         * @param {string} [toHandle] The Mozaic handle for a contact
         * @param {string} [toEmail] The email address of the contact
         * @param {string} [toPhone] The fully qualified phone number of the contact
         * @param {string} [toName] Loosely, the name of the contact. May be changed during registration
         * @param {string} [toPersonaId] Specifies the persona associated with this contact record
         * @param {string} [toUserId] Specifies the user associated with this contact record
         * @param {string} [toUserAccountId] Specifies the user account id associated with this contact record
         * @param {string} [toId] 
         * @param {string} [toCreated] 
         * @param {string} [toShortId] 
         * @param {string} [toObjectName] The name of this object
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsSearchGet(minAmount?: number, maxAmount?: number, fromDate?: string, toDate?: string, statuses?: Array<string>, paymentTypes?: Array<string>, id?: string, shortId?: string, toHandle?: string, toEmail?: string, toPhone?: string, toName?: string, toPersonaId?: string, toUserId?: string, toUserAccountId?: string, toId?: string, toCreated?: string, toShortId?: string, toObjectName?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsSearchGet(minAmount, maxAmount, fromDate, toDate, statuses, paymentTypes, id, shortId, toHandle, toEmail, toPhone, toName, toPersonaId, toUserId, toUserAccountId, toId, toCreated, toShortId, toObjectName, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.apiPaymentsSearchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary List aggregated Pending or Suspended payments
         * @param {AcceptPaymentStatusEnum} [status]   pending  accepted  suspended
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingPayments(status?: AcceptPaymentStatusEnum, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaPendingPaymentsResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingPayments(status, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.getPendingPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary List Transaction Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionStatuses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionStatuses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.getTransactionStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve Customer Virtual Receiving Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualReceivingAccount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualReceivingAccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualReceivingAccount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.getVirtualReceivingAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Accept or Suspend payments from an account.
         * @param {PaymentAcceptDeets} [paymentAcceptDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePendingPayments(paymentAcceptDeets?: PaymentAcceptDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePendingPayments(paymentAcceptDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.updatePendingPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * 
         * summary Cancel a payment
         * @param {PaymentCancelDeets} [paymentCancelDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsCancelPut(paymentCancelDeets?: PaymentCancelDeets, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.apiPaymentsCancelPut(paymentCancelDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Test method for invoice payment intent generation
         * @param {PaymentIntentRequestDeets} [paymentIntentRequestDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsCreatePaymentIntentPost(paymentIntentRequestDeets?: PaymentIntentRequestDeets, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiPaymentsCreatePaymentIntentPost(paymentIntentRequestDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a list of payments
         * @param {string} [orchestrationId] The id of the payment cycle for which to list the payments
         * @param {string} [paymentSource] 
         * @param {string} [paymentSourceId] 
         * @param {AcceptPaymentStatusEnum} [paymentAcceptStatus]   pending  accepted  suspended
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsGet(orchestrationId?: string, paymentSource?: string, paymentSourceId?: string, paymentAcceptStatus?: AcceptPaymentStatusEnum, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentListResponse> {
            return localVarFp.apiPaymentsGet(orchestrationId, paymentSource, paymentSourceId, paymentAcceptStatus, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a true/false for any payment or contact if found
         * summary Retrieve if has any payment or contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsHasPaymentsOrContactsGet(options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.apiPaymentsHasPaymentsOrContactsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Updates a <span class=\"jmbr term\">Payment </span></p>
         * summary Update a Payment Details
         * @param {string} id 
         * @param {PaymentDetailsUpdateDeets} [paymentDetailsUpdateDeets] PaymentDetails_UpdateDeets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdDetailsPut(id: string, paymentDetailsUpdateDeets?: PaymentDetailsUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.apiPaymentsIdDetailsPut(id, paymentDetailsUpdateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single payment if found
         * summary Retrieve a payment by ID
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsIdGet(id: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.apiPaymentsIdGet(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Search payments (e.g. between dates, amounts, etc.)
         * @param {number} [minAmount] The minimum amount for filtering
         * @param {number} [maxAmount] The maximum amount for filtering
         * @param {string} [fromDate] The starting date for filtering
         * @param {string} [toDate] The end date for filtering
         * @param {Array<string>} [statuses] A list of statuses for filtering
         * @param {Array<string>} [paymentTypes] A list of payment types for filtering
         * @param {string} [id] 
         * @param {string} [shortId] 
         * @param {string} [toHandle] The Mozaic handle for a contact
         * @param {string} [toEmail] The email address of the contact
         * @param {string} [toPhone] The fully qualified phone number of the contact
         * @param {string} [toName] Loosely, the name of the contact. May be changed during registration
         * @param {string} [toPersonaId] Specifies the persona associated with this contact record
         * @param {string} [toUserId] Specifies the user associated with this contact record
         * @param {string} [toUserAccountId] Specifies the user account id associated with this contact record
         * @param {string} [toId] 
         * @param {string} [toCreated] 
         * @param {string} [toShortId] 
         * @param {string} [toObjectName] The name of this object
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsSearchGet(minAmount?: number, maxAmount?: number, fromDate?: string, toDate?: string, statuses?: Array<string>, paymentTypes?: Array<string>, id?: string, shortId?: string, toHandle?: string, toEmail?: string, toPhone?: string, toName?: string, toPersonaId?: string, toUserId?: string, toUserAccountId?: string, toId?: string, toCreated?: string, toShortId?: string, toObjectName?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentListResponse> {
            return localVarFp.apiPaymentsSearchGet(minAmount, maxAmount, fromDate, toDate, statuses, paymentTypes, id, shortId, toHandle, toEmail, toPhone, toName, toPersonaId, toUserId, toUserAccountId, toId, toCreated, toShortId, toObjectName, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary List aggregated Pending or Suspended payments
         * @param {AcceptPaymentStatusEnum} [status]   pending  accepted  suspended
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingPayments(status?: AcceptPaymentStatusEnum, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PersonaPendingPaymentsResponseListResponse> {
            return localVarFp.getPendingPayments(status, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary List Transaction Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionStatuses(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getTransactionStatuses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve Customer Virtual Receiving Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualReceivingAccount(options?: RawAxiosRequestConfig): AxiosPromise<VirtualReceivingAccountInfo> {
            return localVarFp.getVirtualReceivingAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Accept or Suspend payments from an account.
         * @param {PaymentAcceptDeets} [paymentAcceptDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePendingPayments(paymentAcceptDeets?: PaymentAcceptDeets, options?: RawAxiosRequestConfig): AxiosPromise<Payment> {
            return localVarFp.updatePendingPayments(paymentAcceptDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * 
     * summary Cancel a payment
     * @param {PaymentCancelDeets} [paymentCancelDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentsApi
     */
    public apiPaymentsCancelPut(paymentCancelDeets?: PaymentCancelDeets, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).apiPaymentsCancelPut(paymentCancelDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Test method for invoice payment intent generation
     * @param {PaymentIntentRequestDeets} [paymentIntentRequestDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentsApi
     */
    public apiPaymentsCreatePaymentIntentPost(paymentIntentRequestDeets?: PaymentIntentRequestDeets, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).apiPaymentsCreatePaymentIntentPost(paymentIntentRequestDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a list of payments
     * @param {string} [orchestrationId] The id of the payment cycle for which to list the payments
     * @param {string} [paymentSource] 
     * @param {string} [paymentSourceId] 
     * @param {AcceptPaymentStatusEnum} [paymentAcceptStatus]   pending  accepted  suspended
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentsApi
     */
    public apiPaymentsGet(orchestrationId?: string, paymentSource?: string, paymentSourceId?: string, paymentAcceptStatus?: AcceptPaymentStatusEnum, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).apiPaymentsGet(orchestrationId, paymentSource, paymentSourceId, paymentAcceptStatus, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a true/false for any payment or contact if found
     * summary Retrieve if has any payment or contact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentsApi
     */
    public apiPaymentsHasPaymentsOrContactsGet(options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).apiPaymentsHasPaymentsOrContactsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Updates a <span class=\"jmbr term\">Payment </span></p>
     * summary Update a Payment Details
     * @param {string} id 
     * @param {PaymentDetailsUpdateDeets} [paymentDetailsUpdateDeets] PaymentDetails_UpdateDeets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentsApi
     */
    public apiPaymentsIdDetailsPut(id: string, paymentDetailsUpdateDeets?: PaymentDetailsUpdateDeets, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).apiPaymentsIdDetailsPut(id, paymentDetailsUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single payment if found
     * summary Retrieve a payment by ID
     * @param {string} id The id of the record you wish to retrieve
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentsApi
     */
    public apiPaymentsIdGet(id: string, userId?: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).apiPaymentsIdGet(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Search payments (e.g. between dates, amounts, etc.)
     * @param {number} [minAmount] The minimum amount for filtering
     * @param {number} [maxAmount] The maximum amount for filtering
     * @param {string} [fromDate] The starting date for filtering
     * @param {string} [toDate] The end date for filtering
     * @param {Array<string>} [statuses] A list of statuses for filtering
     * @param {Array<string>} [paymentTypes] A list of payment types for filtering
     * @param {string} [id] 
     * @param {string} [shortId] 
     * @param {string} [toHandle] The Mozaic handle for a contact
     * @param {string} [toEmail] The email address of the contact
     * @param {string} [toPhone] The fully qualified phone number of the contact
     * @param {string} [toName] Loosely, the name of the contact. May be changed during registration
     * @param {string} [toPersonaId] Specifies the persona associated with this contact record
     * @param {string} [toUserId] Specifies the user associated with this contact record
     * @param {string} [toUserAccountId] Specifies the user account id associated with this contact record
     * @param {string} [toId] 
     * @param {string} [toCreated] 
     * @param {string} [toShortId] 
     * @param {string} [toObjectName] The name of this object
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentsApi
     */
    public apiPaymentsSearchGet(minAmount?: number, maxAmount?: number, fromDate?: string, toDate?: string, statuses?: Array<string>, paymentTypes?: Array<string>, id?: string, shortId?: string, toHandle?: string, toEmail?: string, toPhone?: string, toName?: string, toPersonaId?: string, toUserId?: string, toUserAccountId?: string, toId?: string, toCreated?: string, toShortId?: string, toObjectName?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).apiPaymentsSearchGet(minAmount, maxAmount, fromDate, toDate, statuses, paymentTypes, id, shortId, toHandle, toEmail, toPhone, toName, toPersonaId, toUserId, toUserAccountId, toId, toCreated, toShortId, toObjectName, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary List aggregated Pending or Suspended payments
     * @param {AcceptPaymentStatusEnum} [status]   pending  accepted  suspended
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentsApi
     */
    public getPendingPayments(status?: AcceptPaymentStatusEnum, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getPendingPayments(status, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary List Transaction Statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentsApi
     */
    public getTransactionStatuses(options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getTransactionStatuses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve Customer Virtual Receiving Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentsApi
     */
    public getVirtualReceivingAccount(options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getVirtualReceivingAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Accept or Suspend payments from an account.
     * @param {PaymentAcceptDeets} [paymentAcceptDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PaymentsApi
     */
    public updatePendingPayments(paymentAcceptDeets?: PaymentAcceptDeets, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).updatePendingPayments(paymentAcceptDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionsApi - axios parameter creator
 * export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Use these permissions to set visibility of UI componets only. Any user input to a back end service should not be trusted.</p>
         * summary List all permissions for the current user
         * @param {boolean} [useCache] Defaults to true. If true, then use a five minute cache.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsGet: async (useCache?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (useCache !== undefined) {
                localVarQueryParameter['useCache'] = useCache;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Use these permissions to set visibility of UI componets only. Any user input to a back end service should not be trusted.</p>
         * summary List all permissions for the current user
         * @param {boolean} [useCache] Defaults to true. If true, then use a five minute cache.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionsGet(useCache?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionsGet(useCache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * <p>Use these permissions to set visibility of UI componets only. Any user input to a back end service should not be trusted.</p>
         * summary List all permissions for the current user
         * @param {boolean} [useCache] Defaults to true. If true, then use a five minute cache.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsGet(useCache?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.permissionsGet(useCache, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * <p>Use these permissions to set visibility of UI componets only. Any user input to a back end service should not be trusted.</p>
     * summary List all permissions for the current user
     * @param {boolean} [useCache] Defaults to true. If true, then use a five minute cache.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PermissionsApi
     */
    public permissionsGet(useCache?: boolean, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionsGet(useCache, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PortfolioApi - axios parameter creator
 * export
 */
export const PortfolioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Create a PortfolioCatalog
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the catalog  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of catalog, such as album, video channel, shopping category, etc.
         * @param {string} [subType] The sub type of catalog
         * @param {boolean} [explicit] True if the catalog content is deemed explicit, otherwise false
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {string} [partitionKey] 
         * @param {string} [accountId] Tenant account ID
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCatalog: async (externalId?: string, title?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, partitionKey?: string, accountId?: string, importExternalImages?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/portfolio/catalogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (externalId !== undefined) {
                localVarQueryParameter['ExternalId'] = externalId;
            }

            if (title !== undefined) {
                localVarQueryParameter['Title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['Description'] = description;
            }

            if (details !== undefined) {
                for (const [key, value] of Object.entries(details)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (href !== undefined) {
                localVarQueryParameter['Href'] = href;
            }

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (subType !== undefined) {
                localVarQueryParameter['SubType'] = subType;
            }

            if (explicit !== undefined) {
                localVarQueryParameter['Explicit'] = explicit;
            }

            if (minimumAgeRequirement !== undefined) {
                localVarQueryParameter['MinimumAgeRequirement'] = minimumAgeRequirement;
            }

            if (catalogs) {
                localVarQueryParameter['Catalogs'] = catalogs;
            }

            if (externalUrls !== undefined) {
                for (const [key, value] of Object.entries(externalUrls)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (externalImages) {
                localVarQueryParameter['ExternalImages'] = externalImages;
            }

            if (attributions) {
                localVarQueryParameter['Attributions'] = attributions;
            }

            if (partitionKey !== undefined) {
                localVarQueryParameter['PartitionKey'] = partitionKey;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['AccountId'] = accountId;
            }

            if (importExternalImages !== undefined) {
                localVarQueryParameter['ImportExternalImages'] = importExternalImages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create a PortfolioItem
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
         * @param {string} [addressAddress1] Address line 1
         * @param {string} [addressAddress2] Address line 2
         * @param {string} [addressCityName] City name
         * @param {string} [addressGeoPoint] Latitude and Longitude
         * @param {number} [addressRegionId] 
         * @param {string} [addressPostalCode] Postal code or ZIP code
         * @param {string} [addressRegionName] State, region or province
         * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
         * @param {number} [durationMilliseconds] Duration in ms
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {string} [partitionKey] 
         * @param {string} [accountId] Tenant account ID
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem: async (externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, partitionKey?: string, accountId?: string, importExternalImages?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/portfolio/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (externalId !== undefined) {
                localVarQueryParameter['ExternalId'] = externalId;
            }

            if (title !== undefined) {
                localVarQueryParameter['Title'] = title;
            }

            if (addressCommonName !== undefined) {
                localVarQueryParameter['Address.CommonName'] = addressCommonName;
            }

            if (addressAddress1 !== undefined) {
                localVarQueryParameter['Address.Address1'] = addressAddress1;
            }

            if (addressAddress2 !== undefined) {
                localVarQueryParameter['Address.Address2'] = addressAddress2;
            }

            if (addressCityName !== undefined) {
                localVarQueryParameter['Address.CityName'] = addressCityName;
            }

            if (addressGeoPoint !== undefined) {
                localVarQueryParameter['Address.GeoPoint'] = addressGeoPoint;
            }

            if (addressRegionId !== undefined) {
                localVarQueryParameter['Address.RegionId'] = addressRegionId;
            }

            if (addressPostalCode !== undefined) {
                localVarQueryParameter['Address.PostalCode'] = addressPostalCode;
            }

            if (addressRegionName !== undefined) {
                localVarQueryParameter['Address.RegionName'] = addressRegionName;
            }

            if (addressCountryCode !== undefined) {
                localVarQueryParameter['Address.CountryCode'] = addressCountryCode;
            }

            if (description !== undefined) {
                localVarQueryParameter['Description'] = description;
            }

            if (details !== undefined) {
                for (const [key, value] of Object.entries(details)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (href !== undefined) {
                localVarQueryParameter['Href'] = href;
            }

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (subType !== undefined) {
                localVarQueryParameter['SubType'] = subType;
            }

            if (explicit !== undefined) {
                localVarQueryParameter['Explicit'] = explicit;
            }

            if (durationMilliseconds !== undefined) {
                localVarQueryParameter['DurationMilliseconds'] = durationMilliseconds;
            }

            if (minimumAgeRequirement !== undefined) {
                localVarQueryParameter['MinimumAgeRequirement'] = minimumAgeRequirement;
            }

            if (catalogs) {
                localVarQueryParameter['Catalogs'] = catalogs;
            }

            if (externalUrls !== undefined) {
                for (const [key, value] of Object.entries(externalUrls)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (externalImages) {
                localVarQueryParameter['ExternalImages'] = externalImages;
            }

            if (attributions) {
                localVarQueryParameter['Attributions'] = attributions;
            }

            if (partitionKey !== undefined) {
                localVarQueryParameter['PartitionKey'] = partitionKey;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['AccountId'] = accountId;
            }

            if (importExternalImages !== undefined) {
                localVarQueryParameter['ImportExternalImages'] = importExternalImages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a list of PortfolioCatalogs
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogs: async (limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/portfolio/catalogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a list of PortfolioItems
         * @param {string} [keywords] 
         * @param {string} [channelId] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems: async (keywords?: string, channelId?: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/portfolio/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keywords !== undefined) {
                localVarQueryParameter['Keywords'] = keywords;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['ChannelId'] = channelId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create or update an PortfolioCatalog
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
         * @param {string} [addressAddress1] Address line 1
         * @param {string} [addressAddress2] Address line 2
         * @param {string} [addressCityName] City name
         * @param {string} [addressGeoPoint] Latitude and Longitude
         * @param {number} [addressRegionId] 
         * @param {string} [addressPostalCode] Postal code or ZIP code
         * @param {string} [addressRegionName] State, region or province
         * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
         * @param {number} [durationMilliseconds] Duration in ms
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCatalog: async (id: string, externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, importExternalImages?: boolean, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCatalog', 'id', id)
            const localVarPath = `/api/portfolio/catalogs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (externalId !== undefined) {
                localVarQueryParameter['ExternalId'] = externalId;
            }

            if (title !== undefined) {
                localVarQueryParameter['Title'] = title;
            }

            if (addressCommonName !== undefined) {
                localVarQueryParameter['Address.CommonName'] = addressCommonName;
            }

            if (addressAddress1 !== undefined) {
                localVarQueryParameter['Address.Address1'] = addressAddress1;
            }

            if (addressAddress2 !== undefined) {
                localVarQueryParameter['Address.Address2'] = addressAddress2;
            }

            if (addressCityName !== undefined) {
                localVarQueryParameter['Address.CityName'] = addressCityName;
            }

            if (addressGeoPoint !== undefined) {
                localVarQueryParameter['Address.GeoPoint'] = addressGeoPoint;
            }

            if (addressRegionId !== undefined) {
                localVarQueryParameter['Address.RegionId'] = addressRegionId;
            }

            if (addressPostalCode !== undefined) {
                localVarQueryParameter['Address.PostalCode'] = addressPostalCode;
            }

            if (addressRegionName !== undefined) {
                localVarQueryParameter['Address.RegionName'] = addressRegionName;
            }

            if (addressCountryCode !== undefined) {
                localVarQueryParameter['Address.CountryCode'] = addressCountryCode;
            }

            if (description !== undefined) {
                localVarQueryParameter['Description'] = description;
            }

            if (details !== undefined) {
                for (const [key, value] of Object.entries(details)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (href !== undefined) {
                localVarQueryParameter['Href'] = href;
            }

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (subType !== undefined) {
                localVarQueryParameter['SubType'] = subType;
            }

            if (explicit !== undefined) {
                localVarQueryParameter['Explicit'] = explicit;
            }

            if (durationMilliseconds !== undefined) {
                localVarQueryParameter['DurationMilliseconds'] = durationMilliseconds;
            }

            if (minimumAgeRequirement !== undefined) {
                localVarQueryParameter['MinimumAgeRequirement'] = minimumAgeRequirement;
            }

            if (externalUrls !== undefined) {
                for (const [key, value] of Object.entries(externalUrls)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (externalImages) {
                localVarQueryParameter['ExternalImages'] = externalImages;
            }

            if (attributions) {
                localVarQueryParameter['Attributions'] = attributions;
            }

            if (importExternalImages !== undefined) {
                localVarQueryParameter['ImportExternalImages'] = importExternalImages;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create or update an PortfolioItem
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
         * @param {string} [addressAddress1] Address line 1
         * @param {string} [addressAddress2] Address line 2
         * @param {string} [addressCityName] City name
         * @param {string} [addressGeoPoint] Latitude and Longitude
         * @param {number} [addressRegionId] 
         * @param {string} [addressPostalCode] Postal code or ZIP code
         * @param {string} [addressRegionName] State, region or province
         * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
         * @param {number} [durationMilliseconds] Duration in ms
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (id: string, externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, importExternalImages?: boolean, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateItem', 'id', id)
            const localVarPath = `/api/portfolio/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (externalId !== undefined) {
                localVarQueryParameter['ExternalId'] = externalId;
            }

            if (title !== undefined) {
                localVarQueryParameter['Title'] = title;
            }

            if (addressCommonName !== undefined) {
                localVarQueryParameter['Address.CommonName'] = addressCommonName;
            }

            if (addressAddress1 !== undefined) {
                localVarQueryParameter['Address.Address1'] = addressAddress1;
            }

            if (addressAddress2 !== undefined) {
                localVarQueryParameter['Address.Address2'] = addressAddress2;
            }

            if (addressCityName !== undefined) {
                localVarQueryParameter['Address.CityName'] = addressCityName;
            }

            if (addressGeoPoint !== undefined) {
                localVarQueryParameter['Address.GeoPoint'] = addressGeoPoint;
            }

            if (addressRegionId !== undefined) {
                localVarQueryParameter['Address.RegionId'] = addressRegionId;
            }

            if (addressPostalCode !== undefined) {
                localVarQueryParameter['Address.PostalCode'] = addressPostalCode;
            }

            if (addressRegionName !== undefined) {
                localVarQueryParameter['Address.RegionName'] = addressRegionName;
            }

            if (addressCountryCode !== undefined) {
                localVarQueryParameter['Address.CountryCode'] = addressCountryCode;
            }

            if (description !== undefined) {
                localVarQueryParameter['Description'] = description;
            }

            if (details !== undefined) {
                for (const [key, value] of Object.entries(details)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (href !== undefined) {
                localVarQueryParameter['Href'] = href;
            }

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (subType !== undefined) {
                localVarQueryParameter['SubType'] = subType;
            }

            if (explicit !== undefined) {
                localVarQueryParameter['Explicit'] = explicit;
            }

            if (durationMilliseconds !== undefined) {
                localVarQueryParameter['DurationMilliseconds'] = durationMilliseconds;
            }

            if (minimumAgeRequirement !== undefined) {
                localVarQueryParameter['MinimumAgeRequirement'] = minimumAgeRequirement;
            }

            if (catalogs) {
                localVarQueryParameter['Catalogs'] = catalogs;
            }

            if (externalUrls !== undefined) {
                for (const [key, value] of Object.entries(externalUrls)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (externalImages) {
                localVarQueryParameter['ExternalImages'] = externalImages;
            }

            if (attributions) {
                localVarQueryParameter['Attributions'] = attributions;
            }

            if (importExternalImages !== undefined) {
                localVarQueryParameter['ImportExternalImages'] = importExternalImages;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioApi - functional programming interface
 * export
 */
export const PortfolioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortfolioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Create a PortfolioCatalog
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the catalog  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of catalog, such as album, video channel, shopping category, etc.
         * @param {string} [subType] The sub type of catalog
         * @param {boolean} [explicit] True if the catalog content is deemed explicit, otherwise false
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {string} [partitionKey] 
         * @param {string} [accountId] Tenant account ID
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCatalog(externalId?: string, title?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, partitionKey?: string, accountId?: string, importExternalImages?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioCatalog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCatalog(externalId, title, description, details, href, type, subType, explicit, minimumAgeRequirement, catalogs, externalUrls, externalImages, attributions, partitionKey, accountId, importExternalImages, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioApi.createCatalog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create a PortfolioItem
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
         * @param {string} [addressAddress1] Address line 1
         * @param {string} [addressAddress2] Address line 2
         * @param {string} [addressCityName] City name
         * @param {string} [addressGeoPoint] Latitude and Longitude
         * @param {number} [addressRegionId] 
         * @param {string} [addressPostalCode] Postal code or ZIP code
         * @param {string} [addressRegionName] State, region or province
         * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
         * @param {number} [durationMilliseconds] Duration in ms
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {string} [partitionKey] 
         * @param {string} [accountId] Tenant account ID
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItem(externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, partitionKey?: string, accountId?: string, importExternalImages?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItem(externalId, title, addressCommonName, addressAddress1, addressAddress2, addressCityName, addressGeoPoint, addressRegionId, addressPostalCode, addressRegionName, addressCountryCode, description, details, href, type, subType, explicit, durationMilliseconds, minimumAgeRequirement, catalogs, externalUrls, externalImages, attributions, partitionKey, accountId, importExternalImages, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioApi.createItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a list of PortfolioCatalogs
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogs(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioCatalogListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogs(limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioApi.getCatalogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a list of PortfolioItems
         * @param {string} [keywords] 
         * @param {string} [channelId] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItems(keywords?: string, channelId?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItemListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItems(keywords, channelId, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioApi.getItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create or update an PortfolioCatalog
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
         * @param {string} [addressAddress1] Address line 1
         * @param {string} [addressAddress2] Address line 2
         * @param {string} [addressCityName] City name
         * @param {string} [addressGeoPoint] Latitude and Longitude
         * @param {number} [addressRegionId] 
         * @param {string} [addressPostalCode] Postal code or ZIP code
         * @param {string} [addressRegionName] State, region or province
         * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
         * @param {number} [durationMilliseconds] Duration in ms
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCatalog(id: string, externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, importExternalImages?: boolean, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioCatalog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCatalog(id, externalId, title, addressCommonName, addressAddress1, addressAddress2, addressCityName, addressGeoPoint, addressRegionId, addressPostalCode, addressRegionName, addressCountryCode, description, details, href, type, subType, explicit, durationMilliseconds, minimumAgeRequirement, externalUrls, externalImages, attributions, importExternalImages, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioApi.updateCatalog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create or update an PortfolioItem
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
         * @param {string} [addressAddress1] Address line 1
         * @param {string} [addressAddress2] Address line 2
         * @param {string} [addressCityName] City name
         * @param {string} [addressGeoPoint] Latitude and Longitude
         * @param {number} [addressRegionId] 
         * @param {string} [addressPostalCode] Postal code or ZIP code
         * @param {string} [addressRegionName] State, region or province
         * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
         * @param {number} [durationMilliseconds] Duration in ms
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(id: string, externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, importExternalImages?: boolean, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItem(id, externalId, title, addressCommonName, addressAddress1, addressAddress2, addressCityName, addressGeoPoint, addressRegionId, addressPostalCode, addressRegionName, addressCountryCode, description, details, href, type, subType, explicit, durationMilliseconds, minimumAgeRequirement, catalogs, externalUrls, externalImages, attributions, importExternalImages, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortfolioApi.updateItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PortfolioApi - factory interface
 * export
 */
export const PortfolioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortfolioApiFp(configuration)
    return {
        /**
         * 
         * summary Create a PortfolioCatalog
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the catalog  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of catalog, such as album, video channel, shopping category, etc.
         * @param {string} [subType] The sub type of catalog
         * @param {boolean} [explicit] True if the catalog content is deemed explicit, otherwise false
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {string} [partitionKey] 
         * @param {string} [accountId] Tenant account ID
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCatalog(externalId?: string, title?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, partitionKey?: string, accountId?: string, importExternalImages?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<PortfolioCatalog> {
            return localVarFp.createCatalog(externalId, title, description, details, href, type, subType, explicit, minimumAgeRequirement, catalogs, externalUrls, externalImages, attributions, partitionKey, accountId, importExternalImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create a PortfolioItem
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
         * @param {string} [addressAddress1] Address line 1
         * @param {string} [addressAddress2] Address line 2
         * @param {string} [addressCityName] City name
         * @param {string} [addressGeoPoint] Latitude and Longitude
         * @param {number} [addressRegionId] 
         * @param {string} [addressPostalCode] Postal code or ZIP code
         * @param {string} [addressRegionName] State, region or province
         * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
         * @param {number} [durationMilliseconds] Duration in ms
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {string} [partitionKey] 
         * @param {string} [accountId] Tenant account ID
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, partitionKey?: string, accountId?: string, importExternalImages?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<PortfolioItem> {
            return localVarFp.createItem(externalId, title, addressCommonName, addressAddress1, addressAddress2, addressCityName, addressGeoPoint, addressRegionId, addressPostalCode, addressRegionName, addressCountryCode, description, details, href, type, subType, explicit, durationMilliseconds, minimumAgeRequirement, catalogs, externalUrls, externalImages, attributions, partitionKey, accountId, importExternalImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a list of PortfolioCatalogs
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogs(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PortfolioCatalogListResponse> {
            return localVarFp.getCatalogs(limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a list of PortfolioItems
         * @param {string} [keywords] 
         * @param {string} [channelId] 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(keywords?: string, channelId?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PortfolioItemListResponse> {
            return localVarFp.getItems(keywords, channelId, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create or update an PortfolioCatalog
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
         * @param {string} [addressAddress1] Address line 1
         * @param {string} [addressAddress2] Address line 2
         * @param {string} [addressCityName] City name
         * @param {string} [addressGeoPoint] Latitude and Longitude
         * @param {number} [addressRegionId] 
         * @param {string} [addressPostalCode] Postal code or ZIP code
         * @param {string} [addressRegionName] State, region or province
         * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
         * @param {number} [durationMilliseconds] Duration in ms
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCatalog(id: string, externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, importExternalImages?: boolean, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PortfolioCatalog> {
            return localVarFp.updateCatalog(id, externalId, title, addressCommonName, addressAddress1, addressAddress2, addressCityName, addressGeoPoint, addressRegionId, addressPostalCode, addressRegionName, addressCountryCode, description, details, href, type, subType, explicit, durationMilliseconds, minimumAgeRequirement, externalUrls, externalImages, attributions, importExternalImages, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create or update an PortfolioItem
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [externalId] The idea from the source third party
         * @param {string} [title] The Title
         * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
         * @param {string} [addressAddress1] Address line 1
         * @param {string} [addressAddress2] Address line 2
         * @param {string} [addressCityName] City name
         * @param {string} [addressGeoPoint] Latitude and Longitude
         * @param {number} [addressRegionId] 
         * @param {string} [addressPostalCode] Postal code or ZIP code
         * @param {string} [addressRegionName] State, region or province
         * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
         * @param {string} [description] The decription
         * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
         * @param {string} [href] The external href (optional)
         * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
         * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
         * @param {number} [durationMilliseconds] Duration in ms
         * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
         * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
         * @param {{ [key: string]: string; }} [externalUrls] The external url
         * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
         * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
         * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(id: string, externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, importExternalImages?: boolean, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PortfolioItem> {
            return localVarFp.updateItem(id, externalId, title, addressCommonName, addressAddress1, addressAddress2, addressCityName, addressGeoPoint, addressRegionId, addressPostalCode, addressRegionName, addressCountryCode, description, details, href, type, subType, explicit, durationMilliseconds, minimumAgeRequirement, catalogs, externalUrls, externalImages, attributions, importExternalImages, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortfolioApi - object-oriented interface
 * export
 * @class PortfolioApi
 * @extends {BaseAPI}
 */
export class PortfolioApi extends BaseAPI {
    /**
     * 
     * summary Create a PortfolioCatalog
     * @param {string} [externalId] The idea from the source third party
     * @param {string} [title] The Title
     * @param {string} [description] The decription
     * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the catalog  such as additional product details
     * @param {string} [href] The external href (optional)
     * @param {string} [type] The type of catalog, such as album, video channel, shopping category, etc.
     * @param {string} [subType] The sub type of catalog
     * @param {boolean} [explicit] True if the catalog content is deemed explicit, otherwise false
     * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
     * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
     * @param {{ [key: string]: string; }} [externalUrls] The external url
     * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
     * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
     * @param {string} [partitionKey] 
     * @param {string} [accountId] Tenant account ID
     * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PortfolioApi
     */
    public createCatalog(externalId?: string, title?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, partitionKey?: string, accountId?: string, importExternalImages?: boolean, options?: RawAxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).createCatalog(externalId, title, description, details, href, type, subType, explicit, minimumAgeRequirement, catalogs, externalUrls, externalImages, attributions, partitionKey, accountId, importExternalImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create a PortfolioItem
     * @param {string} [externalId] The idea from the source third party
     * @param {string} [title] The Title
     * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
     * @param {string} [addressAddress1] Address line 1
     * @param {string} [addressAddress2] Address line 2
     * @param {string} [addressCityName] City name
     * @param {string} [addressGeoPoint] Latitude and Longitude
     * @param {number} [addressRegionId] 
     * @param {string} [addressPostalCode] Postal code or ZIP code
     * @param {string} [addressRegionName] State, region or province
     * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
     * @param {string} [description] The decription
     * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
     * @param {string} [href] The external href (optional)
     * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
     * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
     * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
     * @param {number} [durationMilliseconds] Duration in ms
     * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
     * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
     * @param {{ [key: string]: string; }} [externalUrls] The external url
     * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
     * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
     * @param {string} [partitionKey] 
     * @param {string} [accountId] Tenant account ID
     * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PortfolioApi
     */
    public createItem(externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, partitionKey?: string, accountId?: string, importExternalImages?: boolean, options?: RawAxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).createItem(externalId, title, addressCommonName, addressAddress1, addressAddress2, addressCityName, addressGeoPoint, addressRegionId, addressPostalCode, addressRegionName, addressCountryCode, description, details, href, type, subType, explicit, durationMilliseconds, minimumAgeRequirement, catalogs, externalUrls, externalImages, attributions, partitionKey, accountId, importExternalImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a list of PortfolioCatalogs
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PortfolioApi
     */
    public getCatalogs(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).getCatalogs(limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a list of PortfolioItems
     * @param {string} [keywords] 
     * @param {string} [channelId] 
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PortfolioApi
     */
    public getItems(keywords?: string, channelId?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).getItems(keywords, channelId, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create or update an PortfolioCatalog
     * @param {string} id The id of the record you wish to retrieve
     * @param {string} [externalId] The idea from the source third party
     * @param {string} [title] The Title
     * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
     * @param {string} [addressAddress1] Address line 1
     * @param {string} [addressAddress2] Address line 2
     * @param {string} [addressCityName] City name
     * @param {string} [addressGeoPoint] Latitude and Longitude
     * @param {number} [addressRegionId] 
     * @param {string} [addressPostalCode] Postal code or ZIP code
     * @param {string} [addressRegionName] State, region or province
     * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
     * @param {string} [description] The decription
     * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
     * @param {string} [href] The external href (optional)
     * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
     * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
     * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
     * @param {number} [durationMilliseconds] Duration in ms
     * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
     * @param {{ [key: string]: string; }} [externalUrls] The external url
     * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
     * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
     * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PortfolioApi
     */
    public updateCatalog(id: string, externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, importExternalImages?: boolean, userId?: string, options?: RawAxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).updateCatalog(id, externalId, title, addressCommonName, addressAddress1, addressAddress2, addressCityName, addressGeoPoint, addressRegionId, addressPostalCode, addressRegionName, addressCountryCode, description, details, href, type, subType, explicit, durationMilliseconds, minimumAgeRequirement, externalUrls, externalImages, attributions, importExternalImages, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create or update an PortfolioItem
     * @param {string} id The id of the record you wish to retrieve
     * @param {string} [externalId] The idea from the source third party
     * @param {string} [title] The Title
     * @param {string} [addressCommonName] Common name of the address like Central Park, If we already have this in our db, it will pick that address by default
     * @param {string} [addressAddress1] Address line 1
     * @param {string} [addressAddress2] Address line 2
     * @param {string} [addressCityName] City name
     * @param {string} [addressGeoPoint] Latitude and Longitude
     * @param {number} [addressRegionId] 
     * @param {string} [addressPostalCode] Postal code or ZIP code
     * @param {string} [addressRegionName] State, region or province
     * @param {string} [addressCountryCode] Two-letter country code &lt;see href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\&quot;&gt;ISO 3166-1 alpha-2&lt;/see&gt;
     * @param {string} [description] The decription
     * @param {{ [key: string]: string; }} [details] A keyed list of other details related to the item  such as additional product details
     * @param {string} [href] The external href (optional)
     * @param {string} [type] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
     * @param {string} [subType] The type of item audio, video, game, podcast, physical, location, destination, experience, tip-link, invoice
     * @param {boolean} [explicit] True if the content is deemd explicity, otherwise false
     * @param {number} [durationMilliseconds] Duration in ms
     * @param {number} [minimumAgeRequirement] Minimum age in years if there is an age requirement such as 18+, otherise null or zero
     * @param {Array<CatalogEntryDeets>} [catalogs] List of the PortfolioCatalogs this PortfolioItem belongs to
     * @param {{ [key: string]: string; }} [externalUrls] The external url
     * @param {Array<ExternalImageDeets>} [externalImages] Collection of external images
     * @param {Array<AttributionDeets>} [attributions] Attributions are the credits or roles attaching Contact items   to this PortfolioItem
     * @param {boolean} [importExternalImages] When set to true Mozaic will import   the external images for the portfolio items  and raise an \&#39;import_completed\&#39; shared event when complete
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PortfolioApi
     */
    public updateItem(id: string, externalId?: string, title?: string, addressCommonName?: string, addressAddress1?: string, addressAddress2?: string, addressCityName?: string, addressGeoPoint?: string, addressRegionId?: number, addressPostalCode?: string, addressRegionName?: string, addressCountryCode?: string, description?: string, details?: { [key: string]: string; }, href?: string, type?: string, subType?: string, explicit?: boolean, durationMilliseconds?: number, minimumAgeRequirement?: number, catalogs?: Array<CatalogEntryDeets>, externalUrls?: { [key: string]: string; }, externalImages?: Array<ExternalImageDeets>, attributions?: Array<AttributionDeets>, importExternalImages?: boolean, userId?: string, options?: RawAxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).updateItem(id, externalId, title, addressCommonName, addressAddress1, addressAddress2, addressCityName, addressGeoPoint, addressRegionId, addressPostalCode, addressRegionName, addressCountryCode, description, details, href, type, subType, explicit, durationMilliseconds, minimumAgeRequirement, catalogs, externalUrls, externalImages, attributions, importExternalImages, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PushNotificationsApi - axios parameter creator
 * export
 */
export const PushNotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary delete device registration
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPushNotificationsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPushNotificationsIdDelete', 'id', id)
            const localVarPath = `/api/push-notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary This creates or updates a registration (with provided channelURI) at the specified id
         * @param {string} id 
         * @param {DeviceRegistration} [deviceRegistration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPushNotificationsIdPut: async (id: string, deviceRegistration?: DeviceRegistration, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPushNotificationsIdPut', 'id', id)
            const localVarPath = `/api/push-notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceRegistration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Push notification to device
         * @param {string} [pns] 
         * @param {string} [toTag] 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPushNotificationsPost: async (pns?: string, toTag?: string, body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/push-notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pns !== undefined) {
                localVarQueryParameter['pns'] = pns;
            }

            if (toTag !== undefined) {
                localVarQueryParameter['to_tag'] = toTag;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usernameUserNameDelete: async (userName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('usernameUserNameDelete', 'userName', userName)
            const localVarPath = `/username/{userName}`
                .replace(`{${"userName"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushNotificationsApi - functional programming interface
 * export
 */
export const PushNotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PushNotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary delete device registration
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPushNotificationsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPushNotificationsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushNotificationsApi.apiPushNotificationsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary This creates or updates a registration (with provided channelURI) at the specified id
         * @param {string} id 
         * @param {DeviceRegistration} [deviceRegistration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPushNotificationsIdPut(id: string, deviceRegistration?: DeviceRegistration, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPushNotificationsIdPut(id, deviceRegistration, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushNotificationsApi.apiPushNotificationsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Push notification to device
         * @param {string} [pns] 
         * @param {string} [toTag] 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPushNotificationsPost(pns?: string, toTag?: string, body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPushNotificationsPost(pns, toTag, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushNotificationsApi.apiPushNotificationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usernameUserNameDelete(userName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usernameUserNameDelete(userName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushNotificationsApi.usernameUserNameDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PushNotificationsApi - factory interface
 * export
 */
export const PushNotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PushNotificationsApiFp(configuration)
    return {
        /**
         * 
         * summary delete device registration
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPushNotificationsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiPushNotificationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary This creates or updates a registration (with provided channelURI) at the specified id
         * @param {string} id 
         * @param {DeviceRegistration} [deviceRegistration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPushNotificationsIdPut(id: string, deviceRegistration?: DeviceRegistration, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiPushNotificationsIdPut(id, deviceRegistration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Push notification to device
         * @param {string} [pns] 
         * @param {string} [toTag] 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPushNotificationsPost(pns?: string, toTag?: string, body?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiPushNotificationsPost(pns, toTag, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usernameUserNameDelete(userName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usernameUserNameDelete(userName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PushNotificationsApi - object-oriented interface
 * export
 * @class PushNotificationsApi
 * @extends {BaseAPI}
 */
export class PushNotificationsApi extends BaseAPI {
    /**
     * 
     * summary delete device registration
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PushNotificationsApi
     */
    public apiPushNotificationsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PushNotificationsApiFp(this.configuration).apiPushNotificationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary This creates or updates a registration (with provided channelURI) at the specified id
     * @param {string} id 
     * @param {DeviceRegistration} [deviceRegistration] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PushNotificationsApi
     */
    public apiPushNotificationsIdPut(id: string, deviceRegistration?: DeviceRegistration, options?: RawAxiosRequestConfig) {
        return PushNotificationsApiFp(this.configuration).apiPushNotificationsIdPut(id, deviceRegistration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Push notification to device
     * @param {string} [pns] 
     * @param {string} [toTag] 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PushNotificationsApi
     */
    public apiPushNotificationsPost(pns?: string, toTag?: string, body?: string, options?: RawAxiosRequestConfig) {
        return PushNotificationsApiFp(this.configuration).apiPushNotificationsPost(pns, toTag, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary 
     * @param {string} userName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof PushNotificationsApi
     */
    public usernameUserNameDelete(userName: string, options?: RawAxiosRequestConfig) {
        return PushNotificationsApiFp(this.configuration).usernameUserNameDelete(userName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SimpleContractsApi - axios parameter creator
 * export
 */
export const SimpleContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Update a SimpleContract
         * @param {string} contractId the ContractId of the Contract (not the Id property)
         * @param {SimpleContractUpdateDeets} [simpleContractUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSimpleContractsContractIdPut: async (contractId: string, simpleContractUpdateDeets?: SimpleContractUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('apiSimpleContractsContractIdPut', 'contractId', contractId)
            const localVarPath = `/api/simple-contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleContractUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Delete a SimpleContract
         * @param {string} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSimpleContractsDelete: async (contractId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/simple-contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (contractId !== undefined) {
                localVarQueryParameter['contractId'] = contractId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>SimpleContracts are a lighter-weight version of the standard contracts.              Contracts are core to the Mozaic API, they contain Income              objects which have child terms used to specify the rules              of how income should be split or sent to payees.</p>
         * summary List all SimpleContracts
         * @param {boolean} [activeOnly] If true only active SimpleContracts will be returned
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimpleContracts: async (activeOnly?: boolean, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/simple-contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (activeOnly !== undefined) {
                localVarQueryParameter['ActiveOnly'] = activeOnly;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve a list of all related payments
         * @param {string} id 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractPayments: async (id: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simpleContractPayments', 'id', id)
            const localVarPath = `/api/simple-contracts/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Reset avatar to the default
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsDeleteAvatar: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simpleContractsDeleteAvatar', 'id', id)
            const localVarPath = `/api/simple-contracts/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Returns a single `SimpleContract` object based on the specified id</p>
         * summary Retrieve a SimpleContract by accountID and contract ID
         * @param {string} accountId The id of the account that holds the simple contract
         * @param {string} contractId The id of the SimpleContract you want to retrieve
         * @param {number} [specificRevision] Optional revision number of the contract to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsGETByAccountAndId: async (accountId: string, contractId: string, specificRevision?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('simpleContractsGETByAccountAndId', 'accountId', accountId)
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('simpleContractsGETByAccountAndId', 'contractId', contractId)
            const localVarPath = `/api/simple-contracts/{accountId}/{contractId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (specificRevision !== undefined) {
                localVarQueryParameter['specificRevision'] = specificRevision;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Returns a single `SimpleContract` object based on the specified id</p>
         * summary Retrieve a SimpleContract
         * @param {string} id The id of the record you wish to retrieve
         * @param {number} [specificRevision] 
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsGETById: async (id: string, specificRevision?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simpleContractsGETById', 'id', id)
            const localVarPath = `/api/simple-contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (specificRevision !== undefined) {
                localVarQueryParameter['SpecificRevision'] = specificRevision;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve an avatar by id
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsGetAvatarById: async (id: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simpleContractsGetAvatarById', 'id', id)
            const localVarPath = `/api/simple-contracts/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Used to create new SimpleContracts or link to a existing SimpleContract group</p>
         * summary Create a SimpleContract
         * @param {SimpleContractCreateDeets} [simpleContractCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsPOST: async (simpleContractCreateDeets?: SimpleContractCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/simple-contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleContractCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Accept the specified SimpleContract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsPOSTAccept: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simpleContractsPOSTAccept', 'id', id)
            const localVarPath = `/api/simple-contracts/{id}/accept`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Archive the specified SimpleContract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsPOSTArchive: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simpleContractsPOSTArchive', 'id', id)
            const localVarPath = `/api/simple-contracts/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Decline the specified SimpleContract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsPOSTDecline: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simpleContractsPOSTDecline', 'id', id)
            const localVarPath = `/api/simple-contracts/{id}/decline`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
         * summary Upload avatar image via file
         * @param {string} id SimpleContract id
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsUpdateAvatar: async (id: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simpleContractsUpdateAvatar', 'id', id)
            const localVarPath = `/api/simple-contracts/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
         * summary Upload avatar via JSON body
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {AvatarBytes} [avatarBytes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsUpdateAvatarByDeets: async (id: string, userId?: string, avatarBytes?: AvatarBytes, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simpleContractsUpdateAvatarByDeets', 'id', id)
            const localVarPath = `/api/simple-contracts/{id}/image/base64`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avatarBytes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
         * summary Generate a new avatar image via AI prompt.
         * @param {string} id 
         * @param {AvatarPromptCreateDeets} [avatarPromptCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsUpdateAvatarByPrompt: async (id: string, avatarPromptCreateDeets?: AvatarPromptCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simpleContractsUpdateAvatarByPrompt', 'id', id)
            const localVarPath = `/api/simple-contracts/{id}/image/ai`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avatarPromptCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimpleContractsApi - functional programming interface
 * export
 */
export const SimpleContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SimpleContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Update a SimpleContract
         * @param {string} contractId the ContractId of the Contract (not the Id property)
         * @param {SimpleContractUpdateDeets} [simpleContractUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSimpleContractsContractIdPut(contractId: string, simpleContractUpdateDeets?: SimpleContractUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSimpleContractsContractIdPut(contractId, simpleContractUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.apiSimpleContractsContractIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Delete a SimpleContract
         * @param {string} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSimpleContractsDelete(contractId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSimpleContractsDelete(contractId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.apiSimpleContractsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>SimpleContracts are a lighter-weight version of the standard contracts.              Contracts are core to the Mozaic API, they contain Income              objects which have child terms used to specify the rules              of how income should be split or sent to payees.</p>
         * summary List all SimpleContracts
         * @param {boolean} [activeOnly] If true only active SimpleContracts will be returned
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimpleContracts(activeOnly?: boolean, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleContractListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimpleContracts(activeOnly, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.getSimpleContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve a list of all related payments
         * @param {string} id 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractPayments(id: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCycleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractPayments(id, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Reset avatar to the default
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractsDeleteAvatar(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractsDeleteAvatar(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractsDeleteAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Returns a single `SimpleContract` object based on the specified id</p>
         * summary Retrieve a SimpleContract by accountID and contract ID
         * @param {string} accountId The id of the account that holds the simple contract
         * @param {string} contractId The id of the SimpleContract you want to retrieve
         * @param {number} [specificRevision] Optional revision number of the contract to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractsGETByAccountAndId(accountId: string, contractId: string, specificRevision?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractsGETByAccountAndId(accountId, contractId, specificRevision, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractsGETByAccountAndId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Returns a single `SimpleContract` object based on the specified id</p>
         * summary Retrieve a SimpleContract
         * @param {string} id The id of the record you wish to retrieve
         * @param {number} [specificRevision] 
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractsGETById(id: string, specificRevision?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractsGETById(id, specificRevision, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractsGETById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve an avatar by id
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractsGetAvatarById(id: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractsGetAvatarById(id, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractsGetAvatarById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Used to create new SimpleContracts or link to a existing SimpleContract group</p>
         * summary Create a SimpleContract
         * @param {SimpleContractCreateDeets} [simpleContractCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractsPOST(simpleContractCreateDeets?: SimpleContractCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractsPOST(simpleContractCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractsPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Accept the specified SimpleContract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractsPOSTAccept(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractsPOSTAccept(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractsPOSTAccept']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Archive the specified SimpleContract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractsPOSTArchive(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractsPOSTArchive(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractsPOSTArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Decline the specified SimpleContract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractsPOSTDecline(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleContract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractsPOSTDecline(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractsPOSTDecline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
         * summary Upload avatar image via file
         * @param {string} id SimpleContract id
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractsUpdateAvatar(id: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractsUpdateAvatar(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractsUpdateAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
         * summary Upload avatar via JSON body
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {AvatarBytes} [avatarBytes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractsUpdateAvatarByDeets(id: string, userId?: string, avatarBytes?: AvatarBytes, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractsUpdateAvatarByDeets(id, userId, avatarBytes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractsUpdateAvatarByDeets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
         * summary Generate a new avatar image via AI prompt.
         * @param {string} id 
         * @param {AvatarPromptCreateDeets} [avatarPromptCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simpleContractsUpdateAvatarByPrompt(id: string, avatarPromptCreateDeets?: AvatarPromptCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simpleContractsUpdateAvatarByPrompt(id, avatarPromptCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimpleContractsApi.simpleContractsUpdateAvatarByPrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SimpleContractsApi - factory interface
 * export
 */
export const SimpleContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SimpleContractsApiFp(configuration)
    return {
        /**
         * 
         * summary Update a SimpleContract
         * @param {string} contractId the ContractId of the Contract (not the Id property)
         * @param {SimpleContractUpdateDeets} [simpleContractUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSimpleContractsContractIdPut(contractId: string, simpleContractUpdateDeets?: SimpleContractUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<SimpleContract> {
            return localVarFp.apiSimpleContractsContractIdPut(contractId, simpleContractUpdateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Delete a SimpleContract
         * @param {string} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSimpleContractsDelete(contractId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiSimpleContractsDelete(contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>SimpleContracts are a lighter-weight version of the standard contracts.              Contracts are core to the Mozaic API, they contain Income              objects which have child terms used to specify the rules              of how income should be split or sent to payees.</p>
         * summary List all SimpleContracts
         * @param {boolean} [activeOnly] If true only active SimpleContracts will be returned
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimpleContracts(activeOnly?: boolean, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<SimpleContractListResponse> {
            return localVarFp.getSimpleContracts(activeOnly, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve a list of all related payments
         * @param {string} id 
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractPayments(id: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCycleListResponse> {
            return localVarFp.simpleContractPayments(id, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Reset avatar to the default
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsDeleteAvatar(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.simpleContractsDeleteAvatar(id, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Returns a single `SimpleContract` object based on the specified id</p>
         * summary Retrieve a SimpleContract by accountID and contract ID
         * @param {string} accountId The id of the account that holds the simple contract
         * @param {string} contractId The id of the SimpleContract you want to retrieve
         * @param {number} [specificRevision] Optional revision number of the contract to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsGETByAccountAndId(accountId: string, contractId: string, specificRevision?: number, options?: RawAxiosRequestConfig): AxiosPromise<SimpleContract> {
            return localVarFp.simpleContractsGETByAccountAndId(accountId, contractId, specificRevision, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Returns a single `SimpleContract` object based on the specified id</p>
         * summary Retrieve a SimpleContract
         * @param {string} id The id of the record you wish to retrieve
         * @param {number} [specificRevision] 
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsGETById(id: string, specificRevision?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<SimpleContract> {
            return localVarFp.simpleContractsGETById(id, specificRevision, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve an avatar by id
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsGetAvatarById(id: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.simpleContractsGetAvatarById(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Used to create new SimpleContracts or link to a existing SimpleContract group</p>
         * summary Create a SimpleContract
         * @param {SimpleContractCreateDeets} [simpleContractCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsPOST(simpleContractCreateDeets?: SimpleContractCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<SimpleContract> {
            return localVarFp.simpleContractsPOST(simpleContractCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Accept the specified SimpleContract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsPOSTAccept(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SimpleContract> {
            return localVarFp.simpleContractsPOSTAccept(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Archive the specified SimpleContract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsPOSTArchive(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SimpleContract> {
            return localVarFp.simpleContractsPOSTArchive(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Decline the specified SimpleContract
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsPOSTDecline(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SimpleContract> {
            return localVarFp.simpleContractsPOSTDecline(id, options).then((request) => request(axios, basePath));
        },
        /**
         * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
         * summary Upload avatar image via file
         * @param {string} id SimpleContract id
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsUpdateAvatar(id: string, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.simpleContractsUpdateAvatar(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
         * summary Upload avatar via JSON body
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {AvatarBytes} [avatarBytes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsUpdateAvatarByDeets(id: string, userId?: string, avatarBytes?: AvatarBytes, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.simpleContractsUpdateAvatarByDeets(id, userId, avatarBytes, options).then((request) => request(axios, basePath));
        },
        /**
         * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
         * summary Generate a new avatar image via AI prompt.
         * @param {string} id 
         * @param {AvatarPromptCreateDeets} [avatarPromptCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simpleContractsUpdateAvatarByPrompt(id: string, avatarPromptCreateDeets?: AvatarPromptCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.simpleContractsUpdateAvatarByPrompt(id, avatarPromptCreateDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SimpleContractsApi - object-oriented interface
 * export
 * @class SimpleContractsApi
 * @extends {BaseAPI}
 */
export class SimpleContractsApi extends BaseAPI {
    /**
     * 
     * summary Update a SimpleContract
     * @param {string} contractId the ContractId of the Contract (not the Id property)
     * @param {SimpleContractUpdateDeets} [simpleContractUpdateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public apiSimpleContractsContractIdPut(contractId: string, simpleContractUpdateDeets?: SimpleContractUpdateDeets, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).apiSimpleContractsContractIdPut(contractId, simpleContractUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Delete a SimpleContract
     * @param {string} [contractId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public apiSimpleContractsDelete(contractId?: string, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).apiSimpleContractsDelete(contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>SimpleContracts are a lighter-weight version of the standard contracts.              Contracts are core to the Mozaic API, they contain Income              objects which have child terms used to specify the rules              of how income should be split or sent to payees.</p>
     * summary List all SimpleContracts
     * @param {boolean} [activeOnly] If true only active SimpleContracts will be returned
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public getSimpleContracts(activeOnly?: boolean, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).getSimpleContracts(activeOnly, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve a list of all related payments
     * @param {string} id 
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractPayments(id: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractPayments(id, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Reset avatar to the default
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractsDeleteAvatar(id: string, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractsDeleteAvatar(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Returns a single `SimpleContract` object based on the specified id</p>
     * summary Retrieve a SimpleContract by accountID and contract ID
     * @param {string} accountId The id of the account that holds the simple contract
     * @param {string} contractId The id of the SimpleContract you want to retrieve
     * @param {number} [specificRevision] Optional revision number of the contract to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractsGETByAccountAndId(accountId: string, contractId: string, specificRevision?: number, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractsGETByAccountAndId(accountId, contractId, specificRevision, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Returns a single `SimpleContract` object based on the specified id</p>
     * summary Retrieve a SimpleContract
     * @param {string} id The id of the record you wish to retrieve
     * @param {number} [specificRevision] 
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractsGETById(id: string, specificRevision?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractsGETById(id, specificRevision, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve an avatar by id
     * @param {string} id The id of the record you wish to retrieve
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractsGetAvatarById(id: string, userId?: string, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractsGetAvatarById(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Used to create new SimpleContracts or link to a existing SimpleContract group</p>
     * summary Create a SimpleContract
     * @param {SimpleContractCreateDeets} [simpleContractCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractsPOST(simpleContractCreateDeets?: SimpleContractCreateDeets, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractsPOST(simpleContractCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Accept the specified SimpleContract
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractsPOSTAccept(id: string, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractsPOSTAccept(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Archive the specified SimpleContract
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractsPOSTArchive(id: string, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractsPOSTArchive(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Decline the specified SimpleContract
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractsPOSTDecline(id: string, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractsPOSTDecline(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
     * summary Upload avatar image via file
     * @param {string} id SimpleContract id
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractsUpdateAvatar(id: string, file?: File, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractsUpdateAvatar(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
     * summary Upload avatar via JSON body
     * @param {string} id The id of the record you wish to retrieve
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {AvatarBytes} [avatarBytes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractsUpdateAvatarByDeets(id: string, userId?: string, avatarBytes?: AvatarBytes, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractsUpdateAvatarByDeets(id, userId, avatarBytes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * avatar_id could be tenant.id, SimpleContract.id, work.id, project.id, team.id, etc
     * summary Generate a new avatar image via AI prompt.
     * @param {string} id 
     * @param {AvatarPromptCreateDeets} [avatarPromptCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SimpleContractsApi
     */
    public simpleContractsUpdateAvatarByPrompt(id: string, avatarPromptCreateDeets?: AvatarPromptCreateDeets, options?: RawAxiosRequestConfig) {
        return SimpleContractsApiFp(this.configuration).simpleContractsUpdateAvatarByPrompt(id, avatarPromptCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemEventsApi - axios parameter creator
 * export
 */
export const SystemEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Sends a verification code notification with an email input.
         * @param {string} [body] The email to which the verification code will be sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventAdminVerificationCodePost: async (body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/event/admin/verification-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Sends a payout transfer initiated notification with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventPayoutTransferInitiatedPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/event/payout/transfer-initiated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Sends a payment received notification for a recipient with an account with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventRecipientPaymentReceivedHasAccountPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/event/recipient/payment-received-has-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Sends a payment received notification for a recipient without an account with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventRecipientPaymentReceivedNoAccountPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/event/recipient/payment-received-no-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Sends a payment failure notification with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventSenderPaymentFailurePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/event/sender/payment-failure`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Sends a payment success notification with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventSenderPaymentSuccessPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/event/sender/payment-success`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemEventsApi - functional programming interface
 * export
 */
export const SystemEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Sends a verification code notification with an email input.
         * @param {string} [body] The email to which the verification code will be sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEventAdminVerificationCodePost(body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEventAdminVerificationCodePost(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemEventsApi.apiEventAdminVerificationCodePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Sends a payout transfer initiated notification with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEventPayoutTransferInitiatedPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEventPayoutTransferInitiatedPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemEventsApi.apiEventPayoutTransferInitiatedPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Sends a payment received notification for a recipient with an account with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEventRecipientPaymentReceivedHasAccountPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEventRecipientPaymentReceivedHasAccountPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemEventsApi.apiEventRecipientPaymentReceivedHasAccountPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Sends a payment received notification for a recipient without an account with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEventRecipientPaymentReceivedNoAccountPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEventRecipientPaymentReceivedNoAccountPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemEventsApi.apiEventRecipientPaymentReceivedNoAccountPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Sends a payment failure notification with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEventSenderPaymentFailurePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEventSenderPaymentFailurePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemEventsApi.apiEventSenderPaymentFailurePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Sends a payment success notification with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEventSenderPaymentSuccessPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEventSenderPaymentSuccessPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemEventsApi.apiEventSenderPaymentSuccessPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemEventsApi - factory interface
 * export
 */
export const SystemEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemEventsApiFp(configuration)
    return {
        /**
         * 
         * summary Sends a verification code notification with an email input.
         * @param {string} [body] The email to which the verification code will be sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventAdminVerificationCodePost(body?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiEventAdminVerificationCodePost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Sends a payout transfer initiated notification with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventPayoutTransferInitiatedPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiEventPayoutTransferInitiatedPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Sends a payment received notification for a recipient with an account with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventRecipientPaymentReceivedHasAccountPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiEventRecipientPaymentReceivedHasAccountPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Sends a payment received notification for a recipient without an account with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventRecipientPaymentReceivedNoAccountPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiEventRecipientPaymentReceivedNoAccountPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Sends a payment failure notification with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventSenderPaymentFailurePost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiEventSenderPaymentFailurePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Sends a payment success notification with hardcoded values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventSenderPaymentSuccessPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiEventSenderPaymentSuccessPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemEventsApi - object-oriented interface
 * export
 * @class SystemEventsApi
 * @extends {BaseAPI}
 */
export class SystemEventsApi extends BaseAPI {
    /**
     * 
     * summary Sends a verification code notification with an email input.
     * @param {string} [body] The email to which the verification code will be sent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SystemEventsApi
     */
    public apiEventAdminVerificationCodePost(body?: string, options?: RawAxiosRequestConfig) {
        return SystemEventsApiFp(this.configuration).apiEventAdminVerificationCodePost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Sends a payout transfer initiated notification with hardcoded values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SystemEventsApi
     */
    public apiEventPayoutTransferInitiatedPost(options?: RawAxiosRequestConfig) {
        return SystemEventsApiFp(this.configuration).apiEventPayoutTransferInitiatedPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Sends a payment received notification for a recipient with an account with hardcoded values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SystemEventsApi
     */
    public apiEventRecipientPaymentReceivedHasAccountPost(options?: RawAxiosRequestConfig) {
        return SystemEventsApiFp(this.configuration).apiEventRecipientPaymentReceivedHasAccountPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Sends a payment received notification for a recipient without an account with hardcoded values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SystemEventsApi
     */
    public apiEventRecipientPaymentReceivedNoAccountPost(options?: RawAxiosRequestConfig) {
        return SystemEventsApiFp(this.configuration).apiEventRecipientPaymentReceivedNoAccountPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Sends a payment failure notification with hardcoded values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SystemEventsApi
     */
    public apiEventSenderPaymentFailurePost(options?: RawAxiosRequestConfig) {
        return SystemEventsApiFp(this.configuration).apiEventSenderPaymentFailurePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Sends a payment success notification with hardcoded values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof SystemEventsApi
     */
    public apiEventSenderPaymentSuccessPost(options?: RawAxiosRequestConfig) {
        return SystemEventsApiFp(this.configuration).apiEventSenderPaymentSuccessPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TenantsApi - axios parameter creator
 * export
 */
export const TenantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Returns permission details such as CanCreate, CanView, etc  for the specified resource to assist the UI.   For a list of resources available  on this account call GetListResources
         * @param {string} [resourcePath] 
         * @param {string} [vector] 
         * @param {boolean} [readCache] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsAccessGet: async (resourcePath?: string, vector?: string, readCache?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants/Access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourcePath !== undefined) {
                localVarQueryParameter['resourcePath'] = resourcePath;
            }

            if (vector !== undefined) {
                localVarQueryParameter['vector'] = vector;
            }

            if (readCache !== undefined) {
                localVarQueryParameter['readCache'] = readCache;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Returns the list of all access rules for the current user on the current account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsAccountAccessGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants/AccountAccess`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve information about the current user/tenant
         * @param {boolean} [isLightVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsGet: async (isLightVersion?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isLightVersion !== undefined) {
                localVarQueryParameter['isLightVersion'] = isLightVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create and on-board a tenant account
         * @param {TenantCreateDeets} [tenantCreateDeets] Details about the tenant account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsPost: async (tenantCreateDeets?: TenantCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary This is a special use case for onboarding a tenant where the external wallets already exist. Calling this will pull data instead of creating new external accounts where possible.
         * @param {TenantCreateDeets} [tenantCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsPut: async (tenantCreateDeets?: TenantCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary It uses to remove details from stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsRemoveOnboardingDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants/remove-onboarding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Returns a list of securable resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsResourcesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve information about the onbaording tasks
         * @param {string} [taskListType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsTaskListGet: async (taskListType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants/task-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (taskListType !== undefined) {
                localVarQueryParameter['taskListType'] = taskListType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary It will update the task status
         * @param {TaskUpdateStatusDeets} [taskUpdateStatusDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsTaskPut: async (taskUpdateStatusDeets?: TaskUpdateStatusDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskUpdateStatusDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Retrieve information about the onbaording task
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsTaskTaskIdGet: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('apiTenantsTaskTaskIdGet', 'taskId', taskId)
            const localVarPath = `/api/tenants/task/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary It uses to update documents needed for stripe, Proof of concept.
         * @param {File} [frontFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsVerificationFileUploadPut: async (frontFile?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants/verification/fileUpload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (frontFile !== undefined) { 
                localVarFormParams.append('frontFile', frontFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TenantUpdateVerificationDeets} [tenantUpdateVerificationDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsVerificationPut: async (tenantUpdateVerificationDeets?: TenantUpdateVerificationDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenantUpdateVerificationDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Gets an onboarding session key from stripe
         * @param {string} [country] A two letter country code that will be passed to Stripe for account onboarding. Ex: US
         * @param {boolean} [enableExternalAccountCollection] Whether to allow platforms to control bank account collection for their connected&lt;br /&gt;accounts. This feature can only be false for custom accounts (or accounts where the&lt;br /&gt;platform is compliance owner). Otherwise, bank account collection is determined by&lt;br /&gt;compliance requirements.
         * @param {string} [businessType] One of: &#x60;company&#x60;, &#x60;government_entity&#x60;, &#x60;individual&#x60;, or &#x60;non_profit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardingSessionApiKey: async (country?: string, enableExternalAccountCollection?: boolean, businessType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tenants/onboarding-session-api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (enableExternalAccountCollection !== undefined) {
                localVarQueryParameter['enableExternalAccountCollection'] = enableExternalAccountCollection;
            }

            if (businessType !== undefined) {
                localVarQueryParameter['businessType'] = businessType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantsApi - functional programming interface
 * export
 */
export const TenantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Returns permission details such as CanCreate, CanView, etc  for the specified resource to assist the UI.   For a list of resources available  on this account call GetListResources
         * @param {string} [resourcePath] 
         * @param {string} [vector] 
         * @param {boolean} [readCache] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsAccessGet(resourcePath?: string, vector?: string, readCache?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessControlRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsAccessGet(resourcePath, vector, readCache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsAccessGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Returns the list of all access rules for the current user on the current account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsAccountAccessGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsAccountAccessGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsAccountAccessGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve information about the current user/tenant
         * @param {boolean} [isLightVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsGet(isLightVersion?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsGet(isLightVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create and on-board a tenant account
         * @param {TenantCreateDeets} [tenantCreateDeets] Details about the tenant account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsPost(tenantCreateDeets?: TenantCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsPost(tenantCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary This is a special use case for onboarding a tenant where the external wallets already exist. Calling this will pull data instead of creating new external accounts where possible.
         * @param {TenantCreateDeets} [tenantCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsPut(tenantCreateDeets?: TenantCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsPut(tenantCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary It uses to remove details from stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsRemoveOnboardingDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsRemoveOnboardingDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsRemoveOnboardingDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Returns a list of securable resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsResourcesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsResourcesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsResourcesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve information about the onbaording tasks
         * @param {string} [taskListType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsTaskListGet(taskListType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsTaskListGet(taskListType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsTaskListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary It will update the task status
         * @param {TaskUpdateStatusDeets} [taskUpdateStatusDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsTaskPut(taskUpdateStatusDeets?: TaskUpdateStatusDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnBoardingTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsTaskPut(taskUpdateStatusDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsTaskPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Retrieve information about the onbaording task
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsTaskTaskIdGet(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnBoardingTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsTaskTaskIdGet(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsTaskTaskIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary It uses to update documents needed for stripe, Proof of concept.
         * @param {File} [frontFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsVerificationFileUploadPut(frontFile?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsVerificationFileUploadPut(frontFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsVerificationFileUploadPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TenantUpdateVerificationDeets} [tenantUpdateVerificationDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTenantsVerificationPut(tenantUpdateVerificationDeets?: TenantUpdateVerificationDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTenantsVerificationPut(tenantUpdateVerificationDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.apiTenantsVerificationPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Gets an onboarding session key from stripe
         * @param {string} [country] A two letter country code that will be passed to Stripe for account onboarding. Ex: US
         * @param {boolean} [enableExternalAccountCollection] Whether to allow platforms to control bank account collection for their connected&lt;br /&gt;accounts. This feature can only be false for custom accounts (or accounts where the&lt;br /&gt;platform is compliance owner). Otherwise, bank account collection is determined by&lt;br /&gt;compliance requirements.
         * @param {string} [businessType] One of: &#x60;company&#x60;, &#x60;government_entity&#x60;, &#x60;individual&#x60;, or &#x60;non_profit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOnboardingSessionApiKey(country?: string, enableExternalAccountCollection?: boolean, businessType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOnboardingSessionApiKey(country, enableExternalAccountCollection, businessType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TenantsApi.getOnboardingSessionApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TenantsApi - factory interface
 * export
 */
export const TenantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantsApiFp(configuration)
    return {
        /**
         * 
         * summary Returns permission details such as CanCreate, CanView, etc  for the specified resource to assist the UI.   For a list of resources available  on this account call GetListResources
         * @param {string} [resourcePath] 
         * @param {string} [vector] 
         * @param {boolean} [readCache] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsAccessGet(resourcePath?: string, vector?: string, readCache?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AccessControlRule> {
            return localVarFp.apiTenantsAccessGet(resourcePath, vector, readCache, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Returns the list of all access rules for the current user on the current account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsAccountAccessGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiTenantsAccountAccessGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve information about the current user/tenant
         * @param {boolean} [isLightVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsGet(isLightVersion?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Tenant> {
            return localVarFp.apiTenantsGet(isLightVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create and on-board a tenant account
         * @param {TenantCreateDeets} [tenantCreateDeets] Details about the tenant account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsPost(tenantCreateDeets?: TenantCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<Tenant> {
            return localVarFp.apiTenantsPost(tenantCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary This is a special use case for onboarding a tenant where the external wallets already exist. Calling this will pull data instead of creating new external accounts where possible.
         * @param {TenantCreateDeets} [tenantCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsPut(tenantCreateDeets?: TenantCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<Tenant> {
            return localVarFp.apiTenantsPut(tenantCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary It uses to remove details from stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsRemoveOnboardingDelete(options?: RawAxiosRequestConfig): AxiosPromise<Tenant> {
            return localVarFp.apiTenantsRemoveOnboardingDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Returns a list of securable resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsResourcesGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiTenantsResourcesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve information about the onbaording tasks
         * @param {string} [taskListType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsTaskListGet(taskListType?: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskList> {
            return localVarFp.apiTenantsTaskListGet(taskListType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary It will update the task status
         * @param {TaskUpdateStatusDeets} [taskUpdateStatusDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsTaskPut(taskUpdateStatusDeets?: TaskUpdateStatusDeets, options?: RawAxiosRequestConfig): AxiosPromise<OnBoardingTask> {
            return localVarFp.apiTenantsTaskPut(taskUpdateStatusDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Retrieve information about the onbaording task
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsTaskTaskIdGet(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<OnBoardingTask> {
            return localVarFp.apiTenantsTaskTaskIdGet(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary It uses to update documents needed for stripe, Proof of concept.
         * @param {File} [frontFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsVerificationFileUploadPut(frontFile?: File, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.apiTenantsVerificationFileUploadPut(frontFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TenantUpdateVerificationDeets} [tenantUpdateVerificationDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTenantsVerificationPut(tenantUpdateVerificationDeets?: TenantUpdateVerificationDeets, options?: RawAxiosRequestConfig): AxiosPromise<Tenant> {
            return localVarFp.apiTenantsVerificationPut(tenantUpdateVerificationDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Gets an onboarding session key from stripe
         * @param {string} [country] A two letter country code that will be passed to Stripe for account onboarding. Ex: US
         * @param {boolean} [enableExternalAccountCollection] Whether to allow platforms to control bank account collection for their connected&lt;br /&gt;accounts. This feature can only be false for custom accounts (or accounts where the&lt;br /&gt;platform is compliance owner). Otherwise, bank account collection is determined by&lt;br /&gt;compliance requirements.
         * @param {string} [businessType] One of: &#x60;company&#x60;, &#x60;government_entity&#x60;, &#x60;individual&#x60;, or &#x60;non_profit&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardingSessionApiKey(country?: string, enableExternalAccountCollection?: boolean, businessType?: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountSession> {
            return localVarFp.getOnboardingSessionApiKey(country, enableExternalAccountCollection, businessType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantsApi - object-oriented interface
 * export
 * @class TenantsApi
 * @extends {BaseAPI}
 */
export class TenantsApi extends BaseAPI {
    /**
     * 
     * summary Returns permission details such as CanCreate, CanView, etc  for the specified resource to assist the UI.   For a list of resources available  on this account call GetListResources
     * @param {string} [resourcePath] 
     * @param {string} [vector] 
     * @param {boolean} [readCache] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsAccessGet(resourcePath?: string, vector?: string, readCache?: boolean, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsAccessGet(resourcePath, vector, readCache, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Returns the list of all access rules for the current user on the current account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsAccountAccessGet(options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsAccountAccessGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve information about the current user/tenant
     * @param {boolean} [isLightVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsGet(isLightVersion?: boolean, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsGet(isLightVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create and on-board a tenant account
     * @param {TenantCreateDeets} [tenantCreateDeets] Details about the tenant account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsPost(tenantCreateDeets?: TenantCreateDeets, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsPost(tenantCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary This is a special use case for onboarding a tenant where the external wallets already exist. Calling this will pull data instead of creating new external accounts where possible.
     * @param {TenantCreateDeets} [tenantCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsPut(tenantCreateDeets?: TenantCreateDeets, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsPut(tenantCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary It uses to remove details from stripe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsRemoveOnboardingDelete(options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsRemoveOnboardingDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Returns a list of securable resources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsResourcesGet(options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsResourcesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve information about the onbaording tasks
     * @param {string} [taskListType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsTaskListGet(taskListType?: string, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsTaskListGet(taskListType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary It will update the task status
     * @param {TaskUpdateStatusDeets} [taskUpdateStatusDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsTaskPut(taskUpdateStatusDeets?: TaskUpdateStatusDeets, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsTaskPut(taskUpdateStatusDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Retrieve information about the onbaording task
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsTaskTaskIdGet(taskId: string, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsTaskTaskIdGet(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary It uses to update documents needed for stripe, Proof of concept.
     * @param {File} [frontFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsVerificationFileUploadPut(frontFile?: File, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsVerificationFileUploadPut(frontFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenantUpdateVerificationDeets} [tenantUpdateVerificationDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public apiTenantsVerificationPut(tenantUpdateVerificationDeets?: TenantUpdateVerificationDeets, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).apiTenantsVerificationPut(tenantUpdateVerificationDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Gets an onboarding session key from stripe
     * @param {string} [country] A two letter country code that will be passed to Stripe for account onboarding. Ex: US
     * @param {boolean} [enableExternalAccountCollection] Whether to allow platforms to control bank account collection for their connected&lt;br /&gt;accounts. This feature can only be false for custom accounts (or accounts where the&lt;br /&gt;platform is compliance owner). Otherwise, bank account collection is determined by&lt;br /&gt;compliance requirements.
     * @param {string} [businessType] One of: &#x60;company&#x60;, &#x60;government_entity&#x60;, &#x60;individual&#x60;, or &#x60;non_profit&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TenantsApi
     */
    public getOnboardingSessionApiKey(country?: string, enableExternalAccountCollection?: boolean, businessType?: string, options?: RawAxiosRequestConfig) {
        return TenantsApiFp(this.configuration).getOnboardingSessionApiKey(country, enableExternalAccountCollection, businessType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TipLinksApi - axios parameter creator
 * export
 */
export const TipLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Upload image
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinkImage: async (image?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tip-links/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Create a new Tip Link
         * @param {TipLinkCreateDeets} [tipLinkCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinksCREATE: async (tipLinkCreateDeets?: TipLinkCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tip-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tipLinkCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Get data for a single Tip Link by id
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinksGET: async (id: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tipLinksGET', 'id', id)
            const localVarPath = `/api/tip-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Get data for all Tip Links
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinksLIST: async (limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tip-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Search tip links based on contract id              Returns a list of <span class=\"TipLink\">TipLink</span>.</p>
         * summary Search tip links
         * @param {string} [contractId] The search for contract Id
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinksSearch: async (contractId?: string, limit?: number, page?: number, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tip-links/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (contractId !== undefined) {
                localVarQueryParameter['ContractId'] = contractId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (userId != null) {
                localVarHeaderParameter['user_id'] = String(userId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Make changes to an existing Tip Link
         * @param {string} id 
         * @param {TipLinkUpdateDeets} [tipLinkUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinksUpdate: async (id: string, tipLinkUpdateDeets?: TipLinkUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tipLinksUpdate', 'id', id)
            const localVarPath = `/api/tip-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tipLinkUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TipLinksApi - functional programming interface
 * export
 */
export const TipLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TipLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Upload image
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tipLinkImage(image?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipLinksImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tipLinkImage(image, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TipLinksApi.tipLinkImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Create a new Tip Link
         * @param {TipLinkCreateDeets} [tipLinkCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tipLinksCREATE(tipLinkCreateDeets?: TipLinkCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tipLinksCREATE(tipLinkCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TipLinksApi.tipLinksCREATE']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Get data for a single Tip Link by id
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tipLinksGET(id: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tipLinksGET(id, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TipLinksApi.tipLinksGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Get data for all Tip Links
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tipLinksLIST(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipLinkListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tipLinksLIST(limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TipLinksApi.tipLinksLIST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Search tip links based on contract id              Returns a list of <span class=\"TipLink\">TipLink</span>.</p>
         * summary Search tip links
         * @param {string} [contractId] The search for contract Id
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tipLinksSearch(contractId?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipLinkListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tipLinksSearch(contractId, limit, page, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TipLinksApi.tipLinksSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Make changes to an existing Tip Link
         * @param {string} id 
         * @param {TipLinkUpdateDeets} [tipLinkUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tipLinksUpdate(id: string, tipLinkUpdateDeets?: TipLinkUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tipLinksUpdate(id, tipLinkUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TipLinksApi.tipLinksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TipLinksApi - factory interface
 * export
 */
export const TipLinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TipLinksApiFp(configuration)
    return {
        /**
         * 
         * summary Upload image
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinkImage(image?: File, options?: RawAxiosRequestConfig): AxiosPromise<TipLinksImage> {
            return localVarFp.tipLinkImage(image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Create a new Tip Link
         * @param {TipLinkCreateDeets} [tipLinkCreateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinksCREATE(tipLinkCreateDeets?: TipLinkCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<TipLink> {
            return localVarFp.tipLinksCREATE(tipLinkCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Get data for a single Tip Link by id
         * @param {string} id The id of the record you wish to retrieve
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinksGET(id: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<TipLink> {
            return localVarFp.tipLinksGET(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Get data for all Tip Links
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinksLIST(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<TipLinkListResponse> {
            return localVarFp.tipLinksLIST(limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Search tip links based on contract id              Returns a list of <span class=\"TipLink\">TipLink</span>.</p>
         * summary Search tip links
         * @param {string} [contractId] The search for contract Id
         * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
         * @param {number} [page] 1-based page index for paginated results
         * @param {string} [userId] The user id to operate on their behalf (tenants only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinksSearch(contractId?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<TipLinkListResponse> {
            return localVarFp.tipLinksSearch(contractId, limit, page, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Make changes to an existing Tip Link
         * @param {string} id 
         * @param {TipLinkUpdateDeets} [tipLinkUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tipLinksUpdate(id: string, tipLinkUpdateDeets?: TipLinkUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<TipLink> {
            return localVarFp.tipLinksUpdate(id, tipLinkUpdateDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TipLinksApi - object-oriented interface
 * export
 * @class TipLinksApi
 * @extends {BaseAPI}
 */
export class TipLinksApi extends BaseAPI {
    /**
     * 
     * summary Upload image
     * @param {File} [image] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TipLinksApi
     */
    public tipLinkImage(image?: File, options?: RawAxiosRequestConfig) {
        return TipLinksApiFp(this.configuration).tipLinkImage(image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Create a new Tip Link
     * @param {TipLinkCreateDeets} [tipLinkCreateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TipLinksApi
     */
    public tipLinksCREATE(tipLinkCreateDeets?: TipLinkCreateDeets, options?: RawAxiosRequestConfig) {
        return TipLinksApiFp(this.configuration).tipLinksCREATE(tipLinkCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Get data for a single Tip Link by id
     * @param {string} id The id of the record you wish to retrieve
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TipLinksApi
     */
    public tipLinksGET(id: string, userId?: string, options?: RawAxiosRequestConfig) {
        return TipLinksApiFp(this.configuration).tipLinksGET(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Get data for all Tip Links
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TipLinksApi
     */
    public tipLinksLIST(limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return TipLinksApiFp(this.configuration).tipLinksLIST(limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Search tip links based on contract id              Returns a list of <span class=\"TipLink\">TipLink</span>.</p>
     * summary Search tip links
     * @param {string} [contractId] The search for contract Id
     * @param {number} [limit] A limit of the number of objects to be returned for the next page, between 1 and 100.  The default is 25
     * @param {number} [page] 1-based page index for paginated results
     * @param {string} [userId] The user id to operate on their behalf (tenants only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TipLinksApi
     */
    public tipLinksSearch(contractId?: string, limit?: number, page?: number, userId?: string, options?: RawAxiosRequestConfig) {
        return TipLinksApiFp(this.configuration).tipLinksSearch(contractId, limit, page, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Make changes to an existing Tip Link
     * @param {string} id 
     * @param {TipLinkUpdateDeets} [tipLinkUpdateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof TipLinksApi
     */
    public tipLinksUpdate(id: string, tipLinkUpdateDeets?: TipLinkUpdateDeets, options?: RawAxiosRequestConfig) {
        return TipLinksApiFp(this.configuration).tipLinksUpdate(id, tipLinkUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPreferencesApi - axios parameter creator
 * export
 */
export const UserPreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferencesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PersonaSetting} [personaSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferencesPut: async (personaSetting?: PersonaSetting, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPreferencesApi - functional programming interface
 * export
 */
export const UserPreferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPreferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPreferencesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPreferencesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPreferencesApi.apiUserPreferencesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PersonaSetting} [personaSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPreferencesPut(personaSetting?: PersonaSetting, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPreferencesPut(personaSetting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPreferencesApi.apiUserPreferencesPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserPreferencesApi - factory interface
 * export
 */
export const UserPreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPreferencesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferencesGet(options?: RawAxiosRequestConfig): AxiosPromise<PersonaSetting> {
            return localVarFp.apiUserPreferencesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PersonaSetting} [personaSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferencesPut(personaSetting?: PersonaSetting, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUserPreferencesPut(personaSetting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPreferencesApi - object-oriented interface
 * export
 * @class UserPreferencesApi
 * @extends {BaseAPI}
 */
export class UserPreferencesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof UserPreferencesApi
     */
    public apiUserPreferencesGet(options?: RawAxiosRequestConfig) {
        return UserPreferencesApiFp(this.configuration).apiUserPreferencesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PersonaSetting} [personaSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof UserPreferencesApi
     */
    public apiUserPreferencesPut(personaSetting?: PersonaSetting, options?: RawAxiosRequestConfig) {
        return UserPreferencesApiFp(this.configuration).apiUserPreferencesPut(personaSetting, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserStatusesApi - axios parameter creator
 * export
 */
export const UserStatusesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>The UserStatus object provides information on whether              a user is fully on-boarded, can accept payouts and can charge payments</p>
         * summary Gets the UserStatus object
         * @param {string} [userId] UserId of the user (Tenant level access required)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserStatusesGet: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserStatusesApi - functional programming interface
 * export
 */
export const UserStatusesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserStatusesApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>The UserStatus object provides information on whether              a user is fully on-boarded, can accept payouts and can charge payments</p>
         * summary Gets the UserStatus object
         * @param {string} [userId] UserId of the user (Tenant level access required)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserStatusesGet(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserStatusesGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserStatusesApi.apiUserStatusesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserStatusesApi - factory interface
 * export
 */
export const UserStatusesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserStatusesApiFp(configuration)
    return {
        /**
         * <p>The UserStatus object provides information on whether              a user is fully on-boarded, can accept payouts and can charge payments</p>
         * summary Gets the UserStatus object
         * @param {string} [userId] UserId of the user (Tenant level access required)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserStatusesGet(userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserStatus> {
            return localVarFp.apiUserStatusesGet(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserStatusesApi - object-oriented interface
 * export
 * @class UserStatusesApi
 * @extends {BaseAPI}
 */
export class UserStatusesApi extends BaseAPI {
    /**
     * <p>The UserStatus object provides information on whether              a user is fully on-boarded, can accept payouts and can charge payments</p>
     * summary Gets the UserStatus object
     * @param {string} [userId] UserId of the user (Tenant level access required)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof UserStatusesApi
     */
    public apiUserStatusesGet(userId?: string, options?: RawAxiosRequestConfig) {
        return UserStatusesApiFp(this.configuration).apiUserStatusesGet(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VersionApi - axios parameter creator
 * export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVersionGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiVersionGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiVersionGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionApi.apiVersionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VersionApi - factory interface
 * export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVersionGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiVersionGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof VersionApi
     */
    public apiVersionGet(options?: RawAxiosRequestConfig) {
        return VersionApiFp(this.configuration).apiVersionGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WaitlistApi - axios parameter creator
 * export
 */
export const WaitlistApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Deletes the current user from the hubspot waitlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitlistDeleteContact: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/waitlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Gets the contact record of the current user if it exists. Can be used to check   if a user is on a waitlist at application login. It cannot return which waitlist the  user is currently on.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitlistGetContact: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/waitlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Add a contact to a waitlist.
         * @param {WaitlistDeets} [waitlistDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitlistPostContact: async (waitlistDeets?: WaitlistDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/waitlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(waitlistDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WaitlistApi - functional programming interface
 * export
 */
export const WaitlistApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WaitlistApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Deletes the current user from the hubspot waitlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitlistDeleteContact(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.waitlistDeleteContact(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WaitlistApi.waitlistDeleteContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Gets the contact record of the current user if it exists. Can be used to check   if a user is on a waitlist at application login. It cannot return which waitlist the  user is currently on.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitlistGetContact(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HubSpotContact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.waitlistGetContact(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WaitlistApi.waitlistGetContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Add a contact to a waitlist.
         * @param {WaitlistDeets} [waitlistDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitlistPostContact(waitlistDeets?: WaitlistDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HubSpotContact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.waitlistPostContact(waitlistDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WaitlistApi.waitlistPostContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WaitlistApi - factory interface
 * export
 */
export const WaitlistApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WaitlistApiFp(configuration)
    return {
        /**
         * 
         * summary Deletes the current user from the hubspot waitlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitlistDeleteContact(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.waitlistDeleteContact(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Gets the contact record of the current user if it exists. Can be used to check   if a user is on a waitlist at application login. It cannot return which waitlist the  user is currently on.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitlistGetContact(options?: RawAxiosRequestConfig): AxiosPromise<HubSpotContact> {
            return localVarFp.waitlistGetContact(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Add a contact to a waitlist.
         * @param {WaitlistDeets} [waitlistDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitlistPostContact(waitlistDeets?: WaitlistDeets, options?: RawAxiosRequestConfig): AxiosPromise<HubSpotContact> {
            return localVarFp.waitlistPostContact(waitlistDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WaitlistApi - object-oriented interface
 * export
 * @class WaitlistApi
 * @extends {BaseAPI}
 */
export class WaitlistApi extends BaseAPI {
    /**
     * 
     * summary Deletes the current user from the hubspot waitlist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WaitlistApi
     */
    public waitlistDeleteContact(options?: RawAxiosRequestConfig) {
        return WaitlistApiFp(this.configuration).waitlistDeleteContact(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Gets the contact record of the current user if it exists. Can be used to check   if a user is on a waitlist at application login. It cannot return which waitlist the  user is currently on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WaitlistApi
     */
    public waitlistGetContact(options?: RawAxiosRequestConfig) {
        return WaitlistApiFp(this.configuration).waitlistGetContact(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Add a contact to a waitlist.
     * @param {WaitlistDeets} [waitlistDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WaitlistApi
     */
    public waitlistPostContact(waitlistDeets?: WaitlistDeets, options?: RawAxiosRequestConfig) {
        return WaitlistApiFp(this.configuration).waitlistPostContact(waitlistDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletsApi - axios parameter creator
 * export
 */
export const WalletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * summary Get the balance for all wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsBalanceGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/wallets/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Get all wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Enable a wallet
         * @param {string} key The wallet key/identifier
         * @param {WalletEnableDeets} [walletEnableDeets] Details for the wallet to enable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyEnablePost: async (key: string, walletEnableDeets?: WalletEnableDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiWalletsKeyEnablePost', 'key', key)
            const localVarPath = `/api/wallets/{key}/enable`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletEnableDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Get a single wallet
         * @param {string} key The key/identifier for the wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyGet: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiWalletsKeyGet', 'key', key)
            const localVarPath = `/api/wallets/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Add a payment method to a wallet
         * @param {string} key The wallet key
         * @param {PaymentMethodCreateDeets} [paymentMethodCreateDeets] The payment method details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyPaymentMethodsPost: async (key: string, paymentMethodCreateDeets?: PaymentMethodCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiWalletsKeyPaymentMethodsPost', 'key', key)
            const localVarPath = `/api/wallets/{key}/payment-methods`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentMethodCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Update a card or bank payment method.
         * @param {string} key The wallet key
         * @param {PaymentMethodUpdateDeets} [paymentMethodUpdateDeets] Payment method update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyPaymentMethodsPut: async (key: string, paymentMethodUpdateDeets?: PaymentMethodUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiWalletsKeyPaymentMethodsPut', 'key', key)
            const localVarPath = `/api/wallets/{key}/payment-methods`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentMethodUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Set Wallet Default Payout Method
         * @param {string} key 
         * @param {PayoutMethodDefaultUpdateDeets} [payoutMethodDefaultUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyPaymentPayoutDefaultPost: async (key: string, payoutMethodDefaultUpdateDeets?: PayoutMethodDefaultUpdateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiWalletsKeyPaymentPayoutDefaultPost', 'key', key)
            const localVarPath = `/api/wallets/{key}/payment-payout-default`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutMethodDefaultUpdateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Add a payment/payout both method to a wallet
         * @param {string} key The wallet key
         * @param {PaymentPayoutMethodCreateDeets} [paymentPayoutMethodCreateDeets] The payment method details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyPaymentPayoutMethodsPost: async (key: string, paymentPayoutMethodCreateDeets?: PaymentPayoutMethodCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiWalletsKeyPaymentPayoutMethodsPost', 'key', key)
            const localVarPath = `/api/wallets/{key}/payment-payout-methods`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentPayoutMethodCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * summary Add a payout method to a wallet
         * @param {string} key The wallet key
         * @param {PayoutMethodCreateDeets} [payoutMethodCreateDeets] The payout method details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyPayoutMethodsPost: async (key: string, payoutMethodCreateDeets?: PayoutMethodCreateDeets, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('apiWalletsKeyPayoutMethodsPost', 'key', key)
            const localVarPath = `/api/wallets/{key}/payout-methods`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyScheme required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["openid", "profile", "email"], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payoutMethodCreateDeets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletsApi - functional programming interface
 * export
 */
export const WalletsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * summary Get the balance for all wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWalletsBalanceGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWalletsBalanceGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.apiWalletsBalanceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Get all wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWalletsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Wallet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWalletsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.apiWalletsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Enable a wallet
         * @param {string} key The wallet key/identifier
         * @param {WalletEnableDeets} [walletEnableDeets] Details for the wallet to enable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWalletsKeyEnablePost(key: string, walletEnableDeets?: WalletEnableDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWalletsKeyEnablePost(key, walletEnableDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.apiWalletsKeyEnablePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Get a single wallet
         * @param {string} key The key/identifier for the wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWalletsKeyGet(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWalletsKeyGet(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.apiWalletsKeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Add a payment method to a wallet
         * @param {string} key The wallet key
         * @param {PaymentMethodCreateDeets} [paymentMethodCreateDeets] The payment method details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWalletsKeyPaymentMethodsPost(key: string, paymentMethodCreateDeets?: PaymentMethodCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWalletsKeyPaymentMethodsPost(key, paymentMethodCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.apiWalletsKeyPaymentMethodsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Update a card or bank payment method.
         * @param {string} key The wallet key
         * @param {PaymentMethodUpdateDeets} [paymentMethodUpdateDeets] Payment method update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWalletsKeyPaymentMethodsPut(key: string, paymentMethodUpdateDeets?: PaymentMethodUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWalletsKeyPaymentMethodsPut(key, paymentMethodUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.apiWalletsKeyPaymentMethodsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Set Wallet Default Payout Method
         * @param {string} key 
         * @param {PayoutMethodDefaultUpdateDeets} [payoutMethodDefaultUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWalletsKeyPaymentPayoutDefaultPost(key: string, payoutMethodDefaultUpdateDeets?: PayoutMethodDefaultUpdateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWalletsKeyPaymentPayoutDefaultPost(key, payoutMethodDefaultUpdateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.apiWalletsKeyPaymentPayoutDefaultPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Add a payment/payout both method to a wallet
         * @param {string} key The wallet key
         * @param {PaymentPayoutMethodCreateDeets} [paymentPayoutMethodCreateDeets] The payment method details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWalletsKeyPaymentPayoutMethodsPost(key: string, paymentPayoutMethodCreateDeets?: PaymentPayoutMethodCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWalletsKeyPaymentPayoutMethodsPost(key, paymentPayoutMethodCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.apiWalletsKeyPaymentPayoutMethodsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * summary Add a payout method to a wallet
         * @param {string} key The wallet key
         * @param {PayoutMethodCreateDeets} [payoutMethodCreateDeets] The payout method details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWalletsKeyPayoutMethodsPost(key: string, payoutMethodCreateDeets?: PayoutMethodCreateDeets, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWalletsKeyPayoutMethodsPost(key, payoutMethodCreateDeets, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletsApi.apiWalletsKeyPayoutMethodsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletsApi - factory interface
 * export
 */
export const WalletsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletsApiFp(configuration)
    return {
        /**
         * 
         * summary Get the balance for all wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsBalanceGet(options?: RawAxiosRequestConfig): AxiosPromise<Balance> {
            return localVarFp.apiWalletsBalanceGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Get all wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Wallet>> {
            return localVarFp.apiWalletsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Enable a wallet
         * @param {string} key The wallet key/identifier
         * @param {WalletEnableDeets} [walletEnableDeets] Details for the wallet to enable
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyEnablePost(key: string, walletEnableDeets?: WalletEnableDeets, options?: RawAxiosRequestConfig): AxiosPromise<Wallet> {
            return localVarFp.apiWalletsKeyEnablePost(key, walletEnableDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Get a single wallet
         * @param {string} key The key/identifier for the wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyGet(key: string, options?: RawAxiosRequestConfig): AxiosPromise<Wallet> {
            return localVarFp.apiWalletsKeyGet(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Add a payment method to a wallet
         * @param {string} key The wallet key
         * @param {PaymentMethodCreateDeets} [paymentMethodCreateDeets] The payment method details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyPaymentMethodsPost(key: string, paymentMethodCreateDeets?: PaymentMethodCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiWalletsKeyPaymentMethodsPost(key, paymentMethodCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Update a card or bank payment method.
         * @param {string} key The wallet key
         * @param {PaymentMethodUpdateDeets} [paymentMethodUpdateDeets] Payment method update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyPaymentMethodsPut(key: string, paymentMethodUpdateDeets?: PaymentMethodUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiWalletsKeyPaymentMethodsPut(key, paymentMethodUpdateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Set Wallet Default Payout Method
         * @param {string} key 
         * @param {PayoutMethodDefaultUpdateDeets} [payoutMethodDefaultUpdateDeets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyPaymentPayoutDefaultPost(key: string, payoutMethodDefaultUpdateDeets?: PayoutMethodDefaultUpdateDeets, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiWalletsKeyPaymentPayoutDefaultPost(key, payoutMethodDefaultUpdateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Add a payment/payout both method to a wallet
         * @param {string} key The wallet key
         * @param {PaymentPayoutMethodCreateDeets} [paymentPayoutMethodCreateDeets] The payment method details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyPaymentPayoutMethodsPost(key: string, paymentPayoutMethodCreateDeets?: PaymentPayoutMethodCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiWalletsKeyPaymentPayoutMethodsPost(key, paymentPayoutMethodCreateDeets, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * summary Add a payout method to a wallet
         * @param {string} key The wallet key
         * @param {PayoutMethodCreateDeets} [payoutMethodCreateDeets] The payout method details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWalletsKeyPayoutMethodsPost(key: string, payoutMethodCreateDeets?: PayoutMethodCreateDeets, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiWalletsKeyPayoutMethodsPost(key, payoutMethodCreateDeets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletsApi - object-oriented interface
 * export
 * @class WalletsApi
 * @extends {BaseAPI}
 */
export class WalletsApi extends BaseAPI {
    /**
     * 
     * summary Get the balance for all wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WalletsApi
     */
    public apiWalletsBalanceGet(options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).apiWalletsBalanceGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Get all wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WalletsApi
     */
    public apiWalletsGet(options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).apiWalletsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Enable a wallet
     * @param {string} key The wallet key/identifier
     * @param {WalletEnableDeets} [walletEnableDeets] Details for the wallet to enable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WalletsApi
     */
    public apiWalletsKeyEnablePost(key: string, walletEnableDeets?: WalletEnableDeets, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).apiWalletsKeyEnablePost(key, walletEnableDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Get a single wallet
     * @param {string} key The key/identifier for the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WalletsApi
     */
    public apiWalletsKeyGet(key: string, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).apiWalletsKeyGet(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Add a payment method to a wallet
     * @param {string} key The wallet key
     * @param {PaymentMethodCreateDeets} [paymentMethodCreateDeets] The payment method details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WalletsApi
     */
    public apiWalletsKeyPaymentMethodsPost(key: string, paymentMethodCreateDeets?: PaymentMethodCreateDeets, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).apiWalletsKeyPaymentMethodsPost(key, paymentMethodCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Update a card or bank payment method.
     * @param {string} key The wallet key
     * @param {PaymentMethodUpdateDeets} [paymentMethodUpdateDeets] Payment method update details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WalletsApi
     */
    public apiWalletsKeyPaymentMethodsPut(key: string, paymentMethodUpdateDeets?: PaymentMethodUpdateDeets, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).apiWalletsKeyPaymentMethodsPut(key, paymentMethodUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Set Wallet Default Payout Method
     * @param {string} key 
     * @param {PayoutMethodDefaultUpdateDeets} [payoutMethodDefaultUpdateDeets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WalletsApi
     */
    public apiWalletsKeyPaymentPayoutDefaultPost(key: string, payoutMethodDefaultUpdateDeets?: PayoutMethodDefaultUpdateDeets, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).apiWalletsKeyPaymentPayoutDefaultPost(key, payoutMethodDefaultUpdateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Add a payment/payout both method to a wallet
     * @param {string} key The wallet key
     * @param {PaymentPayoutMethodCreateDeets} [paymentPayoutMethodCreateDeets] The payment method details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WalletsApi
     */
    public apiWalletsKeyPaymentPayoutMethodsPost(key: string, paymentPayoutMethodCreateDeets?: PaymentPayoutMethodCreateDeets, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).apiWalletsKeyPaymentPayoutMethodsPost(key, paymentPayoutMethodCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * summary Add a payout method to a wallet
     * @param {string} key The wallet key
     * @param {PayoutMethodCreateDeets} [payoutMethodCreateDeets] The payout method details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * memberof WalletsApi
     */
    public apiWalletsKeyPayoutMethodsPost(key: string, payoutMethodCreateDeets?: PayoutMethodCreateDeets, options?: RawAxiosRequestConfig) {
        return WalletsApiFp(this.configuration).apiWalletsKeyPayoutMethodsPost(key, payoutMethodCreateDeets, options).then((request) => request(this.axios, this.basePath));
    }
}



